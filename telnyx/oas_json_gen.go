// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"net/url"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes AccountSid as json.
func (s AccountSid) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AccountSid from json.
func (s *AccountSid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountSid to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AccountSid(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveCall) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("record_type")
		s.RecordType.Encode(e)
	}
	{
		e.FieldStart("call_session_id")
		e.Str(s.CallSessionID)
	}
	{
		e.FieldStart("call_leg_id")
		e.Str(s.CallLegID)
	}
	{
		e.FieldStart("call_control_id")
		e.Str(s.CallControlID)
	}
	{
		e.FieldStart("client_state")
		e.Str(s.ClientState)
	}
	{
		e.FieldStart("call_duration")
		e.Int(s.CallDuration)
	}
}

var jsonFieldsNameOfActiveCall = [6]string{
	0: "record_type",
	1: "call_session_id",
	2: "call_leg_id",
	3: "call_control_id",
	4: "client_state",
	5: "call_duration",
}

// Decode decodes ActiveCall from json.
func (s *ActiveCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveCall to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "call_session_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CallSessionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_session_id\"")
			}
		case "call_leg_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CallLegID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_leg_id\"")
			}
		case "call_control_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CallControlID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_control_id\"")
			}
		case "client_state":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ClientState = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "call_duration":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.CallDuration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveCall")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveCall) {
					name = jsonFieldsNameOfActiveCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveCallRecordType as json.
func (s ActiveCallRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActiveCallRecordType from json.
func (s *ActiveCallRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveCallRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActiveCallRecordType(v) {
	case ActiveCallRecordTypeCall:
		*s = ActiveCallRecordTypeCall
	default:
		*s = ActiveCallRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActiveCallRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveCallRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveCallsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveCallsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfActiveCallsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ActiveCallsResponse from json.
func (s *ActiveCallsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveCallsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]ActiveCall, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActiveCall
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveCallsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveCallsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveCallsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnchorsiteOverride as json.
func (s AnchorsiteOverride) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnchorsiteOverride from json.
func (s *AnchorsiteOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnchorsiteOverride to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnchorsiteOverride(v) {
	case AnchorsiteOverrideLatency:
		*s = AnchorsiteOverrideLatency
	case AnchorsiteOverrideChicagoIL:
		*s = AnchorsiteOverrideChicagoIL
	case AnchorsiteOverrideAshburnVA:
		*s = AnchorsiteOverrideAshburnVA
	case AnchorsiteOverrideSanJoseCA:
		*s = AnchorsiteOverrideSanJoseCA
	case AnchorsiteOverrideSydneyAustralia:
		*s = AnchorsiteOverrideSydneyAustralia
	case AnchorsiteOverrideAmsterdamNetherlands:
		*s = AnchorsiteOverrideAmsterdamNetherlands
	case AnchorsiteOverrideLondonUK:
		*s = AnchorsiteOverrideLondonUK
	case AnchorsiteOverrideTorontoCanada:
		*s = AnchorsiteOverrideTorontoCanada
	case AnchorsiteOverrideVancouverCanada:
		*s = AnchorsiteOverrideVancouverCanada
	case AnchorsiteOverrideFrankfurtGermany:
		*s = AnchorsiteOverrideFrankfurtGermany
	default:
		*s = AnchorsiteOverride(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnchorsiteOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnchorsiteOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerRequest) encodeFields(e *jx.Encoder) {
	{
		if s.BillingGroupID.Set {
			e.FieldStart("billing_group_id")
			s.BillingGroupID.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.CustomHeaders != nil {
			e.FieldStart("custom_headers")
			e.ArrStart()
			for _, elem := range s.CustomHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PreferredCodecs.Set {
			e.FieldStart("preferred_codecs")
			s.PreferredCodecs.Encode(e)
		}
	}
	{
		if s.SipHeaders != nil {
			e.FieldStart("sip_headers")
			e.ArrStart()
			for _, elem := range s.SipHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SoundModifications.Set {
			e.FieldStart("sound_modifications")
			s.SoundModifications.Encode(e)
		}
	}
	{
		if s.StreamURL.Set {
			e.FieldStart("stream_url")
			s.StreamURL.Encode(e)
		}
	}
	{
		if s.StreamTrack.Set {
			e.FieldStart("stream_track")
			s.StreamTrack.Encode(e)
		}
	}
	{
		if s.SendSilenceWhenIdle.Set {
			e.FieldStart("send_silence_when_idle")
			s.SendSilenceWhenIdle.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookURLMethod.Set {
			e.FieldStart("webhook_url_method")
			s.WebhookURLMethod.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerRequest = [12]string{
	0:  "billing_group_id",
	1:  "client_state",
	2:  "command_id",
	3:  "custom_headers",
	4:  "preferred_codecs",
	5:  "sip_headers",
	6:  "sound_modifications",
	7:  "stream_url",
	8:  "stream_track",
	9:  "send_silence_when_idle",
	10: "webhook_url",
	11: "webhook_url_method",
}

// Decode decodes AnswerRequest from json.
func (s *AnswerRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_group_id":
			if err := func() error {
				s.BillingGroupID.Reset()
				if err := s.BillingGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_group_id\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "custom_headers":
			if err := func() error {
				s.CustomHeaders = make([]CustomSipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomSipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomHeaders = append(s.CustomHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_headers\"")
			}
		case "preferred_codecs":
			if err := func() error {
				s.PreferredCodecs.Reset()
				if err := s.PreferredCodecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_codecs\"")
			}
		case "sip_headers":
			if err := func() error {
				s.SipHeaders = make([]SipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SipHeaders = append(s.SipHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_headers\"")
			}
		case "sound_modifications":
			if err := func() error {
				s.SoundModifications.Reset()
				if err := s.SoundModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sound_modifications\"")
			}
		case "stream_url":
			if err := func() error {
				s.StreamURL.Reset()
				if err := s.StreamURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_url\"")
			}
		case "stream_track":
			if err := func() error {
				s.StreamTrack.Reset()
				if err := s.StreamTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_track\"")
			}
		case "send_silence_when_idle":
			if err := func() error {
				s.SendSilenceWhenIdle.Reset()
				if err := s.SendSilenceWhenIdle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_silence_when_idle\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_url_method":
			if err := func() error {
				s.WebhookURLMethod.Reset()
				if err := s.WebhookURLMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url_method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestPreferredCodecs as json.
func (s AnswerRequestPreferredCodecs) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnswerRequestPreferredCodecs from json.
func (s *AnswerRequestPreferredCodecs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerRequestPreferredCodecs to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnswerRequestPreferredCodecs(v) {
	case AnswerRequestPreferredCodecsG722PCMUPCMAG729OPUSVP8H264:
		*s = AnswerRequestPreferredCodecsG722PCMUPCMAG729OPUSVP8H264
	default:
		*s = AnswerRequestPreferredCodecs(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnswerRequestPreferredCodecs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerRequestPreferredCodecs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestStreamTrack as json.
func (s AnswerRequestStreamTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnswerRequestStreamTrack from json.
func (s *AnswerRequestStreamTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerRequestStreamTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnswerRequestStreamTrack(v) {
	case AnswerRequestStreamTrackInboundTrack:
		*s = AnswerRequestStreamTrackInboundTrack
	case AnswerRequestStreamTrackOutboundTrack:
		*s = AnswerRequestStreamTrackOutboundTrack
	case AnswerRequestStreamTrackBothTracks:
		*s = AnswerRequestStreamTrackBothTracks
	default:
		*s = AnswerRequestStreamTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnswerRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestWebhookURLMethod as json.
func (s AnswerRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnswerRequestWebhookURLMethod from json.
func (s *AnswerRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerRequestWebhookURLMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnswerRequestWebhookURLMethod(v) {
	case AnswerRequestWebhookURLMethodPOST:
		*s = AnswerRequestWebhookURLMethodPOST
	case AnswerRequestWebhookURLMethodGET:
		*s = AnswerRequestWebhookURLMethodGET
	default:
		*s = AnswerRequestWebhookURLMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnswerRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplicationName as json.
func (s ApplicationName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ApplicationName from json.
func (s *ApplicationName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplicationName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ApplicationName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ApplicationName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApplicationName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Attempt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Attempt) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("http")
		s.HTTP.Encode(e)
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAttempt = [5]string{
	0: "status",
	1: "started_at",
	2: "finished_at",
	3: "http",
	4: "errors",
}

// Decode decodes Attempt from json.
func (s *Attempt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Attempt to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		case "http":
			if err := func() error {
				if err := s.HTTP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"http\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Attempt")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Attempt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Attempt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttemptStatus as json.
func (s AttemptStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AttemptStatus from json.
func (s *AttemptStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttemptStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AttemptStatus(v) {
	case AttemptStatusDelivered:
		*s = AttemptStatusDelivered
	case AttemptStatusFailed:
		*s = AttemptStatusFailed
	default:
		*s = AttemptStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AttemptStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttemptStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AudioTranscriptionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AudioTranscriptionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Segments != nil {
			e.FieldStart("segments")
			e.ArrStart()
			for _, elem := range s.Segments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAudioTranscriptionResponse = [3]string{
	0: "text",
	1: "duration",
	2: "segments",
}

// Decode decodes AudioTranscriptionResponse from json.
func (s *AudioTranscriptionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioTranscriptionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "segments":
			if err := func() error {
				s.Segments = make([]AudioTranscriptionResponseSegments, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AudioTranscriptionResponseSegments
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AudioTranscriptionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudioTranscriptionResponse) {
					name = jsonFieldsNameOfAudioTranscriptionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AudioTranscriptionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioTranscriptionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AudioTranscriptionResponseSegments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AudioTranscriptionResponseSegments) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("start")
		e.Float64(s.Start)
	}
	{
		e.FieldStart("end")
		e.Float64(s.End)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfAudioTranscriptionResponseSegments = [4]string{
	0: "id",
	1: "start",
	2: "end",
	3: "text",
}

// Decode decodes AudioTranscriptionResponseSegments from json.
func (s *AudioTranscriptionResponseSegments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioTranscriptionResponseSegments to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Start = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.End = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AudioTranscriptionResponseSegments")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudioTranscriptionResponseSegments) {
					name = jsonFieldsNameOfAudioTranscriptionResponseSegments[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AudioTranscriptionResponseSegments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioTranscriptionResponseSegments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AwsAccessKeyId as json.
func (s AwsAccessKeyId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AwsAccessKeyId from json.
func (s *AwsAccessKeyId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AwsAccessKeyId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AwsAccessKeyId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AwsAccessKeyId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AwsAccessKeyId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AwsSecretAccessKey as json.
func (s AwsSecretAccessKey) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AwsSecretAccessKey from json.
func (s *AwsSecretAccessKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AwsSecretAccessKey to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AwsSecretAccessKey(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AwsSecretAccessKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AwsSecretAccessKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AzureAccountKey as json.
func (s AzureAccountKey) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AzureAccountKey from json.
func (s *AzureAccountKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AzureAccountKey to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AzureAccountKey(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AzureAccountKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AzureAccountKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AzureAccountName as json.
func (s AzureAccountName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AzureAccountName from json.
func (s *AzureAccountName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AzureAccountName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AzureAccountName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AzureAccountName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AzureAccountName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AzureConfigurationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AzureConfigurationData) encodeFields(e *jx.Encoder) {
	{
		if s.Bucket.Set {
			e.FieldStart("bucket")
			s.Bucket.Encode(e)
		}
	}
	{
		if s.AccountName.Set {
			e.FieldStart("account_name")
			s.AccountName.Encode(e)
		}
	}
	{
		if s.AccountKey.Set {
			e.FieldStart("account_key")
			s.AccountKey.Encode(e)
		}
	}
}

var jsonFieldsNameOfAzureConfigurationData = [3]string{
	0: "bucket",
	1: "account_name",
	2: "account_key",
}

// Decode decodes AzureConfigurationData from json.
func (s *AzureConfigurationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AzureConfigurationData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bucket":
			if err := func() error {
				s.Bucket.Reset()
				if err := s.Bucket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucket\"")
			}
		case "account_name":
			if err := func() error {
				s.AccountName.Reset()
				if err := s.AccountName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_name\"")
			}
		case "account_key":
			if err := func() error {
				s.AccountKey.Reset()
				if err := s.AccountKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AzureConfigurationData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AzureConfigurationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AzureConfigurationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BridgeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BridgeRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("call_control_id")
		e.Str(s.CallControlID)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.Queue.Set {
			e.FieldStart("queue")
			s.Queue.Encode(e)
		}
	}
	{
		if s.VideoRoomID.Set {
			e.FieldStart("video_room_id")
			s.VideoRoomID.Encode(e)
		}
	}
	{
		if s.VideoRoomContext.Set {
			e.FieldStart("video_room_context")
			s.VideoRoomContext.Encode(e)
		}
	}
	{
		if s.ParkAfterUnbridge.Set {
			e.FieldStart("park_after_unbridge")
			s.ParkAfterUnbridge.Encode(e)
		}
	}
	{
		if s.PlayRingtone.Set {
			e.FieldStart("play_ringtone")
			s.PlayRingtone.Encode(e)
		}
	}
}

var jsonFieldsNameOfBridgeRequest = [8]string{
	0: "call_control_id",
	1: "client_state",
	2: "command_id",
	3: "queue",
	4: "video_room_id",
	5: "video_room_context",
	6: "park_after_unbridge",
	7: "play_ringtone",
}

// Decode decodes BridgeRequest from json.
func (s *BridgeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BridgeRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "call_control_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CallControlID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_control_id\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "queue":
			if err := func() error {
				s.Queue.Reset()
				if err := s.Queue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue\"")
			}
		case "video_room_id":
			if err := func() error {
				s.VideoRoomID.Reset()
				if err := s.VideoRoomID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_room_id\"")
			}
		case "video_room_context":
			if err := func() error {
				s.VideoRoomContext.Reset()
				if err := s.VideoRoomContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_room_context\"")
			}
		case "park_after_unbridge":
			if err := func() error {
				s.ParkAfterUnbridge.Reset()
				if err := s.ParkAfterUnbridge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"park_after_unbridge\"")
			}
		case "play_ringtone":
			if err := func() error {
				s.PlayRingtone.Reset()
				if err := s.PlayRingtone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"play_ringtone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BridgeRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBridgeRequest) {
					name = jsonFieldsNameOfBridgeRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BridgeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BridgeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Bucket as json.
func (s Bucket) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Bucket from json.
func (s *Bucket) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Bucket to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Bucket(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Bucket) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Bucket) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkCredentialRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkCredentialRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		e.FieldStart("connection_id")
		e.Str(s.ConnectionID)
	}
}

var jsonFieldsNameOfBulkCredentialRequest = [4]string{
	0: "name",
	1: "tag",
	2: "amount",
	3: "connection_id",
}

// Decode decodes BulkCredentialRequest from json.
func (s *BulkCredentialRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkCredentialRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "connection_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkCredentialRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkCredentialRequest) {
					name = jsonFieldsNameOfBulkCredentialRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkCredentialRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkCredentialRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkCredentialResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkCredentialResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkCredentialResponse = [1]string{
	0: "data",
}

// Decode decodes BulkCredentialResponse from json.
func (s *BulkCredentialResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkCredentialResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkCredentialResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkCredentialResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkCredentialResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkCredentialResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkCredentialResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Credentials.Set {
			e.FieldStart("credentials")
			s.Credentials.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkCredentialResponseData = [1]string{
	0: "credentials",
}

// Decode decodes BulkCredentialResponseData from json.
func (s *BulkCredentialResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkCredentialResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credentials":
			if err := func() error {
				s.Credentials.Reset()
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkCredentialResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkCredentialResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkCredentialResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteRoomRecordingsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteRoomRecordingsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkDeleteRoomRecordingsResponse = [1]string{
	0: "data",
}

// Decode decodes BulkDeleteRoomRecordingsResponse from json.
func (s *BulkDeleteRoomRecordingsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteRoomRecordingsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteRoomRecordingsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteRoomRecordingsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteRoomRecordingsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteRoomRecordingsResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteRoomRecordingsResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.RoomRecordings.Set {
			e.FieldStart("room_recordings")
			s.RoomRecordings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkDeleteRoomRecordingsResponseData = [1]string{
	0: "room_recordings",
}

// Decode decodes BulkDeleteRoomRecordingsResponseData from json.
func (s *BulkDeleteRoomRecordingsResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteRoomRecordingsResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "room_recordings":
			if err := func() error {
				s.RoomRecordings.Reset()
				if err := s.RoomRecordings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"room_recordings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteRoomRecordingsResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteRoomRecordingsResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteRoomRecordingsResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Call) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Call) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("record_type")
		s.RecordType.Encode(e)
	}
	{
		e.FieldStart("call_session_id")
		e.Str(s.CallSessionID)
	}
	{
		e.FieldStart("call_leg_id")
		e.Str(s.CallLegID)
	}
	{
		e.FieldStart("call_control_id")
		e.Str(s.CallControlID)
	}
	{
		e.FieldStart("is_alive")
		e.Bool(s.IsAlive)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CallDuration.Set {
			e.FieldStart("call_duration")
			s.CallDuration.Encode(e)
		}
	}
}

var jsonFieldsNameOfCall = [7]string{
	0: "record_type",
	1: "call_session_id",
	2: "call_leg_id",
	3: "call_control_id",
	4: "is_alive",
	5: "client_state",
	6: "call_duration",
}

// Decode decodes Call from json.
func (s *Call) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Call to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "call_session_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CallSessionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_session_id\"")
			}
		case "call_leg_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CallLegID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_leg_id\"")
			}
		case "call_control_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CallControlID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_control_id\"")
			}
		case "is_alive":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsAlive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_alive\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "call_duration":
			if err := func() error {
				s.CallDuration.Reset()
				if err := s.CallDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Call")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCall) {
					name = jsonFieldsNameOfCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Call) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Call) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallControlApplication) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallControlApplication) encodeFields(e *jx.Encoder) {
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.AnchorsiteOverride.Set {
			e.FieldStart("anchorsite_override")
			s.AnchorsiteOverride.Encode(e)
		}
	}
	{
		if s.ApplicationName.Set {
			e.FieldStart("application_name")
			s.ApplicationName.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.DtmfType.Set {
			e.FieldStart("dtmf_type")
			s.DtmfType.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeout.Set {
			e.FieldStart("first_command_timeout")
			s.FirstCommandTimeout.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeoutSecs.Set {
			e.FieldStart("first_command_timeout_secs")
			s.FirstCommandTimeoutSecs.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.WebhookAPIVersion.Set {
			e.FieldStart("webhook_api_version")
			s.WebhookAPIVersion.Encode(e)
		}
	}
	{
		if s.WebhookEventFailoverURL.Set {
			e.FieldStart("webhook_event_failover_url")
			s.WebhookEventFailoverURL.Encode(e)
		}
	}
	{
		if s.WebhookEventURL.Set {
			e.FieldStart("webhook_event_url")
			s.WebhookEventURL.Encode(e)
		}
	}
	{
		if s.WebhookTimeoutSecs.Set {
			e.FieldStart("webhook_timeout_secs")
			s.WebhookTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallControlApplication = [16]string{
	0:  "active",
	1:  "anchorsite_override",
	2:  "application_name",
	3:  "created_at",
	4:  "dtmf_type",
	5:  "first_command_timeout",
	6:  "first_command_timeout_secs",
	7:  "id",
	8:  "inbound",
	9:  "outbound",
	10: "record_type",
	11: "updated_at",
	12: "webhook_api_version",
	13: "webhook_event_failover_url",
	14: "webhook_event_url",
	15: "webhook_timeout_secs",
}

// Decode decodes CallControlApplication from json.
func (s *CallControlApplication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplication to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "anchorsite_override":
			if err := func() error {
				s.AnchorsiteOverride.Reset()
				if err := s.AnchorsiteOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anchorsite_override\"")
			}
		case "application_name":
			if err := func() error {
				s.ApplicationName.Reset()
				if err := s.ApplicationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_name\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "dtmf_type":
			if err := func() error {
				s.DtmfType.Reset()
				if err := s.DtmfType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtmf_type\"")
			}
		case "first_command_timeout":
			if err := func() error {
				s.FirstCommandTimeout.Reset()
				if err := s.FirstCommandTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout\"")
			}
		case "first_command_timeout_secs":
			if err := func() error {
				s.FirstCommandTimeoutSecs.Reset()
				if err := s.FirstCommandTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout_secs\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "webhook_api_version":
			if err := func() error {
				s.WebhookAPIVersion.Reset()
				if err := s.WebhookAPIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_api_version\"")
			}
		case "webhook_event_failover_url":
			if err := func() error {
				s.WebhookEventFailoverURL.Reset()
				if err := s.WebhookEventFailoverURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_event_failover_url\"")
			}
		case "webhook_event_url":
			if err := func() error {
				s.WebhookEventURL.Reset()
				if err := s.WebhookEventURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_event_url\"")
			}
		case "webhook_timeout_secs":
			if err := func() error {
				s.WebhookTimeoutSecs.Reset()
				if err := s.WebhookTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallControlApplication")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallControlApplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationAnchorsiteOverride as json.
func (s CallControlApplicationAnchorsiteOverride) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallControlApplicationAnchorsiteOverride from json.
func (s *CallControlApplicationAnchorsiteOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplicationAnchorsiteOverride to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallControlApplicationAnchorsiteOverride(v) {
	case CallControlApplicationAnchorsiteOverrideLatency:
		*s = CallControlApplicationAnchorsiteOverrideLatency
	case CallControlApplicationAnchorsiteOverrideChicagoIL:
		*s = CallControlApplicationAnchorsiteOverrideChicagoIL
	case CallControlApplicationAnchorsiteOverrideAshburnVA:
		*s = CallControlApplicationAnchorsiteOverrideAshburnVA
	case CallControlApplicationAnchorsiteOverrideSanJoseCA:
		*s = CallControlApplicationAnchorsiteOverrideSanJoseCA
	default:
		*s = CallControlApplicationAnchorsiteOverride(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallControlApplicationAnchorsiteOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplicationAnchorsiteOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationDtmfType as json.
func (s CallControlApplicationDtmfType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallControlApplicationDtmfType from json.
func (s *CallControlApplicationDtmfType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplicationDtmfType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallControlApplicationDtmfType(v) {
	case CallControlApplicationDtmfTypeRFC2833:
		*s = CallControlApplicationDtmfTypeRFC2833
	case CallControlApplicationDtmfTypeInband:
		*s = CallControlApplicationDtmfTypeInband
	case CallControlApplicationDtmfTypeSIPINFO:
		*s = CallControlApplicationDtmfTypeSIPINFO
	default:
		*s = CallControlApplicationDtmfType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallControlApplicationDtmfType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplicationDtmfType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallControlApplicationInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallControlApplicationInbound) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelLimit.Set {
			e.FieldStart("channel_limit")
			s.ChannelLimit.Encode(e)
		}
	}
	{
		if s.ShakenStirEnabled.Set {
			e.FieldStart("shaken_stir_enabled")
			s.ShakenStirEnabled.Encode(e)
		}
	}
	{
		if s.SipSubdomain.Set {
			e.FieldStart("sip_subdomain")
			s.SipSubdomain.Encode(e)
		}
	}
	{
		if s.SipSubdomainReceiveSettings.Set {
			e.FieldStart("sip_subdomain_receive_settings")
			s.SipSubdomainReceiveSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallControlApplicationInbound = [4]string{
	0: "channel_limit",
	1: "shaken_stir_enabled",
	2: "sip_subdomain",
	3: "sip_subdomain_receive_settings",
}

// Decode decodes CallControlApplicationInbound from json.
func (s *CallControlApplicationInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplicationInbound to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_limit":
			if err := func() error {
				s.ChannelLimit.Reset()
				if err := s.ChannelLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_limit\"")
			}
		case "shaken_stir_enabled":
			if err := func() error {
				s.ShakenStirEnabled.Reset()
				if err := s.ShakenStirEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shaken_stir_enabled\"")
			}
		case "sip_subdomain":
			if err := func() error {
				s.SipSubdomain.Reset()
				if err := s.SipSubdomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_subdomain\"")
			}
		case "sip_subdomain_receive_settings":
			if err := func() error {
				s.SipSubdomainReceiveSettings.Reset()
				if err := s.SipSubdomainReceiveSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_subdomain_receive_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallControlApplicationInbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallControlApplicationInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplicationInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationInboundSipSubdomainReceiveSettings as json.
func (s CallControlApplicationInboundSipSubdomainReceiveSettings) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallControlApplicationInboundSipSubdomainReceiveSettings from json.
func (s *CallControlApplicationInboundSipSubdomainReceiveSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplicationInboundSipSubdomainReceiveSettings to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallControlApplicationInboundSipSubdomainReceiveSettings(v) {
	case CallControlApplicationInboundSipSubdomainReceiveSettingsOnlyMyConnections:
		*s = CallControlApplicationInboundSipSubdomainReceiveSettingsOnlyMyConnections
	case CallControlApplicationInboundSipSubdomainReceiveSettingsFromAnyone:
		*s = CallControlApplicationInboundSipSubdomainReceiveSettingsFromAnyone
	default:
		*s = CallControlApplicationInboundSipSubdomainReceiveSettings(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallControlApplicationInboundSipSubdomainReceiveSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplicationInboundSipSubdomainReceiveSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallControlApplicationOutbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallControlApplicationOutbound) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelLimit.Set {
			e.FieldStart("channel_limit")
			s.ChannelLimit.Encode(e)
		}
	}
	{
		if s.OutboundVoiceProfileID.Set {
			e.FieldStart("outbound_voice_profile_id")
			s.OutboundVoiceProfileID.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallControlApplicationOutbound = [2]string{
	0: "channel_limit",
	1: "outbound_voice_profile_id",
}

// Decode decodes CallControlApplicationOutbound from json.
func (s *CallControlApplicationOutbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplicationOutbound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_limit":
			if err := func() error {
				s.ChannelLimit.Reset()
				if err := s.ChannelLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_limit\"")
			}
		case "outbound_voice_profile_id":
			if err := func() error {
				s.OutboundVoiceProfileID.Reset()
				if err := s.OutboundVoiceProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound_voice_profile_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallControlApplicationOutbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallControlApplicationOutbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplicationOutbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationRecordType as json.
func (s CallControlApplicationRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallControlApplicationRecordType from json.
func (s *CallControlApplicationRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplicationRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallControlApplicationRecordType(v) {
	case CallControlApplicationRecordTypeCallControlApplication:
		*s = CallControlApplicationRecordTypeCallControlApplication
	default:
		*s = CallControlApplicationRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallControlApplicationRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplicationRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallControlApplicationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallControlApplicationResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallControlApplicationResponse = [1]string{
	0: "data",
}

// Decode decodes CallControlApplicationResponse from json.
func (s *CallControlApplicationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplicationResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallControlApplicationResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallControlApplicationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplicationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationWebhookAPIVersion as json.
func (s CallControlApplicationWebhookAPIVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallControlApplicationWebhookAPIVersion from json.
func (s *CallControlApplicationWebhookAPIVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlApplicationWebhookAPIVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallControlApplicationWebhookAPIVersion(v) {
	case CallControlApplicationWebhookAPIVersion1:
		*s = CallControlApplicationWebhookAPIVersion1
	case CallControlApplicationWebhookAPIVersion2:
		*s = CallControlApplicationWebhookAPIVersion2
	default:
		*s = CallControlApplicationWebhookAPIVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallControlApplicationWebhookAPIVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlApplicationWebhookAPIVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallControlCommandResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallControlCommandResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallControlCommandResponse = [1]string{
	0: "data",
}

// Decode decodes CallControlCommandResponse from json.
func (s *CallControlCommandResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlCommandResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallControlCommandResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallControlCommandResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlCommandResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallControlCommandResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallControlCommandResult) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallControlCommandResult = [1]string{
	0: "result",
}

// Decode decodes CallControlCommandResult from json.
func (s *CallControlCommandResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlCommandResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallControlCommandResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallControlCommandResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlCommandResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlId as json.
func (s CallControlId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CallControlId from json.
func (s *CallControlId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CallControlId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallControlId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallReasons as json.
func (s CallReasons) Encode(e *jx.Encoder) {
	unwrapped := []CallReasonsItem(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes CallReasons from json.
func (s *CallReasons) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallReasons to nil")
	}
	var unwrapped []CallReasonsItem
	if err := func() error {
		unwrapped = make([]CallReasonsItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CallReasonsItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CallReasons(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallReasons) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallReasons) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallReasonsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallReasonsItem) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.GoogleVerificationStatus.Set {
			e.FieldStart("google_verification_status")
			s.GoogleVerificationStatus.Encode(e)
		}
	}
	{
		if s.GoogleApprovalInfo.Set {
			e.FieldStart("google_approval_info")
			s.GoogleApprovalInfo.Encode(e)
		}
	}
	{
		if s.DisplayProfileID.Set {
			e.FieldStart("display_profile_id")
			s.DisplayProfileID.Encode(e)
		}
	}
	{
		if s.Delete.Set {
			e.FieldStart("delete")
			s.Delete.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallReasonsItem = [7]string{
	0: "record_type",
	1: "id",
	2: "reason",
	3: "google_verification_status",
	4: "google_approval_info",
	5: "display_profile_id",
	6: "delete",
}

// Decode decodes CallReasonsItem from json.
func (s *CallReasonsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallReasonsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "google_verification_status":
			if err := func() error {
				s.GoogleVerificationStatus.Reset()
				if err := s.GoogleVerificationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_verification_status\"")
			}
		case "google_approval_info":
			if err := func() error {
				s.GoogleApprovalInfo.Reset()
				if err := s.GoogleApprovalInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_approval_info\"")
			}
		case "display_profile_id":
			if err := func() error {
				s.DisplayProfileID.Reset()
				if err := s.DisplayProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_profile_id\"")
			}
		case "delete":
			if err := func() error {
				s.Delete.Reset()
				if err := s.Delete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallReasonsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallReasonsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallReasonsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallReasonsItemGoogleVerificationStatus as json.
func (s CallReasonsItemGoogleVerificationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallReasonsItemGoogleVerificationStatus from json.
func (s *CallReasonsItemGoogleVerificationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallReasonsItemGoogleVerificationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallReasonsItemGoogleVerificationStatus(v) {
	case CallReasonsItemGoogleVerificationStatusSTATEUNSPECIFIED:
		*s = CallReasonsItemGoogleVerificationStatusSTATEUNSPECIFIED
	case CallReasonsItemGoogleVerificationStatusPENDINGAPPROVAL:
		*s = CallReasonsItemGoogleVerificationStatusPENDINGAPPROVAL
	case CallReasonsItemGoogleVerificationStatusAPPROVED:
		*s = CallReasonsItemGoogleVerificationStatusAPPROVED
	case CallReasonsItemGoogleVerificationStatusDENIED:
		*s = CallReasonsItemGoogleVerificationStatusDENIED
	case CallReasonsItemGoogleVerificationStatusPENDINGREMOVAL:
		*s = CallReasonsItemGoogleVerificationStatusPENDINGREMOVAL
	default:
		*s = CallReasonsItemGoogleVerificationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallReasonsItemGoogleVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallReasonsItemGoogleVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRecordType as json.
func (s CallRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRecordType from json.
func (s *CallRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRecordType(v) {
	case CallRecordTypeCall:
		*s = CallRecordTypeCall
	default:
		*s = CallRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("to")
		s.To.Encode(e)
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		if s.FromDisplayName.Set {
			e.FieldStart("from_display_name")
			s.FromDisplayName.Encode(e)
		}
	}
	{
		e.FieldStart("connection_id")
		e.Str(s.ConnectionID)
	}
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		if s.MediaName.Set {
			e.FieldStart("media_name")
			s.MediaName.Encode(e)
		}
	}
	{
		if s.PreferredCodecs.Set {
			e.FieldStart("preferred_codecs")
			s.PreferredCodecs.Encode(e)
		}
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
	{
		if s.TimeLimitSecs.Set {
			e.FieldStart("time_limit_secs")
			s.TimeLimitSecs.Encode(e)
		}
	}
	{
		if s.AnsweringMachineDetection.Set {
			e.FieldStart("answering_machine_detection")
			s.AnsweringMachineDetection.Encode(e)
		}
	}
	{
		if s.AnsweringMachineDetectionConfig.Set {
			e.FieldStart("answering_machine_detection_config")
			s.AnsweringMachineDetectionConfig.Encode(e)
		}
	}
	{
		if s.ConferenceConfig.Set {
			e.FieldStart("conference_config")
			s.ConferenceConfig.Encode(e)
		}
	}
	{
		if s.CustomHeaders != nil {
			e.FieldStart("custom_headers")
			e.ArrStart()
			for _, elem := range s.CustomHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BillingGroupID.Set {
			e.FieldStart("billing_group_id")
			s.BillingGroupID.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.LinkTo.Set {
			e.FieldStart("link_to")
			s.LinkTo.Encode(e)
		}
	}
	{
		if s.MediaEncryption.Set {
			e.FieldStart("media_encryption")
			s.MediaEncryption.Encode(e)
		}
	}
	{
		if s.SipAuthUsername.Set {
			e.FieldStart("sip_auth_username")
			s.SipAuthUsername.Encode(e)
		}
	}
	{
		if s.SipAuthPassword.Set {
			e.FieldStart("sip_auth_password")
			s.SipAuthPassword.Encode(e)
		}
	}
	{
		if s.SipHeaders != nil {
			e.FieldStart("sip_headers")
			e.ArrStart()
			for _, elem := range s.SipHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SipTransportProtocol.Set {
			e.FieldStart("sip_transport_protocol")
			s.SipTransportProtocol.Encode(e)
		}
	}
	{
		if s.SoundModifications.Set {
			e.FieldStart("sound_modifications")
			s.SoundModifications.Encode(e)
		}
	}
	{
		if s.StreamURL.Set {
			e.FieldStart("stream_url")
			s.StreamURL.Encode(e)
		}
	}
	{
		if s.StreamTrack.Set {
			e.FieldStart("stream_track")
			s.StreamTrack.Encode(e)
		}
	}
	{
		if s.SendSilenceWhenIdle.Set {
			e.FieldStart("send_silence_when_idle")
			s.SendSilenceWhenIdle.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookURLMethod.Set {
			e.FieldStart("webhook_url_method")
			s.WebhookURLMethod.Encode(e)
		}
	}
	{
		if s.Record.Set {
			e.FieldStart("record")
			s.Record.Encode(e)
		}
	}
	{
		if s.RecordChannels.Set {
			e.FieldStart("record_channels")
			s.RecordChannels.Encode(e)
		}
	}
	{
		if s.RecordFormat.Set {
			e.FieldStart("record_format")
			s.RecordFormat.Encode(e)
		}
	}
	{
		if s.RecordMaxLength.Set {
			e.FieldStart("record_max_length")
			s.RecordMaxLength.Encode(e)
		}
	}
	{
		if s.RecordTimeoutSecs.Set {
			e.FieldStart("record_timeout_secs")
			s.RecordTimeoutSecs.Encode(e)
		}
	}
	{
		if s.RecordTrim.Set {
			e.FieldStart("record_trim")
			s.RecordTrim.Encode(e)
		}
	}
	{
		if s.RecordCustomFileName.Set {
			e.FieldStart("record_custom_file_name")
			s.RecordCustomFileName.Encode(e)
		}
	}
	{
		if s.EnableDialogflow.Set {
			e.FieldStart("enable_dialogflow")
			s.EnableDialogflow.Encode(e)
		}
	}
	{
		if s.DialogflowConfig.Set {
			e.FieldStart("dialogflow_config")
			s.DialogflowConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallRequest = [37]string{
	0:  "to",
	1:  "from",
	2:  "from_display_name",
	3:  "connection_id",
	4:  "audio_url",
	5:  "media_name",
	6:  "preferred_codecs",
	7:  "timeout_secs",
	8:  "time_limit_secs",
	9:  "answering_machine_detection",
	10: "answering_machine_detection_config",
	11: "conference_config",
	12: "custom_headers",
	13: "billing_group_id",
	14: "client_state",
	15: "command_id",
	16: "link_to",
	17: "media_encryption",
	18: "sip_auth_username",
	19: "sip_auth_password",
	20: "sip_headers",
	21: "sip_transport_protocol",
	22: "sound_modifications",
	23: "stream_url",
	24: "stream_track",
	25: "send_silence_when_idle",
	26: "webhook_url",
	27: "webhook_url_method",
	28: "record",
	29: "record_channels",
	30: "record_format",
	31: "record_max_length",
	32: "record_timeout_secs",
	33: "record_trim",
	34: "record_custom_file_name",
	35: "enable_dialogflow",
	36: "dialogflow_config",
}

// Decode decodes CallRequest from json.
func (s *CallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequest to nil")
	}
	var requiredBitSet [5]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "to":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "from_display_name":
			if err := func() error {
				s.FromDisplayName.Reset()
				if err := s.FromDisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_display_name\"")
			}
		case "connection_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_id\"")
			}
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "media_name":
			if err := func() error {
				s.MediaName.Reset()
				if err := s.MediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_name\"")
			}
		case "preferred_codecs":
			if err := func() error {
				s.PreferredCodecs.Reset()
				if err := s.PreferredCodecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_codecs\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		case "time_limit_secs":
			if err := func() error {
				s.TimeLimitSecs.Reset()
				if err := s.TimeLimitSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit_secs\"")
			}
		case "answering_machine_detection":
			if err := func() error {
				s.AnsweringMachineDetection.Reset()
				if err := s.AnsweringMachineDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answering_machine_detection\"")
			}
		case "answering_machine_detection_config":
			if err := func() error {
				s.AnsweringMachineDetectionConfig.Reset()
				if err := s.AnsweringMachineDetectionConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answering_machine_detection_config\"")
			}
		case "conference_config":
			if err := func() error {
				s.ConferenceConfig.Reset()
				if err := s.ConferenceConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_config\"")
			}
		case "custom_headers":
			if err := func() error {
				s.CustomHeaders = make([]CustomSipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomSipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomHeaders = append(s.CustomHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_headers\"")
			}
		case "billing_group_id":
			if err := func() error {
				s.BillingGroupID.Reset()
				if err := s.BillingGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_group_id\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "link_to":
			if err := func() error {
				s.LinkTo.Reset()
				if err := s.LinkTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_to\"")
			}
		case "media_encryption":
			if err := func() error {
				s.MediaEncryption.Reset()
				if err := s.MediaEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_encryption\"")
			}
		case "sip_auth_username":
			if err := func() error {
				s.SipAuthUsername.Reset()
				if err := s.SipAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_username\"")
			}
		case "sip_auth_password":
			if err := func() error {
				s.SipAuthPassword.Reset()
				if err := s.SipAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_password\"")
			}
		case "sip_headers":
			if err := func() error {
				s.SipHeaders = make([]SipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SipHeaders = append(s.SipHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_headers\"")
			}
		case "sip_transport_protocol":
			if err := func() error {
				s.SipTransportProtocol.Reset()
				if err := s.SipTransportProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_transport_protocol\"")
			}
		case "sound_modifications":
			if err := func() error {
				s.SoundModifications.Reset()
				if err := s.SoundModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sound_modifications\"")
			}
		case "stream_url":
			if err := func() error {
				s.StreamURL.Reset()
				if err := s.StreamURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_url\"")
			}
		case "stream_track":
			if err := func() error {
				s.StreamTrack.Reset()
				if err := s.StreamTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_track\"")
			}
		case "send_silence_when_idle":
			if err := func() error {
				s.SendSilenceWhenIdle.Reset()
				if err := s.SendSilenceWhenIdle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_silence_when_idle\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_url_method":
			if err := func() error {
				s.WebhookURLMethod.Reset()
				if err := s.WebhookURLMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url_method\"")
			}
		case "record":
			if err := func() error {
				s.Record.Reset()
				if err := s.Record.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record\"")
			}
		case "record_channels":
			if err := func() error {
				s.RecordChannels.Reset()
				if err := s.RecordChannels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_channels\"")
			}
		case "record_format":
			if err := func() error {
				s.RecordFormat.Reset()
				if err := s.RecordFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_format\"")
			}
		case "record_max_length":
			if err := func() error {
				s.RecordMaxLength.Reset()
				if err := s.RecordMaxLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_max_length\"")
			}
		case "record_timeout_secs":
			if err := func() error {
				s.RecordTimeoutSecs.Reset()
				if err := s.RecordTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_timeout_secs\"")
			}
		case "record_trim":
			if err := func() error {
				s.RecordTrim.Reset()
				if err := s.RecordTrim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_trim\"")
			}
		case "record_custom_file_name":
			if err := func() error {
				s.RecordCustomFileName.Reset()
				if err := s.RecordCustomFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_custom_file_name\"")
			}
		case "enable_dialogflow":
			if err := func() error {
				s.EnableDialogflow.Reset()
				if err := s.EnableDialogflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_dialogflow\"")
			}
		case "dialogflow_config":
			if err := func() error {
				s.DialogflowConfig.Reset()
				if err := s.DialogflowConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogflow_config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00001011,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCallRequest) {
					name = jsonFieldsNameOfCallRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestAnsweringMachineDetection as json.
func (s CallRequestAnsweringMachineDetection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestAnsweringMachineDetection from json.
func (s *CallRequestAnsweringMachineDetection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestAnsweringMachineDetection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestAnsweringMachineDetection(v) {
	case CallRequestAnsweringMachineDetectionPremium:
		*s = CallRequestAnsweringMachineDetectionPremium
	case CallRequestAnsweringMachineDetectionDetect:
		*s = CallRequestAnsweringMachineDetectionDetect
	case CallRequestAnsweringMachineDetectionDetectBeep:
		*s = CallRequestAnsweringMachineDetectionDetectBeep
	case CallRequestAnsweringMachineDetectionDetectWords:
		*s = CallRequestAnsweringMachineDetectionDetectWords
	case CallRequestAnsweringMachineDetectionGreetingEnd:
		*s = CallRequestAnsweringMachineDetectionGreetingEnd
	case CallRequestAnsweringMachineDetectionDisabled:
		*s = CallRequestAnsweringMachineDetectionDisabled
	default:
		*s = CallRequestAnsweringMachineDetection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestAnsweringMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestAnsweringMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallRequestAnsweringMachineDetectionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallRequestAnsweringMachineDetectionConfig) encodeFields(e *jx.Encoder) {
	{
		if s.TotalAnalysisTimeMillis.Set {
			e.FieldStart("total_analysis_time_millis")
			s.TotalAnalysisTimeMillis.Encode(e)
		}
	}
	{
		if s.AfterGreetingSilenceMillis.Set {
			e.FieldStart("after_greeting_silence_millis")
			s.AfterGreetingSilenceMillis.Encode(e)
		}
	}
	{
		if s.BetweenWordsSilenceMillis.Set {
			e.FieldStart("between_words_silence_millis")
			s.BetweenWordsSilenceMillis.Encode(e)
		}
	}
	{
		if s.GreetingDurationMillis.Set {
			e.FieldStart("greeting_duration_millis")
			s.GreetingDurationMillis.Encode(e)
		}
	}
	{
		if s.InitialSilenceMillis.Set {
			e.FieldStart("initial_silence_millis")
			s.InitialSilenceMillis.Encode(e)
		}
	}
	{
		if s.MaximumNumberOfWords.Set {
			e.FieldStart("maximum_number_of_words")
			s.MaximumNumberOfWords.Encode(e)
		}
	}
	{
		if s.MaximumWordLengthMillis.Set {
			e.FieldStart("maximum_word_length_millis")
			s.MaximumWordLengthMillis.Encode(e)
		}
	}
	{
		if s.SilenceThreshold.Set {
			e.FieldStart("silence_threshold")
			s.SilenceThreshold.Encode(e)
		}
	}
	{
		if s.GreetingTotalAnalysisTimeMillis.Set {
			e.FieldStart("greeting_total_analysis_time_millis")
			s.GreetingTotalAnalysisTimeMillis.Encode(e)
		}
	}
	{
		if s.GreetingSilenceDurationMillis.Set {
			e.FieldStart("greeting_silence_duration_millis")
			s.GreetingSilenceDurationMillis.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallRequestAnsweringMachineDetectionConfig = [10]string{
	0: "total_analysis_time_millis",
	1: "after_greeting_silence_millis",
	2: "between_words_silence_millis",
	3: "greeting_duration_millis",
	4: "initial_silence_millis",
	5: "maximum_number_of_words",
	6: "maximum_word_length_millis",
	7: "silence_threshold",
	8: "greeting_total_analysis_time_millis",
	9: "greeting_silence_duration_millis",
}

// Decode decodes CallRequestAnsweringMachineDetectionConfig from json.
func (s *CallRequestAnsweringMachineDetectionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestAnsweringMachineDetectionConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_analysis_time_millis":
			if err := func() error {
				s.TotalAnalysisTimeMillis.Reset()
				if err := s.TotalAnalysisTimeMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_analysis_time_millis\"")
			}
		case "after_greeting_silence_millis":
			if err := func() error {
				s.AfterGreetingSilenceMillis.Reset()
				if err := s.AfterGreetingSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"after_greeting_silence_millis\"")
			}
		case "between_words_silence_millis":
			if err := func() error {
				s.BetweenWordsSilenceMillis.Reset()
				if err := s.BetweenWordsSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"between_words_silence_millis\"")
			}
		case "greeting_duration_millis":
			if err := func() error {
				s.GreetingDurationMillis.Reset()
				if err := s.GreetingDurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_duration_millis\"")
			}
		case "initial_silence_millis":
			if err := func() error {
				s.InitialSilenceMillis.Reset()
				if err := s.InitialSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_silence_millis\"")
			}
		case "maximum_number_of_words":
			if err := func() error {
				s.MaximumNumberOfWords.Reset()
				if err := s.MaximumNumberOfWords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_number_of_words\"")
			}
		case "maximum_word_length_millis":
			if err := func() error {
				s.MaximumWordLengthMillis.Reset()
				if err := s.MaximumWordLengthMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_word_length_millis\"")
			}
		case "silence_threshold":
			if err := func() error {
				s.SilenceThreshold.Reset()
				if err := s.SilenceThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"silence_threshold\"")
			}
		case "greeting_total_analysis_time_millis":
			if err := func() error {
				s.GreetingTotalAnalysisTimeMillis.Reset()
				if err := s.GreetingTotalAnalysisTimeMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_total_analysis_time_millis\"")
			}
		case "greeting_silence_duration_millis":
			if err := func() error {
				s.GreetingSilenceDurationMillis.Reset()
				if err := s.GreetingSilenceDurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_silence_duration_millis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallRequestAnsweringMachineDetectionConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallRequestAnsweringMachineDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestAnsweringMachineDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallRequestConferenceConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallRequestConferenceConfig) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ConferenceName.Set {
			e.FieldStart("conference_name")
			s.ConferenceName.Encode(e)
		}
	}
	{
		if s.EndConferenceOnExit.Set {
			e.FieldStart("end_conference_on_exit")
			s.EndConferenceOnExit.Encode(e)
		}
	}
	{
		if s.SoftEndConferenceOnExit.Set {
			e.FieldStart("soft_end_conference_on_exit")
			s.SoftEndConferenceOnExit.Encode(e)
		}
	}
	{
		if s.Hold.Set {
			e.FieldStart("hold")
			s.Hold.Encode(e)
		}
	}
	{
		if s.HoldAudioURL.Set {
			e.FieldStart("hold_audio_url")
			s.HoldAudioURL.Encode(e)
		}
	}
	{
		if s.HoldMediaName.Set {
			e.FieldStart("hold_media_name")
			s.HoldMediaName.Encode(e)
		}
	}
	{
		if s.Mute.Set {
			e.FieldStart("mute")
			s.Mute.Encode(e)
		}
	}
	{
		if s.StartConferenceOnEnter.Set {
			e.FieldStart("start_conference_on_enter")
			s.StartConferenceOnEnter.Encode(e)
		}
	}
	{
		if s.StartConferenceOnCreate.Set {
			e.FieldStart("start_conference_on_create")
			s.StartConferenceOnCreate.Encode(e)
		}
	}
	{
		if s.SupervisorRole.Set {
			e.FieldStart("supervisor_role")
			s.SupervisorRole.Encode(e)
		}
	}
	{
		if s.WhisperCallControlIds != nil {
			e.FieldStart("whisper_call_control_ids")
			e.ArrStart()
			for _, elem := range s.WhisperCallControlIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BeepEnabled.Set {
			e.FieldStart("beep_enabled")
			s.BeepEnabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallRequestConferenceConfig = [13]string{
	0:  "id",
	1:  "conference_name",
	2:  "end_conference_on_exit",
	3:  "soft_end_conference_on_exit",
	4:  "hold",
	5:  "hold_audio_url",
	6:  "hold_media_name",
	7:  "mute",
	8:  "start_conference_on_enter",
	9:  "start_conference_on_create",
	10: "supervisor_role",
	11: "whisper_call_control_ids",
	12: "beep_enabled",
}

// Decode decodes CallRequestConferenceConfig from json.
func (s *CallRequestConferenceConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestConferenceConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "conference_name":
			if err := func() error {
				s.ConferenceName.Reset()
				if err := s.ConferenceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_name\"")
			}
		case "end_conference_on_exit":
			if err := func() error {
				s.EndConferenceOnExit.Reset()
				if err := s.EndConferenceOnExit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_conference_on_exit\"")
			}
		case "soft_end_conference_on_exit":
			if err := func() error {
				s.SoftEndConferenceOnExit.Reset()
				if err := s.SoftEndConferenceOnExit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"soft_end_conference_on_exit\"")
			}
		case "hold":
			if err := func() error {
				s.Hold.Reset()
				if err := s.Hold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold\"")
			}
		case "hold_audio_url":
			if err := func() error {
				s.HoldAudioURL.Reset()
				if err := s.HoldAudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold_audio_url\"")
			}
		case "hold_media_name":
			if err := func() error {
				s.HoldMediaName.Reset()
				if err := s.HoldMediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold_media_name\"")
			}
		case "mute":
			if err := func() error {
				s.Mute.Reset()
				if err := s.Mute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mute\"")
			}
		case "start_conference_on_enter":
			if err := func() error {
				s.StartConferenceOnEnter.Reset()
				if err := s.StartConferenceOnEnter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_conference_on_enter\"")
			}
		case "start_conference_on_create":
			if err := func() error {
				s.StartConferenceOnCreate.Reset()
				if err := s.StartConferenceOnCreate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_conference_on_create\"")
			}
		case "supervisor_role":
			if err := func() error {
				s.SupervisorRole.Reset()
				if err := s.SupervisorRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supervisor_role\"")
			}
		case "whisper_call_control_ids":
			if err := func() error {
				s.WhisperCallControlIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhisperCallControlIds = append(s.WhisperCallControlIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whisper_call_control_ids\"")
			}
		case "beep_enabled":
			if err := func() error {
				s.BeepEnabled.Reset()
				if err := s.BeepEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beep_enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallRequestConferenceConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallRequestConferenceConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestConferenceConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfigBeepEnabled as json.
func (s CallRequestConferenceConfigBeepEnabled) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestConferenceConfigBeepEnabled from json.
func (s *CallRequestConferenceConfigBeepEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestConferenceConfigBeepEnabled to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestConferenceConfigBeepEnabled(v) {
	case CallRequestConferenceConfigBeepEnabledAlways:
		*s = CallRequestConferenceConfigBeepEnabledAlways
	case CallRequestConferenceConfigBeepEnabledNever:
		*s = CallRequestConferenceConfigBeepEnabledNever
	case CallRequestConferenceConfigBeepEnabledOnEnter:
		*s = CallRequestConferenceConfigBeepEnabledOnEnter
	case CallRequestConferenceConfigBeepEnabledOnExit:
		*s = CallRequestConferenceConfigBeepEnabledOnExit
	default:
		*s = CallRequestConferenceConfigBeepEnabled(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestConferenceConfigBeepEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestConferenceConfigBeepEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfigSupervisorRole as json.
func (s CallRequestConferenceConfigSupervisorRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestConferenceConfigSupervisorRole from json.
func (s *CallRequestConferenceConfigSupervisorRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestConferenceConfigSupervisorRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestConferenceConfigSupervisorRole(v) {
	case CallRequestConferenceConfigSupervisorRoleBarge:
		*s = CallRequestConferenceConfigSupervisorRoleBarge
	case CallRequestConferenceConfigSupervisorRoleMonitor:
		*s = CallRequestConferenceConfigSupervisorRoleMonitor
	case CallRequestConferenceConfigSupervisorRoleNone:
		*s = CallRequestConferenceConfigSupervisorRoleNone
	case CallRequestConferenceConfigSupervisorRoleWhisper:
		*s = CallRequestConferenceConfigSupervisorRoleWhisper
	default:
		*s = CallRequestConferenceConfigSupervisorRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestConferenceConfigSupervisorRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestConferenceConfigSupervisorRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestMediaEncryption as json.
func (s CallRequestMediaEncryption) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestMediaEncryption from json.
func (s *CallRequestMediaEncryption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestMediaEncryption to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestMediaEncryption(v) {
	case CallRequestMediaEncryptionDisabled:
		*s = CallRequestMediaEncryptionDisabled
	case CallRequestMediaEncryptionSRTP:
		*s = CallRequestMediaEncryptionSRTP
	default:
		*s = CallRequestMediaEncryption(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestMediaEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestMediaEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecord as json.
func (s CallRequestRecord) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestRecord from json.
func (s *CallRequestRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestRecord to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestRecord(v) {
	case CallRequestRecordRecordFromAnswer:
		*s = CallRequestRecordRecordFromAnswer
	default:
		*s = CallRequestRecord(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordChannels as json.
func (s CallRequestRecordChannels) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestRecordChannels from json.
func (s *CallRequestRecordChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestRecordChannels to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestRecordChannels(v) {
	case CallRequestRecordChannelsSingle:
		*s = CallRequestRecordChannelsSingle
	case CallRequestRecordChannelsDual:
		*s = CallRequestRecordChannelsDual
	default:
		*s = CallRequestRecordChannels(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestRecordChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestRecordChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordFormat as json.
func (s CallRequestRecordFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestRecordFormat from json.
func (s *CallRequestRecordFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestRecordFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestRecordFormat(v) {
	case CallRequestRecordFormatWav:
		*s = CallRequestRecordFormatWav
	case CallRequestRecordFormatMp3:
		*s = CallRequestRecordFormatMp3
	default:
		*s = CallRequestRecordFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestRecordFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestRecordFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordTrim as json.
func (s CallRequestRecordTrim) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestRecordTrim from json.
func (s *CallRequestRecordTrim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestRecordTrim to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestRecordTrim(v) {
	case CallRequestRecordTrimTrimSilence:
		*s = CallRequestRecordTrimTrimSilence
	default:
		*s = CallRequestRecordTrim(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestRecordTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestRecordTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestSipTransportProtocol as json.
func (s CallRequestSipTransportProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestSipTransportProtocol from json.
func (s *CallRequestSipTransportProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestSipTransportProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestSipTransportProtocol(v) {
	case CallRequestSipTransportProtocolUDP:
		*s = CallRequestSipTransportProtocolUDP
	case CallRequestSipTransportProtocolTCP:
		*s = CallRequestSipTransportProtocolTCP
	case CallRequestSipTransportProtocolTLS:
		*s = CallRequestSipTransportProtocolTLS
	default:
		*s = CallRequestSipTransportProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestSipTransportProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestSipTransportProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestStreamTrack as json.
func (s CallRequestStreamTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestStreamTrack from json.
func (s *CallRequestStreamTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestStreamTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestStreamTrack(v) {
	case CallRequestStreamTrackInboundTrack:
		*s = CallRequestStreamTrackInboundTrack
	case CallRequestStreamTrackOutboundTrack:
		*s = CallRequestStreamTrackOutboundTrack
	case CallRequestStreamTrackBothTracks:
		*s = CallRequestStreamTrackBothTracks
	default:
		*s = CallRequestStreamTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestTo as json.
func (s CallRequestTo) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringCallRequestTo:
		e.Str(s.String)
	case StringArrayCallRequestTo:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes CallRequestTo from json.
func (s *CallRequestTo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestTo to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayCallRequestTo
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringCallRequestTo
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestTo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestTo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestWebhookURLMethod as json.
func (s CallRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestWebhookURLMethod from json.
func (s *CallRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestWebhookURLMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestWebhookURLMethod(v) {
	case CallRequestWebhookURLMethodPOST:
		*s = CallRequestWebhookURLMethodPOST
	case CallRequestWebhookURLMethodGET:
		*s = CallRequestWebhookURLMethodGET
	default:
		*s = CallRequestWebhookURLMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.AnsweredBy.Set {
			e.FieldStart("answered_by")
			s.AnsweredBy.Encode(e)
		}
	}
	{
		if s.CallerName.Set {
			e.FieldStart("caller_name")
			s.CallerName.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.FromFormatted.Set {
			e.FieldStart("from_formatted")
			s.FromFormatted.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.PriceUnit.Set {
			e.FieldStart("price_unit")
			s.PriceUnit.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
	{
		if s.ToFormatted.Set {
			e.FieldStart("to_formatted")
			s.ToFormatted.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallResource = [18]string{
	0:  "account_sid",
	1:  "answered_by",
	2:  "caller_name",
	3:  "date_created",
	4:  "date_updated",
	5:  "direction",
	6:  "duration",
	7:  "end_time",
	8:  "from",
	9:  "from_formatted",
	10: "price",
	11: "price_unit",
	12: "sid",
	13: "start_time",
	14: "status",
	15: "to",
	16: "to_formatted",
	17: "uri",
}

// Decode decodes CallResource from json.
func (s *CallResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "answered_by":
			if err := func() error {
				s.AnsweredBy.Reset()
				if err := s.AnsweredBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answered_by\"")
			}
		case "caller_name":
			if err := func() error {
				s.CallerName.Reset()
				if err := s.CallerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caller_name\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "from_formatted":
			if err := func() error {
				s.FromFormatted.Reset()
				if err := s.FromFormatted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_formatted\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "price_unit":
			if err := func() error {
				s.PriceUnit.Reset()
				if err := s.PriceUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price_unit\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "to_formatted":
			if err := func() error {
				s.ToFormatted.Reset()
				if err := s.ToFormatted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_formatted\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceAnsweredBy as json.
func (s CallResourceAnsweredBy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallResourceAnsweredBy from json.
func (s *CallResourceAnsweredBy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResourceAnsweredBy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallResourceAnsweredBy(v) {
	case CallResourceAnsweredByHuman:
		*s = CallResourceAnsweredByHuman
	case CallResourceAnsweredByMachine:
		*s = CallResourceAnsweredByMachine
	case CallResourceAnsweredByNotSure:
		*s = CallResourceAnsweredByNotSure
	default:
		*s = CallResourceAnsweredBy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallResourceAnsweredBy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResourceAnsweredBy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceDirection as json.
func (s CallResourceDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallResourceDirection from json.
func (s *CallResourceDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResourceDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallResourceDirection(v) {
	case CallResourceDirectionInbound:
		*s = CallResourceDirectionInbound
	case CallResourceDirectionOutbound:
		*s = CallResourceDirectionOutbound
	default:
		*s = CallResourceDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallResourceDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResourceDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallResourceIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallResourceIndex) encodeFields(e *jx.Encoder) {
	{
		if s.Calls != nil {
			e.FieldStart("calls")
			e.ArrStart()
			for _, elem := range s.Calls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallResourceIndex = [8]string{
	0: "calls",
	1: "end",
	2: "first_page_uri",
	3: "next_page_uri",
	4: "page",
	5: "page_size",
	6: "start",
	7: "uri",
}

// Decode decodes CallResourceIndex from json.
func (s *CallResourceIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResourceIndex to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "calls":
			if err := func() error {
				s.Calls = make([]CallResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CallResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Calls = append(s.Calls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calls\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallResourceIndex")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceStatus as json.
func (s CallResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallResourceStatus from json.
func (s *CallResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallResourceStatus(v) {
	case CallResourceStatusRinging:
		*s = CallResourceStatusRinging
	case CallResourceStatusInProgress:
		*s = CallResourceStatusInProgress
	case CallResourceStatusCanceled:
		*s = CallResourceStatusCanceled
	case CallResourceStatusCompleted:
		*s = CallResourceStatusCompleted
	case CallResourceStatusFailed:
		*s = CallResourceStatusFailed
	case CallResourceStatusBusy:
		*s = CallResourceStatusBusy
	case CallResourceStatusNoAnswer:
		*s = CallResourceStatusNoAnswer
	default:
		*s = CallResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CdrGetSyncUsageReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CdrGetSyncUsageReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfCdrGetSyncUsageReportResponse = [1]string{
	0: "data",
}

// Decode decodes CdrGetSyncUsageReportResponse from json.
func (s *CdrGetSyncUsageReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CdrGetSyncUsageReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CdrGetSyncUsageReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CdrGetSyncUsageReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CdrGetSyncUsageReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CdrUsageReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CdrUsageReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Connections != nil {
			e.FieldStart("connections")
			e.ArrStart()
			for _, elem := range s.Connections {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AggregationType.Set {
			e.FieldStart("aggregation_type")
			s.AggregationType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ReportURL.Set {
			e.FieldStart("report_url")
			s.ReportURL.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.ProductBreakdown.Set {
			e.FieldStart("product_breakdown")
			s.ProductBreakdown.Encode(e)
		}
	}
}

var jsonFieldsNameOfCdrUsageReportResponse = [12]string{
	0:  "id",
	1:  "start_time",
	2:  "end_time",
	3:  "connections",
	4:  "aggregation_type",
	5:  "status",
	6:  "report_url",
	7:  "result",
	8:  "created_at",
	9:  "updated_at",
	10: "record_type",
	11: "product_breakdown",
}

// Decode decodes CdrUsageReportResponse from json.
func (s *CdrUsageReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CdrUsageReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "connections":
			if err := func() error {
				s.Connections = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.Connections = append(s.Connections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connections\"")
			}
		case "aggregation_type":
			if err := func() error {
				s.AggregationType.Reset()
				if err := s.AggregationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aggregation_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "report_url":
			if err := func() error {
				s.ReportURL.Reset()
				if err := s.ReportURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"report_url\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "product_breakdown":
			if err := func() error {
				s.ProductBreakdown.Reset()
				if err := s.ProductBreakdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product_breakdown\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CdrUsageReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CdrUsageReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CdrUsageReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CdrUsageReportResponseAggregationType as json.
func (s CdrUsageReportResponseAggregationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CdrUsageReportResponseAggregationType from json.
func (s *CdrUsageReportResponseAggregationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CdrUsageReportResponseAggregationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CdrUsageReportResponseAggregationType(v) {
	case CdrUsageReportResponseAggregationTypeNOAGGREGATION:
		*s = CdrUsageReportResponseAggregationTypeNOAGGREGATION
	case CdrUsageReportResponseAggregationTypeCONNECTION:
		*s = CdrUsageReportResponseAggregationTypeCONNECTION
	case CdrUsageReportResponseAggregationTypeTAG:
		*s = CdrUsageReportResponseAggregationTypeTAG
	case CdrUsageReportResponseAggregationTypeBILLINGGROUP:
		*s = CdrUsageReportResponseAggregationTypeBILLINGGROUP
	default:
		*s = CdrUsageReportResponseAggregationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CdrUsageReportResponseAggregationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CdrUsageReportResponseAggregationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CdrUsageReportResponseProductBreakdown as json.
func (s CdrUsageReportResponseProductBreakdown) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CdrUsageReportResponseProductBreakdown from json.
func (s *CdrUsageReportResponseProductBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CdrUsageReportResponseProductBreakdown to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CdrUsageReportResponseProductBreakdown(v) {
	case CdrUsageReportResponseProductBreakdownNOBREAKDOWN:
		*s = CdrUsageReportResponseProductBreakdownNOBREAKDOWN
	case CdrUsageReportResponseProductBreakdownDIDVSTOLLFREE:
		*s = CdrUsageReportResponseProductBreakdownDIDVSTOLLFREE
	case CdrUsageReportResponseProductBreakdownCOUNTRY:
		*s = CdrUsageReportResponseProductBreakdownCOUNTRY
	case CdrUsageReportResponseProductBreakdownDIDVSTOLLFREEPERCOUNTRY:
		*s = CdrUsageReportResponseProductBreakdownDIDVSTOLLFREEPERCOUNTRY
	default:
		*s = CdrUsageReportResponseProductBreakdown(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CdrUsageReportResponseProductBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CdrUsageReportResponseProductBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CdrUsageReportResponseResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CdrUsageReportResponseResult) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CdrUsageReportResponseResult from json.
func (s *CdrUsageReportResponseResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CdrUsageReportResponseResult to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CdrUsageReportResponseResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CdrUsageReportResponseResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CdrUsageReportResponseResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CdrUsageReportResponseStatus as json.
func (s CdrUsageReportResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CdrUsageReportResponseStatus from json.
func (s *CdrUsageReportResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CdrUsageReportResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CdrUsageReportResponseStatus(v) {
	case CdrUsageReportResponseStatusPENDING:
		*s = CdrUsageReportResponseStatusPENDING
	case CdrUsageReportResponseStatusCOMPLETE:
		*s = CdrUsageReportResponseStatusCOMPLETE
	case CdrUsageReportResponseStatusFAILED:
		*s = CdrUsageReportResponseStatusFAILED
	case CdrUsageReportResponseStatusEXPIRED:
		*s = CdrUsageReportResponseStatusEXPIRED
	default:
		*s = CdrUsageReportResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CdrUsageReportResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CdrUsageReportResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientStateUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientStateUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("client_state")
		e.Str(s.ClientState)
	}
}

var jsonFieldsNameOfClientStateUpdateRequest = [1]string{
	0: "client_state",
}

// Decode decodes ClientStateUpdateRequest from json.
func (s *ClientStateUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientStateUpdateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientState = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientStateUpdateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClientStateUpdateRequest) {
					name = jsonFieldsNameOfClientStateUpdateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientStateUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientStateUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConferenceRecordingResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConferenceRecordingResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.Channels.Set {
			e.FieldStart("channels")
			s.Channels.Encode(e)
		}
	}
	{
		if s.ConferenceSid.Set {
			e.FieldStart("conference_sid")
			s.ConferenceSid.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.MediaURL.Set {
			e.FieldStart("media_url")
			s.MediaURL.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.SubresourceUris.Set {
			e.FieldStart("subresource_uris")
			s.SubresourceUris.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfConferenceRecordingResource = [15]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "channels",
	3:  "conference_sid",
	4:  "date_created",
	5:  "date_updated",
	6:  "duration",
	7:  "error_code",
	8:  "media_url",
	9:  "sid",
	10: "source",
	11: "start_time",
	12: "status",
	13: "subresource_uris",
	14: "uri",
}

// Decode decodes ConferenceRecordingResource from json.
func (s *ConferenceRecordingResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "channels":
			if err := func() error {
				s.Channels.Reset()
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "conference_sid":
			if err := func() error {
				s.ConferenceSid.Reset()
				if err := s.ConferenceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_sid\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "media_url":
			if err := func() error {
				s.MediaURL.Reset()
				if err := s.MediaURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_url\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subresource_uris":
			if err := func() error {
				s.SubresourceUris.Reset()
				if err := s.SubresourceUris.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresource_uris\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceRecordingResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConferenceRecordingResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConferenceRecordingResourceIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConferenceRecordingResourceIndex) encodeFields(e *jx.Encoder) {
	{
		if s.Recordings != nil {
			e.FieldStart("recordings")
			e.ArrStart()
			for _, elem := range s.Recordings {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfConferenceRecordingResourceIndex = [8]string{
	0: "recordings",
	1: "end",
	2: "first_page_uri",
	3: "next_page_uri",
	4: "page",
	5: "page_size",
	6: "start",
	7: "uri",
}

// Decode decodes ConferenceRecordingResourceIndex from json.
func (s *ConferenceRecordingResourceIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResourceIndex to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recordings":
			if err := func() error {
				s.Recordings = make([]ConferenceRecordingResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConferenceRecordingResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Recordings = append(s.Recordings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordings\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceRecordingResourceIndex")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConferenceRecordingResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceSource as json.
func (s ConferenceRecordingResourceSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConferenceRecordingResourceSource from json.
func (s *ConferenceRecordingResourceSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResourceSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConferenceRecordingResourceSource(v) {
	case ConferenceRecordingResourceSourceDialVerb:
		*s = ConferenceRecordingResourceSourceDialVerb
	case ConferenceRecordingResourceSourceConference:
		*s = ConferenceRecordingResourceSourceConference
	case ConferenceRecordingResourceSourceOutboundAPI:
		*s = ConferenceRecordingResourceSourceOutboundAPI
	case ConferenceRecordingResourceSourceTrunking:
		*s = ConferenceRecordingResourceSourceTrunking
	case ConferenceRecordingResourceSourceRecordVerb:
		*s = ConferenceRecordingResourceSourceRecordVerb
	case ConferenceRecordingResourceSourceStartCallRecordingAPI:
		*s = ConferenceRecordingResourceSourceStartCallRecordingAPI
	case ConferenceRecordingResourceSourceStartConferenceRecordingAPI:
		*s = ConferenceRecordingResourceSourceStartConferenceRecordingAPI
	default:
		*s = ConferenceRecordingResourceSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceRecordingResourceSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResourceSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceStatus as json.
func (s ConferenceRecordingResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConferenceRecordingResourceStatus from json.
func (s *ConferenceRecordingResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConferenceRecordingResourceStatus(v) {
	case ConferenceRecordingResourceStatusProcessing:
		*s = ConferenceRecordingResourceStatusProcessing
	case ConferenceRecordingResourceStatusAbsent:
		*s = ConferenceRecordingResourceStatusAbsent
	case ConferenceRecordingResourceStatusCompleted:
		*s = ConferenceRecordingResourceStatusCompleted
	case ConferenceRecordingResourceStatusDeleted:
		*s = ConferenceRecordingResourceStatusDeleted
	default:
		*s = ConferenceRecordingResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceRecordingResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConferenceRecordingResourceSubresourceUris) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConferenceRecordingResourceSubresourceUris) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConferenceRecordingResourceSubresourceUris from json.
func (s *ConferenceRecordingResourceSubresourceUris) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResourceSubresourceUris to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceRecordingResourceSubresourceUris")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceRecordingResourceSubresourceUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResourceSubresourceUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConferenceResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConferenceResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.CallSidEndingConference.Set {
			e.FieldStart("call_sid_ending_conference")
			s.CallSidEndingConference.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.FriendlyName.Set {
			e.FieldStart("friendly_name")
			s.FriendlyName.Encode(e)
		}
	}
	{
		if s.ReasonConferenceEnded.Set {
			e.FieldStart("reason_conference_ended")
			s.ReasonConferenceEnded.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.SubresourceUris.Set {
			e.FieldStart("subresource_uris")
			s.SubresourceUris.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfConferenceResource = [12]string{
	0:  "account_sid",
	1:  "api_version",
	2:  "call_sid_ending_conference",
	3:  "date_created",
	4:  "date_updated",
	5:  "friendly_name",
	6:  "reason_conference_ended",
	7:  "region",
	8:  "sid",
	9:  "status",
	10: "subresource_uris",
	11: "uri",
}

// Decode decodes ConferenceResource from json.
func (s *ConferenceResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "call_sid_ending_conference":
			if err := func() error {
				s.CallSidEndingConference.Reset()
				if err := s.CallSidEndingConference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid_ending_conference\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "friendly_name":
			if err := func() error {
				s.FriendlyName.Reset()
				if err := s.FriendlyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friendly_name\"")
			}
		case "reason_conference_ended":
			if err := func() error {
				s.ReasonConferenceEnded.Reset()
				if err := s.ReasonConferenceEnded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason_conference_ended\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subresource_uris":
			if err := func() error {
				s.SubresourceUris.Reset()
				if err := s.SubresourceUris.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresource_uris\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConferenceResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConferenceResourceIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConferenceResourceIndex) encodeFields(e *jx.Encoder) {
	{
		if s.Conferences != nil {
			e.FieldStart("conferences")
			e.ArrStart()
			for _, elem := range s.Conferences {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfConferenceResourceIndex = [8]string{
	0: "conferences",
	1: "end",
	2: "first_page_uri",
	3: "next_page_uri",
	4: "page",
	5: "page_size",
	6: "start",
	7: "uri",
}

// Decode decodes ConferenceResourceIndex from json.
func (s *ConferenceResourceIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResourceIndex to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conferences":
			if err := func() error {
				s.Conferences = make([]ConferenceResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConferenceResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conferences = append(s.Conferences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conferences\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceResourceIndex")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConferenceResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceReasonConferenceEnded as json.
func (s ConferenceResourceReasonConferenceEnded) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConferenceResourceReasonConferenceEnded from json.
func (s *ConferenceResourceReasonConferenceEnded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResourceReasonConferenceEnded to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConferenceResourceReasonConferenceEnded(v) {
	case ConferenceResourceReasonConferenceEndedParticipantWithEndConferenceOnExitLeft:
		*s = ConferenceResourceReasonConferenceEndedParticipantWithEndConferenceOnExitLeft
	case ConferenceResourceReasonConferenceEndedLastParticipantLeft:
		*s = ConferenceResourceReasonConferenceEndedLastParticipantLeft
	case ConferenceResourceReasonConferenceEndedConferenceEndedViaAPI:
		*s = ConferenceResourceReasonConferenceEndedConferenceEndedViaAPI
	case ConferenceResourceReasonConferenceEndedTimeExceeded:
		*s = ConferenceResourceReasonConferenceEndedTimeExceeded
	default:
		*s = ConferenceResourceReasonConferenceEnded(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceResourceReasonConferenceEnded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResourceReasonConferenceEnded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceStatus as json.
func (s ConferenceResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConferenceResourceStatus from json.
func (s *ConferenceResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConferenceResourceStatus(v) {
	case ConferenceResourceStatusInit:
		*s = ConferenceResourceStatusInit
	case ConferenceResourceStatusInProgress:
		*s = ConferenceResourceStatusInProgress
	case ConferenceResourceStatusCompleted:
		*s = ConferenceResourceStatusCompleted
	default:
		*s = ConferenceResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConferenceResourceSubresourceUris) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConferenceResourceSubresourceUris) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConferenceResourceSubresourceUris from json.
func (s *ConferenceResourceSubresourceUris) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResourceSubresourceUris to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceResourceSubresourceUris")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceResourceSubresourceUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResourceSubresourceUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceSid as json.
func (s ConferenceSid) Encode(e *jx.Encoder) {
	unwrapped := uuid.UUID(s)

	json.EncodeUUID(e, unwrapped)
}

// Decode decodes ConferenceSid from json.
func (s *ConferenceSid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceSid to nil")
	}
	var unwrapped uuid.UUID
	if err := func() error {
		v, err := json.DecodeUUID(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConferenceSid(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConnectionActive as json.
func (s ConnectionActive) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes ConnectionActive from json.
func (s *ConnectionActive) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectionActive to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConnectionActive(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConnectionActive) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectionActive) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCallControlApplicationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCallControlApplicationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("application_name")
		e.Str(s.ApplicationName)
	}
	{
		e.FieldStart("webhook_event_url")
		e.Str(s.WebhookEventURL)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.AnchorsiteOverride.Set {
			e.FieldStart("anchorsite_override")
			s.AnchorsiteOverride.Encode(e)
		}
	}
	{
		if s.DtmfType.Set {
			e.FieldStart("dtmf_type")
			s.DtmfType.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeout.Set {
			e.FieldStart("first_command_timeout")
			s.FirstCommandTimeout.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeoutSecs.Set {
			e.FieldStart("first_command_timeout_secs")
			s.FirstCommandTimeoutSecs.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
	{
		if s.WebhookAPIVersion.Set {
			e.FieldStart("webhook_api_version")
			s.WebhookAPIVersion.Encode(e)
		}
	}
	{
		if s.WebhookEventFailoverURL.Set {
			e.FieldStart("webhook_event_failover_url")
			s.WebhookEventFailoverURL.Encode(e)
		}
	}
	{
		if s.WebhookTimeoutSecs.Set {
			e.FieldStart("webhook_timeout_secs")
			s.WebhookTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateCallControlApplicationRequest = [12]string{
	0:  "application_name",
	1:  "webhook_event_url",
	2:  "active",
	3:  "anchorsite_override",
	4:  "dtmf_type",
	5:  "first_command_timeout",
	6:  "first_command_timeout_secs",
	7:  "inbound",
	8:  "outbound",
	9:  "webhook_api_version",
	10: "webhook_event_failover_url",
	11: "webhook_timeout_secs",
}

// Decode decodes CreateCallControlApplicationRequest from json.
func (s *CreateCallControlApplicationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCallControlApplicationRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "application_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApplicationName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_name\"")
			}
		case "webhook_event_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WebhookEventURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_event_url\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "anchorsite_override":
			if err := func() error {
				s.AnchorsiteOverride.Reset()
				if err := s.AnchorsiteOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anchorsite_override\"")
			}
		case "dtmf_type":
			if err := func() error {
				s.DtmfType.Reset()
				if err := s.DtmfType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtmf_type\"")
			}
		case "first_command_timeout":
			if err := func() error {
				s.FirstCommandTimeout.Reset()
				if err := s.FirstCommandTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout\"")
			}
		case "first_command_timeout_secs":
			if err := func() error {
				s.FirstCommandTimeoutSecs.Reset()
				if err := s.FirstCommandTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout_secs\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		case "webhook_api_version":
			if err := func() error {
				s.WebhookAPIVersion.Reset()
				if err := s.WebhookAPIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_api_version\"")
			}
		case "webhook_event_failover_url":
			if err := func() error {
				s.WebhookEventFailoverURL.Reset()
				if err := s.WebhookEventFailoverURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_event_failover_url\"")
			}
		case "webhook_timeout_secs":
			if err := func() error {
				s.WebhookTimeoutSecs.Reset()
				if err := s.WebhookTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCallControlApplicationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCallControlApplicationRequest) {
					name = jsonFieldsNameOfCreateCallControlApplicationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCallControlApplicationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCallControlApplicationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCallControlApplicationRequestAnchorsiteOverride as json.
func (s CreateCallControlApplicationRequestAnchorsiteOverride) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateCallControlApplicationRequestAnchorsiteOverride from json.
func (s *CreateCallControlApplicationRequestAnchorsiteOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCallControlApplicationRequestAnchorsiteOverride to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateCallControlApplicationRequestAnchorsiteOverride(v) {
	case CreateCallControlApplicationRequestAnchorsiteOverrideLatency:
		*s = CreateCallControlApplicationRequestAnchorsiteOverrideLatency
	case CreateCallControlApplicationRequestAnchorsiteOverrideChicagoIL:
		*s = CreateCallControlApplicationRequestAnchorsiteOverrideChicagoIL
	case CreateCallControlApplicationRequestAnchorsiteOverrideAshburnVA:
		*s = CreateCallControlApplicationRequestAnchorsiteOverrideAshburnVA
	case CreateCallControlApplicationRequestAnchorsiteOverrideSanJoseCA:
		*s = CreateCallControlApplicationRequestAnchorsiteOverrideSanJoseCA
	default:
		*s = CreateCallControlApplicationRequestAnchorsiteOverride(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateCallControlApplicationRequestAnchorsiteOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCallControlApplicationRequestAnchorsiteOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCallControlApplicationRequestDtmfType as json.
func (s CreateCallControlApplicationRequestDtmfType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateCallControlApplicationRequestDtmfType from json.
func (s *CreateCallControlApplicationRequestDtmfType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCallControlApplicationRequestDtmfType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateCallControlApplicationRequestDtmfType(v) {
	case CreateCallControlApplicationRequestDtmfTypeRFC2833:
		*s = CreateCallControlApplicationRequestDtmfTypeRFC2833
	case CreateCallControlApplicationRequestDtmfTypeInband:
		*s = CreateCallControlApplicationRequestDtmfTypeInband
	case CreateCallControlApplicationRequestDtmfTypeSIPINFO:
		*s = CreateCallControlApplicationRequestDtmfTypeSIPINFO
	default:
		*s = CreateCallControlApplicationRequestDtmfType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateCallControlApplicationRequestDtmfType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCallControlApplicationRequestDtmfType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCallControlApplicationRequestWebhookAPIVersion as json.
func (s CreateCallControlApplicationRequestWebhookAPIVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateCallControlApplicationRequestWebhookAPIVersion from json.
func (s *CreateCallControlApplicationRequestWebhookAPIVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCallControlApplicationRequestWebhookAPIVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateCallControlApplicationRequestWebhookAPIVersion(v) {
	case CreateCallControlApplicationRequestWebhookAPIVersion1:
		*s = CreateCallControlApplicationRequestWebhookAPIVersion1
	case CreateCallControlApplicationRequestWebhookAPIVersion2:
		*s = CreateCallControlApplicationRequestWebhookAPIVersion2
	default:
		*s = CreateCallControlApplicationRequestWebhookAPIVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateCallControlApplicationRequestWebhookAPIVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCallControlApplicationRequestWebhookAPIVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeXMLSecretRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeXMLSecretRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfCreateTeXMLSecretRequest = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes CreateTeXMLSecretRequest from json.
func (s *CreateTeXMLSecretRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeXMLSecretRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeXMLSecretRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTeXMLSecretRequest) {
					name = jsonFieldsNameOfCreateTeXMLSecretRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeXMLSecretRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeXMLSecretRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeXMLSecretResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeXMLSecretResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTeXMLSecretResponse = [1]string{
	0: "data",
}

// Decode decodes CreateTeXMLSecretResponse from json.
func (s *CreateTeXMLSecretResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeXMLSecretResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeXMLSecretResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeXMLSecretResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeXMLSecretResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeXMLSecretResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeXMLSecretResult) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTeXMLSecretResult = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes CreateTeXMLSecretResult from json.
func (s *CreateTeXMLSecretResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeXMLSecretResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeXMLSecretResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeXMLSecretResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeXMLSecretResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTeXMLSecretResultValue as json.
func (s CreateTeXMLSecretResultValue) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateTeXMLSecretResultValue from json.
func (s *CreateTeXMLSecretResultValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeXMLSecretResultValue to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateTeXMLSecretResultValue(v) {
	case CreateTeXMLSecretResultValue_:
		*s = CreateTeXMLSecretResultValue_
	default:
		*s = CreateTeXMLSecretResultValue(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTeXMLSecretResultValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeXMLSecretResultValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationNotFound as json.
func (s *CreateTexmlApplicationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTexmlApplicationNotFound from json.
func (s *CreateTexmlApplicationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTexmlApplicationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTexmlApplicationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTexmlApplicationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTexmlApplicationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("friendly_name")
		s.FriendlyName.Encode(e)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.AnchorsiteOverride.Set {
			e.FieldStart("anchorsite_override")
			s.AnchorsiteOverride.Encode(e)
		}
	}
	{
		if s.DtmfType.Set {
			e.FieldStart("dtmf_type")
			s.DtmfType.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeout.Set {
			e.FieldStart("first_command_timeout")
			s.FirstCommandTimeout.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeoutSecs.Set {
			e.FieldStart("first_command_timeout_secs")
			s.FirstCommandTimeoutSecs.Encode(e)
		}
	}
	{
		e.FieldStart("voice_url")
		e.Str(s.VoiceURL)
	}
	{
		if s.VoiceFallbackURL.Set {
			e.FieldStart("voice_fallback_url")
			s.VoiceFallbackURL.Encode(e)
		}
	}
	{
		if s.VoiceMethod.Set {
			e.FieldStart("voice_method")
			s.VoiceMethod.Encode(e)
		}
	}
	{
		if s.StatusCallback.Set {
			e.FieldStart("status_callback")
			s.StatusCallback.Encode(e)
		}
	}
	{
		if s.StatusCallbackMethod.Set {
			e.FieldStart("status_callback_method")
			s.StatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTexmlApplicationRequest = [13]string{
	0:  "friendly_name",
	1:  "active",
	2:  "anchorsite_override",
	3:  "dtmf_type",
	4:  "first_command_timeout",
	5:  "first_command_timeout_secs",
	6:  "voice_url",
	7:  "voice_fallback_url",
	8:  "voice_method",
	9:  "status_callback",
	10: "status_callback_method",
	11: "inbound",
	12: "outbound",
}

// Decode decodes CreateTexmlApplicationRequest from json.
func (s *CreateTexmlApplicationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "friendly_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FriendlyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friendly_name\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "anchorsite_override":
			if err := func() error {
				s.AnchorsiteOverride.Reset()
				if err := s.AnchorsiteOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anchorsite_override\"")
			}
		case "dtmf_type":
			if err := func() error {
				s.DtmfType.Reset()
				if err := s.DtmfType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtmf_type\"")
			}
		case "first_command_timeout":
			if err := func() error {
				s.FirstCommandTimeout.Reset()
				if err := s.FirstCommandTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout\"")
			}
		case "first_command_timeout_secs":
			if err := func() error {
				s.FirstCommandTimeoutSecs.Reset()
				if err := s.FirstCommandTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout_secs\"")
			}
		case "voice_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.VoiceURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_url\"")
			}
		case "voice_fallback_url":
			if err := func() error {
				s.VoiceFallbackURL.Reset()
				if err := s.VoiceFallbackURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_fallback_url\"")
			}
		case "voice_method":
			if err := func() error {
				s.VoiceMethod.Reset()
				if err := s.VoiceMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_method\"")
			}
		case "status_callback":
			if err := func() error {
				s.StatusCallback.Reset()
				if err := s.StatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_callback\"")
			}
		case "status_callback_method":
			if err := func() error {
				s.StatusCallbackMethod.Reset()
				if err := s.StatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_callback_method\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTexmlApplicationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTexmlApplicationRequest) {
					name = jsonFieldsNameOfCreateTexmlApplicationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTexmlApplicationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTexmlApplicationRequestInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTexmlApplicationRequestInbound) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelLimit.Set {
			e.FieldStart("channel_limit")
			s.ChannelLimit.Encode(e)
		}
	}
	{
		if s.ShakenStirEnabled.Set {
			e.FieldStart("shaken_stir_enabled")
			s.ShakenStirEnabled.Encode(e)
		}
	}
	{
		if s.SipSubdomain.Set {
			e.FieldStart("sip_subdomain")
			s.SipSubdomain.Encode(e)
		}
	}
	{
		if s.SipSubdomainReceiveSettings.Set {
			e.FieldStart("sip_subdomain_receive_settings")
			s.SipSubdomainReceiveSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTexmlApplicationRequestInbound = [4]string{
	0: "channel_limit",
	1: "shaken_stir_enabled",
	2: "sip_subdomain",
	3: "sip_subdomain_receive_settings",
}

// Decode decodes CreateTexmlApplicationRequestInbound from json.
func (s *CreateTexmlApplicationRequestInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationRequestInbound to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_limit":
			if err := func() error {
				s.ChannelLimit.Reset()
				if err := s.ChannelLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_limit\"")
			}
		case "shaken_stir_enabled":
			if err := func() error {
				s.ShakenStirEnabled.Reset()
				if err := s.ShakenStirEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shaken_stir_enabled\"")
			}
		case "sip_subdomain":
			if err := func() error {
				s.SipSubdomain.Reset()
				if err := s.SipSubdomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_subdomain\"")
			}
		case "sip_subdomain_receive_settings":
			if err := func() error {
				s.SipSubdomainReceiveSettings.Reset()
				if err := s.SipSubdomainReceiveSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_subdomain_receive_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTexmlApplicationRequestInbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTexmlApplicationRequestInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationRequestInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings as json.
func (s CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings from json.
func (s *CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings(v) {
	case CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettingsOnlyMyConnections:
		*s = CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettingsOnlyMyConnections
	case CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettingsFromAnyone:
		*s = CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettingsFromAnyone
	default:
		*s = CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTexmlApplicationRequestOutbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTexmlApplicationRequestOutbound) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelLimit.Set {
			e.FieldStart("channel_limit")
			s.ChannelLimit.Encode(e)
		}
	}
	{
		if s.OutboundVoiceProfileID.Set {
			e.FieldStart("outbound_voice_profile_id")
			s.OutboundVoiceProfileID.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTexmlApplicationRequestOutbound = [2]string{
	0: "channel_limit",
	1: "outbound_voice_profile_id",
}

// Decode decodes CreateTexmlApplicationRequestOutbound from json.
func (s *CreateTexmlApplicationRequestOutbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationRequestOutbound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_limit":
			if err := func() error {
				s.ChannelLimit.Reset()
				if err := s.ChannelLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_limit\"")
			}
		case "outbound_voice_profile_id":
			if err := func() error {
				s.OutboundVoiceProfileID.Reset()
				if err := s.OutboundVoiceProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound_voice_profile_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTexmlApplicationRequestOutbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTexmlApplicationRequestOutbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationRequestOutbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationRequestStatusCallbackMethod as json.
func (s CreateTexmlApplicationRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateTexmlApplicationRequestStatusCallbackMethod from json.
func (s *CreateTexmlApplicationRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationRequestStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateTexmlApplicationRequestStatusCallbackMethod(v) {
	case CreateTexmlApplicationRequestStatusCallbackMethodGet:
		*s = CreateTexmlApplicationRequestStatusCallbackMethodGet
	case CreateTexmlApplicationRequestStatusCallbackMethodPost:
		*s = CreateTexmlApplicationRequestStatusCallbackMethodPost
	default:
		*s = CreateTexmlApplicationRequestStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTexmlApplicationRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationRequestVoiceMethod as json.
func (s CreateTexmlApplicationRequestVoiceMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateTexmlApplicationRequestVoiceMethod from json.
func (s *CreateTexmlApplicationRequestVoiceMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationRequestVoiceMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateTexmlApplicationRequestVoiceMethod(v) {
	case CreateTexmlApplicationRequestVoiceMethodGet:
		*s = CreateTexmlApplicationRequestVoiceMethodGet
	case CreateTexmlApplicationRequestVoiceMethodPost:
		*s = CreateTexmlApplicationRequestVoiceMethodPost
	default:
		*s = CreateTexmlApplicationRequestVoiceMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTexmlApplicationRequestVoiceMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationRequestVoiceMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationUnauthorized as json.
func (s *CreateTexmlApplicationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTexmlApplicationUnauthorized from json.
func (s *CreateTexmlApplicationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTexmlApplicationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTexmlApplicationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationUnprocessableEntity as json.
func (s *CreateTexmlApplicationUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTexmlApplicationUnprocessableEntity from json.
func (s *CreateTexmlApplicationUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTexmlApplicationUnprocessableEntity to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTexmlApplicationUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTexmlApplicationUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTexmlApplicationUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerificationRequestCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerificationRequestCall) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("verify_profile_id")
		json.EncodeUUID(e, s.VerifyProfileID)
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
	{
		if s.CallTimeoutSecs.Set {
			e.FieldStart("call_timeout_secs")
			s.CallTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerificationRequestCall = [4]string{
	0: "phone_number",
	1: "verify_profile_id",
	2: "timeout_secs",
	3: "call_timeout_secs",
}

// Decode decodes CreateVerificationRequestCall from json.
func (s *CreateVerificationRequestCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerificationRequestCall to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "verify_profile_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VerifyProfileID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_profile_id\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		case "call_timeout_secs":
			if err := func() error {
				s.CallTimeoutSecs.Reset()
				if err := s.CallTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerificationRequestCall")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVerificationRequestCall) {
					name = jsonFieldsNameOfCreateVerificationRequestCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerificationRequestCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerificationRequestCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerificationRequestFlashcall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerificationRequestFlashcall) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("verify_profile_id")
		json.EncodeUUID(e, s.VerifyProfileID)
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerificationRequestFlashcall = [3]string{
	0: "phone_number",
	1: "verify_profile_id",
	2: "timeout_secs",
}

// Decode decodes CreateVerificationRequestFlashcall from json.
func (s *CreateVerificationRequestFlashcall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerificationRequestFlashcall to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "verify_profile_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VerifyProfileID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_profile_id\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerificationRequestFlashcall")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVerificationRequestFlashcall) {
					name = jsonFieldsNameOfCreateVerificationRequestFlashcall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerificationRequestFlashcall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerificationRequestFlashcall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerificationRequestSMS) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerificationRequestSMS) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("verify_profile_id")
		json.EncodeUUID(e, s.VerifyProfileID)
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerificationRequestSMS = [3]string{
	0: "phone_number",
	1: "verify_profile_id",
	2: "timeout_secs",
}

// Decode decodes CreateVerificationRequestSMS from json.
func (s *CreateVerificationRequestSMS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerificationRequestSMS to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "verify_profile_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VerifyProfileID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_profile_id\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerificationRequestSMS")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVerificationRequestSMS) {
					name = jsonFieldsNameOfCreateVerificationRequestSMS[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerificationRequestSMS) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerificationRequestSMS) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerificationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerificationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateVerificationResponse = [1]string{
	0: "data",
}

// Decode decodes CreateVerificationResponse from json.
func (s *CreateVerificationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerificationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerificationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVerificationResponse) {
					name = jsonFieldsNameOfCreateVerificationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerificationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerificationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerifiedCallsDisplayProfileRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerifiedCallsDisplayProfileRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("business_identity_id")
		json.EncodeUUID(e, s.BusinessIdentityID)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("display_name")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.LogoURL.Set {
			e.FieldStart("logo_url")
			s.LogoURL.Encode(e)
		}
	}
	{
		if s.CallReasons != nil {
			e.FieldStart("call_reasons")
			s.CallReasons.Encode(e)
		}
	}
	{
		if s.PhoneNumbers != nil {
			e.FieldStart("phone_numbers")
			s.PhoneNumbers.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerifiedCallsDisplayProfileRequest = [6]string{
	0: "business_identity_id",
	1: "name",
	2: "display_name",
	3: "logo_url",
	4: "call_reasons",
	5: "phone_numbers",
}

// Decode decodes CreateVerifiedCallsDisplayProfileRequest from json.
func (s *CreateVerifiedCallsDisplayProfileRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerifiedCallsDisplayProfileRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_identity_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.BusinessIdentityID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_identity_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "logo_url":
			if err := func() error {
				s.LogoURL.Reset()
				if err := s.LogoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logo_url\"")
			}
		case "call_reasons":
			if err := func() error {
				if err := s.CallReasons.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_reasons\"")
			}
		case "phone_numbers":
			if err := func() error {
				if err := s.PhoneNumbers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_numbers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerifiedCallsDisplayProfileRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVerifiedCallsDisplayProfileRequest) {
					name = jsonFieldsNameOfCreateVerifiedCallsDisplayProfileRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerifiedCallsDisplayProfileRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerifiedCallsDisplayProfileRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerifiedNumberReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerifiedNumberReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("verification_method")
		s.VerificationMethod.Encode(e)
	}
}

var jsonFieldsNameOfCreateVerifiedNumberReq = [2]string{
	0: "phone_number",
	1: "verification_method",
}

// Decode decodes CreateVerifiedNumberReq from json.
func (s *CreateVerifiedNumberReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerifiedNumberReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "verification_method":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.VerificationMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerifiedNumberReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVerifiedNumberReq) {
					name = jsonFieldsNameOfCreateVerifiedNumberReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerifiedNumberReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerifiedNumberReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVerifiedNumberReqVerificationMethod as json.
func (s CreateVerifiedNumberReqVerificationMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateVerifiedNumberReqVerificationMethod from json.
func (s *CreateVerifiedNumberReqVerificationMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerifiedNumberReqVerificationMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateVerifiedNumberReqVerificationMethod(v) {
	case CreateVerifiedNumberReqVerificationMethodSMS:
		*s = CreateVerifiedNumberReqVerificationMethodSMS
	case CreateVerifiedNumberReqVerificationMethodCall:
		*s = CreateVerifiedNumberReqVerificationMethodCall
	default:
		*s = CreateVerifiedNumberReqVerificationMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateVerifiedNumberReqVerificationMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerifiedNumberReqVerificationMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerifiedNumberResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerifiedNumberResponse) encodeFields(e *jx.Encoder) {
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.VerificationMethod.Set {
			e.FieldStart("verification_method")
			s.VerificationMethod.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerifiedNumberResponse = [2]string{
	0: "phone_number",
	1: "verification_method",
}

// Decode decodes CreateVerifiedNumberResponse from json.
func (s *CreateVerifiedNumberResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerifiedNumberResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "verification_method":
			if err := func() error {
				s.VerificationMethod.Reset()
				if err := s.VerificationMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerifiedNumberResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerifiedNumberResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerifiedNumberResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerifyProfileCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerifyProfileCallRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MessagingTemplateID.Set {
			e.FieldStart("messaging_template_id")
			s.MessagingTemplateID.Encode(e)
		}
	}
	{
		if s.AppName.Set {
			e.FieldStart("app_name")
			s.AppName.Encode(e)
		}
	}
	{
		if s.WhitelistedDestinations != nil {
			e.FieldStart("whitelisted_destinations")
			e.ArrStart()
			for _, elem := range s.WhitelistedDestinations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerifyProfileCallRequest = [4]string{
	0: "messaging_template_id",
	1: "app_name",
	2: "whitelisted_destinations",
	3: "default_verification_timeout_secs",
}

// Decode decodes CreateVerifyProfileCallRequest from json.
func (s *CreateVerifyProfileCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerifyProfileCallRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messaging_template_id":
			if err := func() error {
				s.MessagingTemplateID.Reset()
				if err := s.MessagingTemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_template_id\"")
			}
		case "app_name":
			if err := func() error {
				s.AppName.Reset()
				if err := s.AppName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_name\"")
			}
		case "whitelisted_destinations":
			if err := func() error {
				s.WhitelistedDestinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedDestinations = append(s.WhitelistedDestinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_destinations\"")
			}
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerifyProfileCallRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerifyProfileCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerifyProfileCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerifyProfileFlashcallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerifyProfileFlashcallRequest) encodeFields(e *jx.Encoder) {
	{
		if s.WhitelistedDestinations != nil {
			e.FieldStart("whitelisted_destinations")
			e.ArrStart()
			for _, elem := range s.WhitelistedDestinations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerifyProfileFlashcallRequest = [2]string{
	0: "whitelisted_destinations",
	1: "default_verification_timeout_secs",
}

// Decode decodes CreateVerifyProfileFlashcallRequest from json.
func (s *CreateVerifyProfileFlashcallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerifyProfileFlashcallRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "whitelisted_destinations":
			if err := func() error {
				s.WhitelistedDestinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedDestinations = append(s.WhitelistedDestinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_destinations\"")
			}
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerifyProfileFlashcallRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerifyProfileFlashcallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerifyProfileFlashcallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerifyProfileReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerifyProfileReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookFailoverURL.Set {
			e.FieldStart("webhook_failover_url")
			s.WebhookFailoverURL.Encode(e)
		}
	}
	{
		if s.SMS.Set {
			e.FieldStart("sms")
			s.SMS.Encode(e)
		}
	}
	{
		if s.Call.Set {
			e.FieldStart("call")
			s.Call.Encode(e)
		}
	}
	{
		if s.Flashcall.Set {
			e.FieldStart("flashcall")
			s.Flashcall.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerifyProfileReq = [7]string{
	0: "name",
	1: "webhook_url",
	2: "webhook_failover_url",
	3: "sms",
	4: "call",
	5: "flashcall",
	6: "language",
}

// Decode decodes CreateVerifyProfileReq from json.
func (s *CreateVerifyProfileReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerifyProfileReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_failover_url":
			if err := func() error {
				s.WebhookFailoverURL.Reset()
				if err := s.WebhookFailoverURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_failover_url\"")
			}
		case "sms":
			if err := func() error {
				s.SMS.Reset()
				if err := s.SMS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms\"")
			}
		case "call":
			if err := func() error {
				s.Call.Reset()
				if err := s.Call.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call\"")
			}
		case "flashcall":
			if err := func() error {
				s.Flashcall.Reset()
				if err := s.Flashcall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flashcall\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerifyProfileReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVerifyProfileReq) {
					name = jsonFieldsNameOfCreateVerifyProfileReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerifyProfileReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerifyProfileReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVerifyProfileSMSRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVerifyProfileSMSRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MessagingTemplateID.Set {
			e.FieldStart("messaging_template_id")
			s.MessagingTemplateID.Encode(e)
		}
	}
	{
		if s.AppName.Set {
			e.FieldStart("app_name")
			s.AppName.Encode(e)
		}
	}
	{
		if s.AlphaSender.Set {
			e.FieldStart("alpha_sender")
			s.AlphaSender.Encode(e)
		}
	}
	{
		e.FieldStart("whitelisted_destinations")
		e.ArrStart()
		for _, elem := range s.WhitelistedDestinations {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVerifyProfileSMSRequest = [5]string{
	0: "messaging_template_id",
	1: "app_name",
	2: "alpha_sender",
	3: "whitelisted_destinations",
	4: "default_verification_timeout_secs",
}

// Decode decodes CreateVerifyProfileSMSRequest from json.
func (s *CreateVerifyProfileSMSRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVerifyProfileSMSRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messaging_template_id":
			if err := func() error {
				s.MessagingTemplateID.Reset()
				if err := s.MessagingTemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_template_id\"")
			}
		case "app_name":
			if err := func() error {
				s.AppName.Reset()
				if err := s.AppName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_name\"")
			}
		case "alpha_sender":
			if err := func() error {
				s.AlphaSender.Reset()
				if err := s.AlphaSender.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpha_sender\"")
			}
		case "whitelisted_destinations":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.WhitelistedDestinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedDestinations = append(s.WhitelistedDestinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_destinations\"")
			}
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVerifyProfileSMSRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateVerifyProfileSMSRequest) {
					name = jsonFieldsNameOfCreateVerifyProfileSMSRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVerifyProfileSMSRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVerifyProfileSMSRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatedAt as json.
func (s CreatedAt) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CreatedAt from json.
func (s *CreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatedAt to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreatedAt(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreatedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Credentials as json.
func (s Credentials) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Credentials from json.
func (s *Credentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Credentials to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Credentials(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Credentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Credentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CredentialsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CredentialsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		e.FieldStart("connection_id")
		e.Str(s.ConnectionID)
	}
	{
		e.FieldStart("record_type")
		s.RecordType.Encode(e)
	}
}

var jsonFieldsNameOfCredentialsResponse = [3]string{
	0: "data",
	1: "connection_id",
	2: "record_type",
}

// Decode decodes CredentialsResponse from json.
func (s *CredentialsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "connection_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_id\"")
			}
		case "record_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredentialsResponse) {
					name = jsonFieldsNameOfCredentialsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CredentialsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CredentialsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Cursor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Cursor) encodeFields(e *jx.Encoder) {
	{
		if s.After.Set {
			e.FieldStart("after")
			s.After.Encode(e)
		}
	}
	{
		if s.Before.Set {
			e.FieldStart("before")
			s.Before.Encode(e)
		}
	}
}

var jsonFieldsNameOfCursor = [2]string{
	0: "after",
	1: "before",
}

// Decode decodes Cursor from json.
func (s *Cursor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Cursor to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "after":
			if err := func() error {
				s.After.Reset()
				if err := s.After.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"after\"")
			}
		case "before":
			if err := func() error {
				s.Before.Reset()
				if err := s.Before.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"before\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Cursor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Cursor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Cursor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CursorPaginationMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CursorPaginationMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Cursors.Set {
			e.FieldStart("cursors")
			s.Cursors.Encode(e)
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
}

var jsonFieldsNameOfCursorPaginationMeta = [3]string{
	0: "cursors",
	1: "next",
	2: "previous",
}

// Decode decodes CursorPaginationMeta from json.
func (s *CursorPaginationMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CursorPaginationMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cursors":
			if err := func() error {
				s.Cursors.Reset()
				if err := s.Cursors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursors\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CursorPaginationMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CursorPaginationMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CursorPaginationMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomSipHeader) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomSipHeader) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfCustomSipHeader = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes CustomSipHeader from json.
func (s *CustomSipHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomSipHeader to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomSipHeader")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCustomSipHeader) {
					name = jsonFieldsNameOfCustomSipHeader[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomSipHeader) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomSipHeader) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomStorageConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomStorageConfiguration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("backend")
		s.Backend.Encode(e)
	}
	{
		e.FieldStart("configuration")
		s.Configuration.Encode(e)
	}
}

var jsonFieldsNameOfCustomStorageConfiguration = [2]string{
	0: "backend",
	1: "configuration",
}

// Decode decodes CustomStorageConfiguration from json.
func (s *CustomStorageConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomStorageConfiguration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backend":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Backend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backend\"")
			}
		case "configuration":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Configuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomStorageConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCustomStorageConfiguration) {
					name = jsonFieldsNameOfCustomStorageConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomStorageConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomStorageConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CustomStorageConfigurationBackend as json.
func (s CustomStorageConfigurationBackend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CustomStorageConfigurationBackend from json.
func (s *CustomStorageConfigurationBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomStorageConfigurationBackend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CustomStorageConfigurationBackend(v) {
	case CustomStorageConfigurationBackendGcs:
		*s = CustomStorageConfigurationBackendGcs
	case CustomStorageConfigurationBackendS3:
		*s = CustomStorageConfigurationBackendS3
	case CustomStorageConfigurationBackendAzure:
		*s = CustomStorageConfigurationBackendAzure
	default:
		*s = CustomStorageConfigurationBackend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CustomStorageConfigurationBackend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomStorageConfigurationBackend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CustomStorageConfigurationConfiguration as json.
func (s CustomStorageConfigurationConfiguration) Encode(e *jx.Encoder) {
	switch s.Type {
	case GCSConfigurationDataCustomStorageConfigurationConfiguration:
		s.GCSConfigurationData.Encode(e)
	case S3ConfigurationDataCustomStorageConfigurationConfiguration:
		s.S3ConfigurationData.Encode(e)
	case AzureConfigurationDataCustomStorageConfigurationConfiguration:
		s.AzureConfigurationData.Encode(e)
	}
}

func (s CustomStorageConfigurationConfiguration) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case GCSConfigurationDataCustomStorageConfigurationConfiguration:
		s.GCSConfigurationData.encodeFields(e)
	case S3ConfigurationDataCustomStorageConfigurationConfiguration:
		s.S3ConfigurationData.encodeFields(e)
	case AzureConfigurationDataCustomStorageConfigurationConfiguration:
		s.AzureConfigurationData.encodeFields(e)
	}
}

// Decode decodes CustomStorageConfigurationConfiguration from json.
func (s *CustomStorageConfigurationConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomStorageConfigurationConfiguration to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "credentials":
				match := GCSConfigurationDataCustomStorageConfigurationConfiguration
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "region":
				match := S3ConfigurationDataCustomStorageConfigurationConfiguration
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "aws_access_key_id":
				match := S3ConfigurationDataCustomStorageConfigurationConfiguration
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "aws_secret_access_key":
				match := S3ConfigurationDataCustomStorageConfigurationConfiguration
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "account_name":
				match := AzureConfigurationDataCustomStorageConfigurationConfiguration
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "account_key":
				match := AzureConfigurationDataCustomStorageConfigurationConfiguration
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GCSConfigurationDataCustomStorageConfigurationConfiguration:
		if err := s.GCSConfigurationData.Decode(d); err != nil {
			return err
		}
	case S3ConfigurationDataCustomStorageConfigurationConfiguration:
		if err := s.S3ConfigurationData.Decode(d); err != nil {
			return err
		}
	case AzureConfigurationDataCustomStorageConfigurationConfiguration:
		if err := s.AzureConfigurationData.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CustomStorageConfigurationConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomStorageConfigurationConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DateTimeRFC2822 as json.
func (s DateTimeRFC2822) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DateTimeRFC2822 from json.
func (s *DateTimeRFC2822) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DateTimeRFC2822 to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DateTimeRFC2822(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DateTimeRFC2822) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DateTimeRFC2822) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteTexmlApplicationBadRequest as json.
func (s *DeleteTexmlApplicationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteTexmlApplicationBadRequest from json.
func (s *DeleteTexmlApplicationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteTexmlApplicationBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteTexmlApplicationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteTexmlApplicationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteTexmlApplicationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteTexmlApplicationNotFound as json.
func (s *DeleteTexmlApplicationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteTexmlApplicationNotFound from json.
func (s *DeleteTexmlApplicationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteTexmlApplicationNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteTexmlApplicationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteTexmlApplicationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteTexmlApplicationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteTexmlApplicationUnauthorized as json.
func (s *DeleteTexmlApplicationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteTexmlApplicationUnauthorized from json.
func (s *DeleteTexmlApplicationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteTexmlApplicationUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteTexmlApplicationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteTexmlApplicationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteTexmlApplicationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVerifiedNumberNotFound as json.
func (s *DeleteVerifiedNumberNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Errors)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVerifiedNumberNotFound from json.
func (s *DeleteVerifiedNumberNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVerifiedNumberNotFound to nil")
	}
	var unwrapped Errors
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVerifiedNumberNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVerifiedNumberNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVerifiedNumberNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteVerifiedNumberUnauthorized as json.
func (s *DeleteVerifiedNumberUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Errors)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteVerifiedNumberUnauthorized from json.
func (s *DeleteVerifiedNumberUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVerifiedNumberUnauthorized to nil")
	}
	var unwrapped Errors
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteVerifiedNumberUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVerifiedNumberUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVerifiedNumberUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialParticipantResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialParticipantResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfDialParticipantResponse = [1]string{
	0: "data",
}

// Decode decodes DialParticipantResponse from json.
func (s *DialParticipantResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialParticipantResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialParticipantResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialParticipantResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialParticipantResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogflowConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogflowConfig) encodeFields(e *jx.Encoder) {
	{
		if s.AnalyzeSentiment.Set {
			e.FieldStart("analyze_sentiment")
			s.AnalyzeSentiment.Encode(e)
		}
	}
	{
		if s.PartialAutomatedAgentReply.Set {
			e.FieldStart("partial_automated_agent_reply")
			s.PartialAutomatedAgentReply.Encode(e)
		}
	}
}

var jsonFieldsNameOfDialogflowConfig = [2]string{
	0: "analyze_sentiment",
	1: "partial_automated_agent_reply",
}

// Decode decodes DialogflowConfig from json.
func (s *DialogflowConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogflowConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "analyze_sentiment":
			if err := func() error {
				s.AnalyzeSentiment.Reset()
				if err := s.AnalyzeSentiment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analyze_sentiment\"")
			}
		case "partial_automated_agent_reply":
			if err := func() error {
				s.PartialAutomatedAgentReply.Reset()
				if err := s.PartialAutomatedAgentReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partial_automated_agent_reply\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialogflowConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogflowConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogflowConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisplayName as json.
func (s DisplayName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DisplayName from json.
func (s *DisplayName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisplayName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DisplayName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DisplayName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisplayName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisplayVerifiedCallsDisplayProfileResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisplayVerifiedCallsDisplayProfileResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfDisplayVerifiedCallsDisplayProfileResponse = [1]string{
	0: "data",
}

// Decode decodes DisplayVerifiedCallsDisplayProfileResponse from json.
func (s *DisplayVerifiedCallsDisplayProfileResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisplayVerifiedCallsDisplayProfileResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisplayVerifiedCallsDisplayProfileResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisplayVerifiedCallsDisplayProfileResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisplayVerifiedCallsDisplayProfileResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DtmfType as json.
func (s DtmfType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DtmfType from json.
func (s *DtmfType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DtmfType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DtmfType(v) {
	case DtmfTypeRFC2833:
		*s = DtmfTypeRFC2833
	case DtmfTypeInband:
		*s = DtmfTypeInband
	case DtmfTypeSIPINFO:
		*s = DtmfTypeSIPINFO
	default:
		*s = DtmfType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DtmfType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DtmfType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnqueueRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnqueueRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("queue_name")
		e.Str(s.QueueName)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.MaxWaitTimeSecs.Set {
			e.FieldStart("max_wait_time_secs")
			s.MaxWaitTimeSecs.Encode(e)
		}
	}
	{
		if s.MaxSize.Set {
			e.FieldStart("max_size")
			s.MaxSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnqueueRequest = [5]string{
	0: "queue_name",
	1: "client_state",
	2: "command_id",
	3: "max_wait_time_secs",
	4: "max_size",
}

// Decode decodes EnqueueRequest from json.
func (s *EnqueueRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnqueueRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queue_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.QueueName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_name\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "max_wait_time_secs":
			if err := func() error {
				s.MaxWaitTimeSecs.Reset()
				if err := s.MaxWaitTimeSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_wait_time_secs\"")
			}
		case "max_size":
			if err := func() error {
				s.MaxSize.Reset()
				if err := s.MaxSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnqueueRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnqueueRequest) {
					name = jsonFieldsNameOfEnqueueRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnqueueRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnqueueRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		json.EncodeStringInt(e, s.Code)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [5]string{
	0: "code",
	1: "title",
	2: "detail",
	3: "source",
	4: "meta",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeStringInt(d)
				s.Code = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ErrorMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ErrorMeta) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ErrorMeta from json.
func (s *ErrorMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorMeta to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorRecord) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorRecord = [5]string{
	0: "code",
	1: "title",
	2: "detail",
	3: "source",
	4: "meta",
}

// Decode decodes ErrorRecord from json.
func (s *ErrorRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfErrorResponse = [1]string{
	0: "errors",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errors":
			if err := func() error {
				s.Errors = make([]ErrorRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ErrorRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorSource) encodeFields(e *jx.Encoder) {
	{
		if s.Pointer.Set {
			e.FieldStart("pointer")
			s.Pointer.Encode(e)
		}
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorSource = [2]string{
	0: "pointer",
	1: "parameter",
}

// Decode decodes ErrorSource from json.
func (s *ErrorSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pointer":
			if err := func() error {
				s.Pointer.Reset()
				if err := s.Pointer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pointer\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Errors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Errors) encodeFields(e *jx.Encoder) {
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfErrors = [1]string{
	0: "errors",
}

// Decode decodes Errors from json.
func (s *Errors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Errors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Errors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Errors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Errors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FindTexmlApplicationsBadRequest as json.
func (s *FindTexmlApplicationsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes FindTexmlApplicationsBadRequest from json.
func (s *FindTexmlApplicationsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindTexmlApplicationsBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FindTexmlApplicationsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindTexmlApplicationsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindTexmlApplicationsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FindTexmlApplicationsUnauthorized as json.
func (s *FindTexmlApplicationsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes FindTexmlApplicationsUnauthorized from json.
func (s *FindTexmlApplicationsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindTexmlApplicationsUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FindTexmlApplicationsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindTexmlApplicationsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindTexmlApplicationsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FirstCommandTimeout as json.
func (s FirstCommandTimeout) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes FirstCommandTimeout from json.
func (s *FirstCommandTimeout) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FirstCommandTimeout to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FirstCommandTimeout(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FirstCommandTimeout) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FirstCommandTimeout) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FirstCommandTimeoutSecs as json.
func (s FirstCommandTimeoutSecs) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes FirstCommandTimeoutSecs from json.
func (s *FirstCommandTimeoutSecs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FirstCommandTimeoutSecs to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FirstCommandTimeoutSecs(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FirstCommandTimeoutSecs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FirstCommandTimeoutSecs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GCSConfigurationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GCSConfigurationData) encodeFields(e *jx.Encoder) {
	{
		if s.Credentials.Set {
			e.FieldStart("credentials")
			s.Credentials.Encode(e)
		}
	}
	{
		if s.Bucket.Set {
			e.FieldStart("bucket")
			s.Bucket.Encode(e)
		}
	}
}

var jsonFieldsNameOfGCSConfigurationData = [2]string{
	0: "credentials",
	1: "bucket",
}

// Decode decodes GCSConfigurationData from json.
func (s *GCSConfigurationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GCSConfigurationData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credentials":
			if err := func() error {
				s.Credentials.Reset()
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		case "bucket":
			if err := func() error {
				s.Bucket.Reset()
				if err := s.Bucket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucket\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GCSConfigurationData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GCSConfigurationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GCSConfigurationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GatherRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GatherRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MinimumDigits.Set {
			e.FieldStart("minimum_digits")
			s.MinimumDigits.Encode(e)
		}
	}
	{
		if s.MaximumDigits.Set {
			e.FieldStart("maximum_digits")
			s.MaximumDigits.Encode(e)
		}
	}
	{
		if s.TimeoutMillis.Set {
			e.FieldStart("timeout_millis")
			s.TimeoutMillis.Encode(e)
		}
	}
	{
		if s.InterDigitTimeoutMillis.Set {
			e.FieldStart("inter_digit_timeout_millis")
			s.InterDigitTimeoutMillis.Encode(e)
		}
	}
	{
		if s.InitialTimeoutMillis.Set {
			e.FieldStart("initial_timeout_millis")
			s.InitialTimeoutMillis.Encode(e)
		}
	}
	{
		if s.TerminatingDigit.Set {
			e.FieldStart("terminating_digit")
			s.TerminatingDigit.Encode(e)
		}
	}
	{
		if s.ValidDigits.Set {
			e.FieldStart("valid_digits")
			s.ValidDigits.Encode(e)
		}
	}
	{
		if s.GatherID.Set {
			e.FieldStart("gather_id")
			s.GatherID.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGatherRequest = [10]string{
	0: "minimum_digits",
	1: "maximum_digits",
	2: "timeout_millis",
	3: "inter_digit_timeout_millis",
	4: "initial_timeout_millis",
	5: "terminating_digit",
	6: "valid_digits",
	7: "gather_id",
	8: "client_state",
	9: "command_id",
}

// Decode decodes GatherRequest from json.
func (s *GatherRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minimum_digits":
			if err := func() error {
				s.MinimumDigits.Reset()
				if err := s.MinimumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_digits\"")
			}
		case "maximum_digits":
			if err := func() error {
				s.MaximumDigits.Reset()
				if err := s.MaximumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_digits\"")
			}
		case "timeout_millis":
			if err := func() error {
				s.TimeoutMillis.Reset()
				if err := s.TimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_millis\"")
			}
		case "inter_digit_timeout_millis":
			if err := func() error {
				s.InterDigitTimeoutMillis.Reset()
				if err := s.InterDigitTimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inter_digit_timeout_millis\"")
			}
		case "initial_timeout_millis":
			if err := func() error {
				s.InitialTimeoutMillis.Reset()
				if err := s.InitialTimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_timeout_millis\"")
			}
		case "terminating_digit":
			if err := func() error {
				s.TerminatingDigit.Reset()
				if err := s.TerminatingDigit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating_digit\"")
			}
		case "valid_digits":
			if err := func() error {
				s.ValidDigits.Reset()
				if err := s.ValidDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid_digits\"")
			}
		case "gather_id":
			if err := func() error {
				s.GatherID.Reset()
				if err := s.GatherID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gather_id\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatherRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GatherRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GatherUsingAudioRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GatherUsingAudioRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		if s.MediaName.Set {
			e.FieldStart("media_name")
			s.MediaName.Encode(e)
		}
	}
	{
		if s.InvalidAudioURL.Set {
			e.FieldStart("invalid_audio_url")
			s.InvalidAudioURL.Encode(e)
		}
	}
	{
		if s.InvalidMediaName.Set {
			e.FieldStart("invalid_media_name")
			s.InvalidMediaName.Encode(e)
		}
	}
	{
		if s.MinimumDigits.Set {
			e.FieldStart("minimum_digits")
			s.MinimumDigits.Encode(e)
		}
	}
	{
		if s.MaximumDigits.Set {
			e.FieldStart("maximum_digits")
			s.MaximumDigits.Encode(e)
		}
	}
	{
		if s.MaximumTries.Set {
			e.FieldStart("maximum_tries")
			s.MaximumTries.Encode(e)
		}
	}
	{
		if s.TimeoutMillis.Set {
			e.FieldStart("timeout_millis")
			s.TimeoutMillis.Encode(e)
		}
	}
	{
		if s.TerminatingDigit.Set {
			e.FieldStart("terminating_digit")
			s.TerminatingDigit.Encode(e)
		}
	}
	{
		if s.ValidDigits.Set {
			e.FieldStart("valid_digits")
			s.ValidDigits.Encode(e)
		}
	}
	{
		if s.InterDigitTimeoutMillis.Set {
			e.FieldStart("inter_digit_timeout_millis")
			s.InterDigitTimeoutMillis.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGatherUsingAudioRequest = [13]string{
	0:  "audio_url",
	1:  "media_name",
	2:  "invalid_audio_url",
	3:  "invalid_media_name",
	4:  "minimum_digits",
	5:  "maximum_digits",
	6:  "maximum_tries",
	7:  "timeout_millis",
	8:  "terminating_digit",
	9:  "valid_digits",
	10: "inter_digit_timeout_millis",
	11: "client_state",
	12: "command_id",
}

// Decode decodes GatherUsingAudioRequest from json.
func (s *GatherUsingAudioRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingAudioRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "media_name":
			if err := func() error {
				s.MediaName.Reset()
				if err := s.MediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_name\"")
			}
		case "invalid_audio_url":
			if err := func() error {
				s.InvalidAudioURL.Reset()
				if err := s.InvalidAudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invalid_audio_url\"")
			}
		case "invalid_media_name":
			if err := func() error {
				s.InvalidMediaName.Reset()
				if err := s.InvalidMediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invalid_media_name\"")
			}
		case "minimum_digits":
			if err := func() error {
				s.MinimumDigits.Reset()
				if err := s.MinimumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_digits\"")
			}
		case "maximum_digits":
			if err := func() error {
				s.MaximumDigits.Reset()
				if err := s.MaximumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_digits\"")
			}
		case "maximum_tries":
			if err := func() error {
				s.MaximumTries.Reset()
				if err := s.MaximumTries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_tries\"")
			}
		case "timeout_millis":
			if err := func() error {
				s.TimeoutMillis.Reset()
				if err := s.TimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_millis\"")
			}
		case "terminating_digit":
			if err := func() error {
				s.TerminatingDigit.Reset()
				if err := s.TerminatingDigit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating_digit\"")
			}
		case "valid_digits":
			if err := func() error {
				s.ValidDigits.Reset()
				if err := s.ValidDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid_digits\"")
			}
		case "inter_digit_timeout_millis":
			if err := func() error {
				s.InterDigitTimeoutMillis.Reset()
				if err := s.InterDigitTimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inter_digit_timeout_millis\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatherUsingAudioRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GatherUsingAudioRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingAudioRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GatherUsingSpeakRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GatherUsingSpeakRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		if s.InvalidPayload.Set {
			e.FieldStart("invalid_payload")
			s.InvalidPayload.Encode(e)
		}
	}
	{
		if s.PayloadType.Set {
			e.FieldStart("payload_type")
			s.PayloadType.Encode(e)
		}
	}
	{
		if s.ServiceLevel.Set {
			e.FieldStart("service_level")
			s.ServiceLevel.Encode(e)
		}
	}
	{
		e.FieldStart("voice")
		s.Voice.Encode(e)
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.MinimumDigits.Set {
			e.FieldStart("minimum_digits")
			s.MinimumDigits.Encode(e)
		}
	}
	{
		if s.MaximumDigits.Set {
			e.FieldStart("maximum_digits")
			s.MaximumDigits.Encode(e)
		}
	}
	{
		if s.MaximumTries.Set {
			e.FieldStart("maximum_tries")
			s.MaximumTries.Encode(e)
		}
	}
	{
		if s.TimeoutMillis.Set {
			e.FieldStart("timeout_millis")
			s.TimeoutMillis.Encode(e)
		}
	}
	{
		if s.TerminatingDigit.Set {
			e.FieldStart("terminating_digit")
			s.TerminatingDigit.Encode(e)
		}
	}
	{
		if s.ValidDigits.Set {
			e.FieldStart("valid_digits")
			s.ValidDigits.Encode(e)
		}
	}
	{
		if s.InterDigitTimeoutMillis.Set {
			e.FieldStart("inter_digit_timeout_millis")
			s.InterDigitTimeoutMillis.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGatherUsingSpeakRequest = [15]string{
	0:  "payload",
	1:  "invalid_payload",
	2:  "payload_type",
	3:  "service_level",
	4:  "voice",
	5:  "language",
	6:  "minimum_digits",
	7:  "maximum_digits",
	8:  "maximum_tries",
	9:  "timeout_millis",
	10: "terminating_digit",
	11: "valid_digits",
	12: "inter_digit_timeout_millis",
	13: "client_state",
	14: "command_id",
}

// Decode decodes GatherUsingSpeakRequest from json.
func (s *GatherUsingSpeakRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "payload":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "invalid_payload":
			if err := func() error {
				s.InvalidPayload.Reset()
				if err := s.InvalidPayload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invalid_payload\"")
			}
		case "payload_type":
			if err := func() error {
				s.PayloadType.Reset()
				if err := s.PayloadType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload_type\"")
			}
		case "service_level":
			if err := func() error {
				s.ServiceLevel.Reset()
				if err := s.ServiceLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_level\"")
			}
		case "voice":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Voice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "minimum_digits":
			if err := func() error {
				s.MinimumDigits.Reset()
				if err := s.MinimumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_digits\"")
			}
		case "maximum_digits":
			if err := func() error {
				s.MaximumDigits.Reset()
				if err := s.MaximumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_digits\"")
			}
		case "maximum_tries":
			if err := func() error {
				s.MaximumTries.Reset()
				if err := s.MaximumTries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_tries\"")
			}
		case "timeout_millis":
			if err := func() error {
				s.TimeoutMillis.Reset()
				if err := s.TimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_millis\"")
			}
		case "terminating_digit":
			if err := func() error {
				s.TerminatingDigit.Reset()
				if err := s.TerminatingDigit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating_digit\"")
			}
		case "valid_digits":
			if err := func() error {
				s.ValidDigits.Reset()
				if err := s.ValidDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid_digits\"")
			}
		case "inter_digit_timeout_millis":
			if err := func() error {
				s.InterDigitTimeoutMillis.Reset()
				if err := s.InterDigitTimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inter_digit_timeout_millis\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatherUsingSpeakRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGatherUsingSpeakRequest) {
					name = jsonFieldsNameOfGatherUsingSpeakRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GatherUsingSpeakRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestLanguage as json.
func (s GatherUsingSpeakRequestLanguage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatherUsingSpeakRequestLanguage from json.
func (s *GatherUsingSpeakRequestLanguage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequestLanguage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatherUsingSpeakRequestLanguage(v) {
	case GatherUsingSpeakRequestLanguageArb:
		*s = GatherUsingSpeakRequestLanguageArb
	case GatherUsingSpeakRequestLanguageCmnCN:
		*s = GatherUsingSpeakRequestLanguageCmnCN
	case GatherUsingSpeakRequestLanguageCyGB:
		*s = GatherUsingSpeakRequestLanguageCyGB
	case GatherUsingSpeakRequestLanguageDaDK:
		*s = GatherUsingSpeakRequestLanguageDaDK
	case GatherUsingSpeakRequestLanguageDeDE:
		*s = GatherUsingSpeakRequestLanguageDeDE
	case GatherUsingSpeakRequestLanguageEnAU:
		*s = GatherUsingSpeakRequestLanguageEnAU
	case GatherUsingSpeakRequestLanguageEnGB:
		*s = GatherUsingSpeakRequestLanguageEnGB
	case GatherUsingSpeakRequestLanguageEnGBWLS:
		*s = GatherUsingSpeakRequestLanguageEnGBWLS
	case GatherUsingSpeakRequestLanguageEnIN:
		*s = GatherUsingSpeakRequestLanguageEnIN
	case GatherUsingSpeakRequestLanguageEnUS:
		*s = GatherUsingSpeakRequestLanguageEnUS
	case GatherUsingSpeakRequestLanguageEsES:
		*s = GatherUsingSpeakRequestLanguageEsES
	case GatherUsingSpeakRequestLanguageEsMX:
		*s = GatherUsingSpeakRequestLanguageEsMX
	case GatherUsingSpeakRequestLanguageEsUS:
		*s = GatherUsingSpeakRequestLanguageEsUS
	case GatherUsingSpeakRequestLanguageFrCA:
		*s = GatherUsingSpeakRequestLanguageFrCA
	case GatherUsingSpeakRequestLanguageFrFR:
		*s = GatherUsingSpeakRequestLanguageFrFR
	case GatherUsingSpeakRequestLanguageHiIN:
		*s = GatherUsingSpeakRequestLanguageHiIN
	case GatherUsingSpeakRequestLanguageIsIS:
		*s = GatherUsingSpeakRequestLanguageIsIS
	case GatherUsingSpeakRequestLanguageItIT:
		*s = GatherUsingSpeakRequestLanguageItIT
	case GatherUsingSpeakRequestLanguageJaJP:
		*s = GatherUsingSpeakRequestLanguageJaJP
	case GatherUsingSpeakRequestLanguageKoKR:
		*s = GatherUsingSpeakRequestLanguageKoKR
	case GatherUsingSpeakRequestLanguageNbNO:
		*s = GatherUsingSpeakRequestLanguageNbNO
	case GatherUsingSpeakRequestLanguageNlNL:
		*s = GatherUsingSpeakRequestLanguageNlNL
	case GatherUsingSpeakRequestLanguagePlPL:
		*s = GatherUsingSpeakRequestLanguagePlPL
	case GatherUsingSpeakRequestLanguagePtBR:
		*s = GatherUsingSpeakRequestLanguagePtBR
	case GatherUsingSpeakRequestLanguagePtPT:
		*s = GatherUsingSpeakRequestLanguagePtPT
	case GatherUsingSpeakRequestLanguageRoRO:
		*s = GatherUsingSpeakRequestLanguageRoRO
	case GatherUsingSpeakRequestLanguageRuRU:
		*s = GatherUsingSpeakRequestLanguageRuRU
	case GatherUsingSpeakRequestLanguageSvSE:
		*s = GatherUsingSpeakRequestLanguageSvSE
	case GatherUsingSpeakRequestLanguageTrTR:
		*s = GatherUsingSpeakRequestLanguageTrTR
	default:
		*s = GatherUsingSpeakRequestLanguage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatherUsingSpeakRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestPayloadType as json.
func (s GatherUsingSpeakRequestPayloadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatherUsingSpeakRequestPayloadType from json.
func (s *GatherUsingSpeakRequestPayloadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequestPayloadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatherUsingSpeakRequestPayloadType(v) {
	case GatherUsingSpeakRequestPayloadTypeText:
		*s = GatherUsingSpeakRequestPayloadTypeText
	case GatherUsingSpeakRequestPayloadTypeSsml:
		*s = GatherUsingSpeakRequestPayloadTypeSsml
	default:
		*s = GatherUsingSpeakRequestPayloadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatherUsingSpeakRequestPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequestPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestServiceLevel as json.
func (s GatherUsingSpeakRequestServiceLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatherUsingSpeakRequestServiceLevel from json.
func (s *GatherUsingSpeakRequestServiceLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequestServiceLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatherUsingSpeakRequestServiceLevel(v) {
	case GatherUsingSpeakRequestServiceLevelBasic:
		*s = GatherUsingSpeakRequestServiceLevelBasic
	case GatherUsingSpeakRequestServiceLevelPremium:
		*s = GatherUsingSpeakRequestServiceLevelPremium
	default:
		*s = GatherUsingSpeakRequestServiceLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatherUsingSpeakRequestServiceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequestServiceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestVoice as json.
func (s GatherUsingSpeakRequestVoice) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatherUsingSpeakRequestVoice from json.
func (s *GatherUsingSpeakRequestVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequestVoice to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatherUsingSpeakRequestVoice(v) {
	case GatherUsingSpeakRequestVoiceMale:
		*s = GatherUsingSpeakRequestVoiceMale
	case GatherUsingSpeakRequestVoiceFemale:
		*s = GatherUsingSpeakRequestVoiceFemale
	default:
		*s = GatherUsingSpeakRequestVoice(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatherUsingSpeakRequestVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequestVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllTelephonyCredentialResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllTelephonyCredentialResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetAllTelephonyCredentialResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes GetAllTelephonyCredentialResponse from json.
func (s *GetAllTelephonyCredentialResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllTelephonyCredentialResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]TelephonyCredential, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TelephonyCredential
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllTelephonyCredentialResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllTelephonyCredentialResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllTelephonyCredentialResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllTexmlApplicationsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllTexmlApplicationsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetAllTexmlApplicationsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes GetAllTexmlApplicationsResponse from json.
func (s *GetAllTexmlApplicationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllTexmlApplicationsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]TexmlApplication, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TexmlApplication
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllTexmlApplicationsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllTexmlApplicationsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllTexmlApplicationsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCallResponse = [1]string{
	0: "data",
}

// Decode decodes GetCallResponse from json.
func (s *GetCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCallsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCallsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCallsResponse = [1]string{
	0: "data",
}

// Decode decodes GetCallsResponse from json.
func (s *GetCallsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCallsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCallsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCallsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCallsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConferenceRecordingsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConferenceRecordingsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConferenceRecordingsResponse = [1]string{
	0: "data",
}

// Decode decodes GetConferenceRecordingsResponse from json.
func (s *GetConferenceRecordingsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConferenceRecordingsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConferenceRecordingsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConferenceRecordingsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConferenceRecordingsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConferenceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConferenceResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConferenceResponse = [1]string{
	0: "data",
}

// Decode decodes GetConferenceResponse from json.
func (s *GetConferenceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConferenceResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConferenceResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConferenceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConferenceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConferencesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConferencesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConferencesResponse = [1]string{
	0: "data",
}

// Decode decodes GetConferencesResponse from json.
func (s *GetConferencesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConferencesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConferencesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConferencesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConferencesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetParticipantResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetParticipantResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetParticipantResponse = [1]string{
	0: "data",
}

// Decode decodes GetParticipantResponse from json.
func (s *GetParticipantResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetParticipantResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetParticipantsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetParticipantsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetParticipantsResponse = [1]string{
	0: "data",
}

// Decode decodes GetParticipantsResponse from json.
func (s *GetParticipantsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetParticipantsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRecordingTranscriptionOKApplicationJSON as json.
func (s GetRecordingTranscriptionOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetRecordingTranscriptionOKApplicationJSON from json.
func (s *GetRecordingTranscriptionOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRecordingTranscriptionOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRecordingTranscriptionOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRecordingTranscriptionOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRecordingTranscriptionOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRecordingTranscriptionsOKApplicationJSON as json.
func (s GetRecordingTranscriptionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetRecordingTranscriptionsOKApplicationJSON from json.
func (s *GetRecordingTranscriptionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRecordingTranscriptionsOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRecordingTranscriptionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRecordingTranscriptionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRecordingTranscriptionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRecordingsOKApplicationJSON as json.
func (s GetRecordingsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetRecordingsOKApplicationJSON from json.
func (s *GetRecordingsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRecordingsOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRecordingsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRecordingsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRecordingsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRoomRecordingResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRoomRecordingResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRoomRecordingResponse = [1]string{
	0: "data",
}

// Decode decodes GetRoomRecordingResponse from json.
func (s *GetRoomRecordingResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRoomRecordingResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRoomRecordingResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRoomRecordingResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRoomRecordingResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTexmlApplicationBadRequest as json.
func (s *GetTexmlApplicationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTexmlApplicationBadRequest from json.
func (s *GetTexmlApplicationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTexmlApplicationBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTexmlApplicationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTexmlApplicationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTexmlApplicationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTexmlApplicationNotFound as json.
func (s *GetTexmlApplicationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTexmlApplicationNotFound from json.
func (s *GetTexmlApplicationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTexmlApplicationNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTexmlApplicationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTexmlApplicationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTexmlApplicationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTexmlApplicationUnauthorized as json.
func (s *GetTexmlApplicationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTexmlApplicationUnauthorized from json.
func (s *GetTexmlApplicationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTexmlApplicationUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTexmlApplicationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTexmlApplicationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTexmlApplicationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsageReportByApplicationBadRequest as json.
func (s *GetUsageReportByApplicationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUsageReportByApplicationBadRequest from json.
func (s *GetUsageReportByApplicationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsageReportByApplicationBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUsageReportByApplicationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsageReportByApplicationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsageReportByApplicationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsageReportByApplicationInternalServerError as json.
func (s *GetUsageReportByApplicationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUsageReportByApplicationInternalServerError from json.
func (s *GetUsageReportByApplicationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsageReportByApplicationInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUsageReportByApplicationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsageReportByApplicationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsageReportByApplicationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVerifiedNumberNotFound as json.
func (s *GetVerifiedNumberNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Errors)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVerifiedNumberNotFound from json.
func (s *GetVerifiedNumberNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVerifiedNumberNotFound to nil")
	}
	var unwrapped Errors
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVerifiedNumberNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVerifiedNumberNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVerifiedNumberNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVerifiedNumberUnauthorized as json.
func (s *GetVerifiedNumberUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Errors)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVerifiedNumberUnauthorized from json.
func (s *GetVerifiedNumberUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVerifiedNumberUnauthorized to nil")
	}
	var unwrapped Errors
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVerifiedNumberUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVerifiedNumberUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVerifiedNumberUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetWebhookDeliveryOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetWebhookDeliveryOK) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetWebhookDeliveryOK = [1]string{
	0: "data",
}

// Decode decodes GetWebhookDeliveryOK from json.
func (s *GetWebhookDeliveryOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWebhookDeliveryOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetWebhookDeliveryOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWebhookDeliveryOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWebhookDeliveryOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTTP as json.
func (s HTTP) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes HTTP from json.
func (s *HTTP) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTP to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HTTP(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTTP) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTP) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTTPValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTTPValidationError) encodeFields(e *jx.Encoder) {
	{
		if s.Detail != nil {
			e.FieldStart("detail")
			e.ArrStart()
			for _, elem := range s.Detail {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHTTPValidationError = [1]string{
	0: "detail",
}

// Decode decodes HTTPValidationError from json.
func (s *HTTPValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTPValidationError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail = make([]ValidationError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Detail = append(s.Detail, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTTPValidationError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTTPValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTPValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HangupRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HangupRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfHangupRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes HangupRequest from json.
func (s *HangupRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HangupRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HangupRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HangupRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HangupRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateCallRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ApplicationSid")
		e.Str(s.ApplicationSid)
	}
	{
		e.FieldStart("To")
		e.Str(s.To)
	}
	{
		e.FieldStart("From")
		e.Str(s.From)
	}
	{
		if s.URL.Set {
			e.FieldStart("Url")
			s.URL.Encode(e)
		}
	}
	{
		if s.UrlMethod.Set {
			e.FieldStart("UrlMethod")
			s.UrlMethod.Encode(e)
		}
	}
	{
		if s.FallbackUrl.Set {
			e.FieldStart("FallbackUrl")
			s.FallbackUrl.Encode(e)
		}
	}
	{
		if s.StatusCallback.Set {
			e.FieldStart("StatusCallback")
			s.StatusCallback.Encode(e)
		}
	}
	{
		if s.StatusCallbackMethod.Set {
			e.FieldStart("StatusCallbackMethod")
			s.StatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.StatusCallbackEvent.Set {
			e.FieldStart("StatusCallbackEvent")
			s.StatusCallbackEvent.Encode(e)
		}
	}
	{
		if s.MachineDetection.Set {
			e.FieldStart("MachineDetection")
			s.MachineDetection.Encode(e)
		}
	}
	{
		if s.DetectionMode.Set {
			e.FieldStart("DetectionMode")
			s.DetectionMode.Encode(e)
		}
	}
	{
		if s.AsyncAmd.Set {
			e.FieldStart("AsyncAmd")
			s.AsyncAmd.Encode(e)
		}
	}
	{
		if s.AsyncAmdStatusCallback.Set {
			e.FieldStart("AsyncAmdStatusCallback")
			s.AsyncAmdStatusCallback.Encode(e)
		}
	}
	{
		if s.AsyncAmdStatusCallbackMethod.Set {
			e.FieldStart("AsyncAmdStatusCallbackMethod")
			s.AsyncAmdStatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.MachineDetectionTimeout.Set {
			e.FieldStart("MachineDetectionTimeout")
			s.MachineDetectionTimeout.Encode(e)
		}
	}
	{
		if s.MachineDetectionSpeechThreshold.Set {
			e.FieldStart("MachineDetectionSpeechThreshold")
			s.MachineDetectionSpeechThreshold.Encode(e)
		}
	}
	{
		if s.MachineDetectionSpeechEndThreshold.Set {
			e.FieldStart("MachineDetectionSpeechEndThreshold")
			s.MachineDetectionSpeechEndThreshold.Encode(e)
		}
	}
	{
		if s.MachineDetectionSilenceTimeout.Set {
			e.FieldStart("MachineDetectionSilenceTimeout")
			s.MachineDetectionSilenceTimeout.Encode(e)
		}
	}
	{
		if s.CancelPlaybackOnMachineDetection.Set {
			e.FieldStart("CancelPlaybackOnMachineDetection")
			s.CancelPlaybackOnMachineDetection.Encode(e)
		}
	}
	{
		if s.CancelPlaybackOnDetectMessageEnd.Set {
			e.FieldStart("CancelPlaybackOnDetectMessageEnd")
			s.CancelPlaybackOnDetectMessageEnd.Encode(e)
		}
	}
	{
		if s.PreferredCodecs.Set {
			e.FieldStart("PreferredCodecs")
			s.PreferredCodecs.Encode(e)
		}
	}
	{
		if s.Record.Set {
			e.FieldStart("Record")
			s.Record.Encode(e)
		}
	}
	{
		if s.RecordingChannels.Set {
			e.FieldStart("RecordingChannels")
			s.RecordingChannels.Encode(e)
		}
	}
	{
		if s.RecordingStatusCallback.Set {
			e.FieldStart("RecordingStatusCallback")
			s.RecordingStatusCallback.Encode(e)
		}
	}
	{
		if s.RecordingStatusCallbackMethod.Set {
			e.FieldStart("RecordingStatusCallbackMethod")
			s.RecordingStatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.RecordingStatusCallbackEvent.Set {
			e.FieldStart("RecordingStatusCallbackEvent")
			s.RecordingStatusCallbackEvent.Encode(e)
		}
	}
	{
		if s.RecordingTimeout.Set {
			e.FieldStart("RecordingTimeout")
			s.RecordingTimeout.Encode(e)
		}
	}
	{
		if s.RecordingTrack.Set {
			e.FieldStart("RecordingTrack")
			s.RecordingTrack.Encode(e)
		}
	}
	{
		if s.SipAuthPassword.Set {
			e.FieldStart("SipAuthPassword")
			s.SipAuthPassword.Encode(e)
		}
	}
	{
		if s.SipAuthUsername.Set {
			e.FieldStart("SipAuthUsername")
			s.SipAuthUsername.Encode(e)
		}
	}
	{
		if s.Trim.Set {
			e.FieldStart("Trim")
			s.Trim.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateCallRequest = [31]string{
	0:  "ApplicationSid",
	1:  "To",
	2:  "From",
	3:  "Url",
	4:  "UrlMethod",
	5:  "FallbackUrl",
	6:  "StatusCallback",
	7:  "StatusCallbackMethod",
	8:  "StatusCallbackEvent",
	9:  "MachineDetection",
	10: "DetectionMode",
	11: "AsyncAmd",
	12: "AsyncAmdStatusCallback",
	13: "AsyncAmdStatusCallbackMethod",
	14: "MachineDetectionTimeout",
	15: "MachineDetectionSpeechThreshold",
	16: "MachineDetectionSpeechEndThreshold",
	17: "MachineDetectionSilenceTimeout",
	18: "CancelPlaybackOnMachineDetection",
	19: "CancelPlaybackOnDetectMessageEnd",
	20: "PreferredCodecs",
	21: "Record",
	22: "RecordingChannels",
	23: "RecordingStatusCallback",
	24: "RecordingStatusCallbackMethod",
	25: "RecordingStatusCallbackEvent",
	26: "RecordingTimeout",
	27: "RecordingTrack",
	28: "SipAuthPassword",
	29: "SipAuthUsername",
	30: "Trim",
}

// Decode decodes InitiateCallRequest from json.
func (s *InitiateCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequest to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ApplicationSid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApplicationSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ApplicationSid\"")
			}
		case "To":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"To\"")
			}
		case "From":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"From\"")
			}
		case "Url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Url\"")
			}
		case "UrlMethod":
			if err := func() error {
				s.UrlMethod.Reset()
				if err := s.UrlMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UrlMethod\"")
			}
		case "FallbackUrl":
			if err := func() error {
				s.FallbackUrl.Reset()
				if err := s.FallbackUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FallbackUrl\"")
			}
		case "StatusCallback":
			if err := func() error {
				s.StatusCallback.Reset()
				if err := s.StatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallback\"")
			}
		case "StatusCallbackMethod":
			if err := func() error {
				s.StatusCallbackMethod.Reset()
				if err := s.StatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallbackMethod\"")
			}
		case "StatusCallbackEvent":
			if err := func() error {
				s.StatusCallbackEvent.Reset()
				if err := s.StatusCallbackEvent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallbackEvent\"")
			}
		case "MachineDetection":
			if err := func() error {
				s.MachineDetection.Reset()
				if err := s.MachineDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetection\"")
			}
		case "DetectionMode":
			if err := func() error {
				s.DetectionMode.Reset()
				if err := s.DetectionMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DetectionMode\"")
			}
		case "AsyncAmd":
			if err := func() error {
				s.AsyncAmd.Reset()
				if err := s.AsyncAmd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AsyncAmd\"")
			}
		case "AsyncAmdStatusCallback":
			if err := func() error {
				s.AsyncAmdStatusCallback.Reset()
				if err := s.AsyncAmdStatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AsyncAmdStatusCallback\"")
			}
		case "AsyncAmdStatusCallbackMethod":
			if err := func() error {
				s.AsyncAmdStatusCallbackMethod.Reset()
				if err := s.AsyncAmdStatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AsyncAmdStatusCallbackMethod\"")
			}
		case "MachineDetectionTimeout":
			if err := func() error {
				s.MachineDetectionTimeout.Reset()
				if err := s.MachineDetectionTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetectionTimeout\"")
			}
		case "MachineDetectionSpeechThreshold":
			if err := func() error {
				s.MachineDetectionSpeechThreshold.Reset()
				if err := s.MachineDetectionSpeechThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetectionSpeechThreshold\"")
			}
		case "MachineDetectionSpeechEndThreshold":
			if err := func() error {
				s.MachineDetectionSpeechEndThreshold.Reset()
				if err := s.MachineDetectionSpeechEndThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetectionSpeechEndThreshold\"")
			}
		case "MachineDetectionSilenceTimeout":
			if err := func() error {
				s.MachineDetectionSilenceTimeout.Reset()
				if err := s.MachineDetectionSilenceTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetectionSilenceTimeout\"")
			}
		case "CancelPlaybackOnMachineDetection":
			if err := func() error {
				s.CancelPlaybackOnMachineDetection.Reset()
				if err := s.CancelPlaybackOnMachineDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CancelPlaybackOnMachineDetection\"")
			}
		case "CancelPlaybackOnDetectMessageEnd":
			if err := func() error {
				s.CancelPlaybackOnDetectMessageEnd.Reset()
				if err := s.CancelPlaybackOnDetectMessageEnd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CancelPlaybackOnDetectMessageEnd\"")
			}
		case "PreferredCodecs":
			if err := func() error {
				s.PreferredCodecs.Reset()
				if err := s.PreferredCodecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PreferredCodecs\"")
			}
		case "Record":
			if err := func() error {
				s.Record.Reset()
				if err := s.Record.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Record\"")
			}
		case "RecordingChannels":
			if err := func() error {
				s.RecordingChannels.Reset()
				if err := s.RecordingChannels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingChannels\"")
			}
		case "RecordingStatusCallback":
			if err := func() error {
				s.RecordingStatusCallback.Reset()
				if err := s.RecordingStatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingStatusCallback\"")
			}
		case "RecordingStatusCallbackMethod":
			if err := func() error {
				s.RecordingStatusCallbackMethod.Reset()
				if err := s.RecordingStatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingStatusCallbackMethod\"")
			}
		case "RecordingStatusCallbackEvent":
			if err := func() error {
				s.RecordingStatusCallbackEvent.Reset()
				if err := s.RecordingStatusCallbackEvent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingStatusCallbackEvent\"")
			}
		case "RecordingTimeout":
			if err := func() error {
				s.RecordingTimeout.Reset()
				if err := s.RecordingTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingTimeout\"")
			}
		case "RecordingTrack":
			if err := func() error {
				s.RecordingTrack.Reset()
				if err := s.RecordingTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingTrack\"")
			}
		case "SipAuthPassword":
			if err := func() error {
				s.SipAuthPassword.Reset()
				if err := s.SipAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SipAuthPassword\"")
			}
		case "SipAuthUsername":
			if err := func() error {
				s.SipAuthUsername.Reset()
				if err := s.SipAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SipAuthUsername\"")
			}
		case "Trim":
			if err := func() error {
				s.Trim.Reset()
				if err := s.Trim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Trim\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateCallRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000111,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateCallRequest) {
					name = jsonFieldsNameOfInitiateCallRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestAsyncAmdStatusCallbackMethod as json.
func (s InitiateCallRequestAsyncAmdStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestAsyncAmdStatusCallbackMethod from json.
func (s *InitiateCallRequestAsyncAmdStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestAsyncAmdStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestAsyncAmdStatusCallbackMethod(v) {
	case InitiateCallRequestAsyncAmdStatusCallbackMethodGET:
		*s = InitiateCallRequestAsyncAmdStatusCallbackMethodGET
	case InitiateCallRequestAsyncAmdStatusCallbackMethodPOST:
		*s = InitiateCallRequestAsyncAmdStatusCallbackMethodPOST
	default:
		*s = InitiateCallRequestAsyncAmdStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestAsyncAmdStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestAsyncAmdStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestDetectionMode as json.
func (s InitiateCallRequestDetectionMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestDetectionMode from json.
func (s *InitiateCallRequestDetectionMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestDetectionMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestDetectionMode(v) {
	case InitiateCallRequestDetectionModePremium:
		*s = InitiateCallRequestDetectionModePremium
	case InitiateCallRequestDetectionModeRegular:
		*s = InitiateCallRequestDetectionModeRegular
	default:
		*s = InitiateCallRequestDetectionMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestDetectionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestDetectionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestMachineDetection as json.
func (s InitiateCallRequestMachineDetection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestMachineDetection from json.
func (s *InitiateCallRequestMachineDetection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestMachineDetection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestMachineDetection(v) {
	case InitiateCallRequestMachineDetectionEnable:
		*s = InitiateCallRequestMachineDetectionEnable
	case InitiateCallRequestMachineDetectionDisable:
		*s = InitiateCallRequestMachineDetectionDisable
	case InitiateCallRequestMachineDetectionDetectMessageEnd:
		*s = InitiateCallRequestMachineDetectionDetectMessageEnd
	default:
		*s = InitiateCallRequestMachineDetection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingChannels as json.
func (s InitiateCallRequestRecordingChannels) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestRecordingChannels from json.
func (s *InitiateCallRequestRecordingChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestRecordingChannels to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestRecordingChannels(v) {
	case InitiateCallRequestRecordingChannelsMono:
		*s = InitiateCallRequestRecordingChannelsMono
	case InitiateCallRequestRecordingChannelsDual:
		*s = InitiateCallRequestRecordingChannelsDual
	default:
		*s = InitiateCallRequestRecordingChannels(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestRecordingChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestRecordingChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingStatusCallbackMethod as json.
func (s InitiateCallRequestRecordingStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestRecordingStatusCallbackMethod from json.
func (s *InitiateCallRequestRecordingStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestRecordingStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestRecordingStatusCallbackMethod(v) {
	case InitiateCallRequestRecordingStatusCallbackMethodGET:
		*s = InitiateCallRequestRecordingStatusCallbackMethodGET
	case InitiateCallRequestRecordingStatusCallbackMethodPOST:
		*s = InitiateCallRequestRecordingStatusCallbackMethodPOST
	default:
		*s = InitiateCallRequestRecordingStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestRecordingStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestRecordingStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingTrack as json.
func (s InitiateCallRequestRecordingTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestRecordingTrack from json.
func (s *InitiateCallRequestRecordingTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestRecordingTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestRecordingTrack(v) {
	case InitiateCallRequestRecordingTrackInbound:
		*s = InitiateCallRequestRecordingTrackInbound
	case InitiateCallRequestRecordingTrackOutbound:
		*s = InitiateCallRequestRecordingTrackOutbound
	case InitiateCallRequestRecordingTrackBoth:
		*s = InitiateCallRequestRecordingTrackBoth
	default:
		*s = InitiateCallRequestRecordingTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestStatusCallbackEvent as json.
func (s InitiateCallRequestStatusCallbackEvent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestStatusCallbackEvent from json.
func (s *InitiateCallRequestStatusCallbackEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestStatusCallbackEvent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestStatusCallbackEvent(v) {
	case InitiateCallRequestStatusCallbackEventInitiated:
		*s = InitiateCallRequestStatusCallbackEventInitiated
	case InitiateCallRequestStatusCallbackEventRinging:
		*s = InitiateCallRequestStatusCallbackEventRinging
	case InitiateCallRequestStatusCallbackEventAnswered:
		*s = InitiateCallRequestStatusCallbackEventAnswered
	case InitiateCallRequestStatusCallbackEventCompleted:
		*s = InitiateCallRequestStatusCallbackEventCompleted
	default:
		*s = InitiateCallRequestStatusCallbackEvent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestStatusCallbackEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestStatusCallbackEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestStatusCallbackMethod as json.
func (s InitiateCallRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestStatusCallbackMethod from json.
func (s *InitiateCallRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestStatusCallbackMethod(v) {
	case InitiateCallRequestStatusCallbackMethodGET:
		*s = InitiateCallRequestStatusCallbackMethodGET
	case InitiateCallRequestStatusCallbackMethodPOST:
		*s = InitiateCallRequestStatusCallbackMethodPOST
	default:
		*s = InitiateCallRequestStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestTrim as json.
func (s InitiateCallRequestTrim) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestTrim from json.
func (s *InitiateCallRequestTrim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestTrim to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestTrim(v) {
	case InitiateCallRequestTrimTrimSilence:
		*s = InitiateCallRequestTrimTrimSilence
	case InitiateCallRequestTrimDoNotTrim:
		*s = InitiateCallRequestTrimDoNotTrim
	default:
		*s = InitiateCallRequestTrim(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestUrlMethod as json.
func (s InitiateCallRequestUrlMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestUrlMethod from json.
func (s *InitiateCallRequestUrlMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestUrlMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestUrlMethod(v) {
	case InitiateCallRequestUrlMethodGET:
		*s = InitiateCallRequestUrlMethodGET
	case InitiateCallRequestUrlMethodPOST:
		*s = InitiateCallRequestUrlMethodPOST
	default:
		*s = InitiateCallRequestUrlMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestUrlMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestUrlMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateCallResponse = [1]string{
	0: "data",
}

// Decode decodes InitiateCallResponse from json.
func (s *InitiateCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateCallResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateCallResult) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateCallResult = [3]string{
	0: "from",
	1: "to",
	2: "status",
}

// Decode decodes InitiateCallResult from json.
func (s *InitiateCallResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateCallResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateCallResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IntId as json.
func (s IntId) Encode(e *jx.Encoder) {
	unwrapped := int64(s)

	json.EncodeStringInt64(e, unwrapped)
}

// Decode decodes IntId from json.
func (s *IntId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntId to nil")
	}
	var unwrapped int64
	if err := func() error {
		v, err := json.DecodeStringInt64(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IntId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IntId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaveQueueRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaveQueueRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaveQueueRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes LeaveQueueRequest from json.
func (s *LeaveQueueRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveQueueRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaveQueueRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveQueueRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveQueueRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListCallControlApplicationsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListCallControlApplicationsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfListCallControlApplicationsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListCallControlApplicationsResponse from json.
func (s *ListCallControlApplicationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCallControlApplicationsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]CallControlApplication, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CallControlApplication
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListCallControlApplicationsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListCallControlApplicationsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCallControlApplicationsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListQueueCallsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListQueueCallsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfListQueueCallsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListQueueCallsResponse from json.
func (s *ListQueueCallsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListQueueCallsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]QueueCall, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QueueCall
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListQueueCallsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListQueueCallsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListQueueCallsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListRoomRecordingsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListRoomRecordingsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfListRoomRecordingsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListRoomRecordingsResponse from json.
func (s *ListRoomRecordingsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRoomRecordingsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]RoomRecording, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RoomRecording
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListRoomRecordingsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListRoomRecordingsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRoomRecordingsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListTagsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListTagsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfListTagsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListTagsResponse from json.
func (s *ListTagsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTagsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]ListTagsResponseDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ListTagsResponseDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListTagsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTagsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTagsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListTagsResponseDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListTagsResponseDataItem) encodeFields(e *jx.Encoder) {
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
}

var jsonFieldsNameOfListTagsResponseDataItem = [2]string{
	0: "tag",
	1: "amount",
}

// Decode decodes ListTagsResponseDataItem from json.
func (s *ListTagsResponseDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTagsResponseDataItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListTagsResponseDataItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTagsResponseDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTagsResponseDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListUsageReportsOptionsBadRequest as json.
func (s *ListUsageReportsOptionsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListUsageReportsOptionsBadRequest from json.
func (s *ListUsageReportsOptionsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUsageReportsOptionsBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUsageReportsOptionsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListUsageReportsOptionsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListUsageReportsOptionsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListUsageReportsOptionsInternalServerError as json.
func (s *ListUsageReportsOptionsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListUsageReportsOptionsInternalServerError from json.
func (s *ListUsageReportsOptionsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListUsageReportsOptionsInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListUsageReportsOptionsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListUsageReportsOptionsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListUsageReportsOptionsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListVerificationsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListVerificationsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfListVerificationsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListVerificationsResponse from json.
func (s *ListVerificationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVerificationsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]Verification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Verification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListVerificationsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListVerificationsResponse) {
					name = jsonFieldsNameOfListVerificationsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListVerificationsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListVerificationsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListVerifiedCallsDisplayProfilesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListVerifiedCallsDisplayProfilesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfListVerifiedCallsDisplayProfilesResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListVerifiedCallsDisplayProfilesResponse from json.
func (s *ListVerifiedCallsDisplayProfilesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVerifiedCallsDisplayProfilesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]VerifiedCallsDisplayProfile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VerifiedCallsDisplayProfile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListVerifiedCallsDisplayProfilesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListVerifiedCallsDisplayProfilesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListVerifiedCallsDisplayProfilesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListVerifiedNumbersResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListVerifiedNumbersResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfListVerifiedNumbersResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListVerifiedNumbersResponse from json.
func (s *ListVerifiedNumbersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVerifiedNumbersResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]VerifiedNumberResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VerifiedNumberResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListVerifiedNumbersResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListVerifiedNumbersResponse) {
					name = jsonFieldsNameOfListVerifiedNumbersResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListVerifiedNumbersResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListVerifiedNumbersResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListVerifiedNumbersUnprocessableEntityApplicationJSON as json.
func (s ListVerifiedNumbersUnprocessableEntityApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes ListVerifiedNumbersUnprocessableEntityApplicationJSON from json.
func (s *ListVerifiedNumbersUnprocessableEntityApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVerifiedNumbersUnprocessableEntityApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListVerifiedNumbersUnprocessableEntityApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListVerifiedNumbersUnprocessableEntityApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListVerifiedNumbersUnprocessableEntityApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListVerifyProfileMessageTemplateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListVerifyProfileMessageTemplateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfListVerifyProfileMessageTemplateResponse = [1]string{
	0: "data",
}

// Decode decodes ListVerifyProfileMessageTemplateResponse from json.
func (s *ListVerifyProfileMessageTemplateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVerifyProfileMessageTemplateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]VerifyProfileMessageTemplateResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VerifyProfileMessageTemplateResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListVerifyProfileMessageTemplateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListVerifyProfileMessageTemplateResponse) {
					name = jsonFieldsNameOfListVerifyProfileMessageTemplateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListVerifyProfileMessageTemplateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListVerifyProfileMessageTemplateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListVerifyProfilesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListVerifyProfilesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfListVerifyProfilesResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListVerifyProfilesResponse from json.
func (s *ListVerifyProfilesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListVerifyProfilesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]VerifyProfileResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VerifyProfileResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListVerifyProfilesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListVerifyProfilesResponse) {
					name = jsonFieldsNameOfListVerifyProfilesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListVerifyProfilesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListVerifyProfilesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogoURL as json.
func (s LogoURL) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes LogoURL from json.
func (s *LogoURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogoURL to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LogoURL(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogoURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogoURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Loopcount as json.
func (s Loopcount) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringLoopcount:
		e.Str(s.String)
	case IntLoopcount:
		e.Int(s.Int)
	}
}

// Decode decodes Loopcount from json.
func (s *Loopcount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Loopcount to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntLoopcount
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringLoopcount
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Loopcount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Loopcount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MdrGetSyncUsageReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MdrGetSyncUsageReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfMdrGetSyncUsageReportResponse = [1]string{
	0: "data",
}

// Decode decodes MdrGetSyncUsageReportResponse from json.
func (s *MdrGetSyncUsageReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MdrGetSyncUsageReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MdrGetSyncUsageReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MdrGetSyncUsageReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MdrGetSyncUsageReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MdrGetUsageReportsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MdrGetUsageReportsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfMdrGetUsageReportsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes MdrGetUsageReportsResponse from json.
func (s *MdrGetUsageReportsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MdrGetUsageReportsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]MdrUsageReportResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MdrUsageReportResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MdrGetUsageReportsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MdrGetUsageReportsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MdrGetUsageReportsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MdrUsageRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MdrUsageRecord) encodeFields(e *jx.Encoder) {
	{
		if s.Cost.Set {
			e.FieldStart("cost")
			s.Cost.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.Product.Set {
			e.FieldStart("product")
			s.Product.Encode(e)
		}
	}
	{
		if s.Connection.Set {
			e.FieldStart("connection")
			s.Connection.Encode(e)
		}
	}
	{
		if s.Received.Set {
			e.FieldStart("received")
			s.Received.Encode(e)
		}
	}
	{
		if s.Delivered.Set {
			e.FieldStart("delivered")
			s.Delivered.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Parts.Set {
			e.FieldStart("parts")
			s.Parts.Encode(e)
		}
	}
	{
		if s.Sent.Set {
			e.FieldStart("sent")
			s.Sent.Encode(e)
		}
	}
	{
		if s.ProfileID.Set {
			e.FieldStart("profile_id")
			s.ProfileID.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.MessageType.Set {
			e.FieldStart("message_type")
			s.MessageType.Encode(e)
		}
	}
	{
		if s.TnType.Set {
			e.FieldStart("tn_type")
			s.TnType.Encode(e)
		}
	}
	{
		if s.CarrierPassthroughFee.Set {
			e.FieldStart("carrier_passthrough_fee")
			s.CarrierPassthroughFee.Encode(e)
		}
	}
}

var jsonFieldsNameOfMdrUsageRecord = [14]string{
	0:  "cost",
	1:  "direction",
	2:  "product",
	3:  "connection",
	4:  "received",
	5:  "delivered",
	6:  "currency",
	7:  "parts",
	8:  "sent",
	9:  "profile_id",
	10: "tags",
	11: "message_type",
	12: "tn_type",
	13: "carrier_passthrough_fee",
}

// Decode decodes MdrUsageRecord from json.
func (s *MdrUsageRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MdrUsageRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cost":
			if err := func() error {
				s.Cost.Reset()
				if err := s.Cost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cost\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "product":
			if err := func() error {
				s.Product.Reset()
				if err := s.Product.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product\"")
			}
		case "connection":
			if err := func() error {
				s.Connection.Reset()
				if err := s.Connection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection\"")
			}
		case "received":
			if err := func() error {
				s.Received.Reset()
				if err := s.Received.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received\"")
			}
		case "delivered":
			if err := func() error {
				s.Delivered.Reset()
				if err := s.Delivered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivered\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "parts":
			if err := func() error {
				s.Parts.Reset()
				if err := s.Parts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parts\"")
			}
		case "sent":
			if err := func() error {
				s.Sent.Reset()
				if err := s.Sent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sent\"")
			}
		case "profile_id":
			if err := func() error {
				s.ProfileID.Reset()
				if err := s.ProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profile_id\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "message_type":
			if err := func() error {
				s.MessageType.Reset()
				if err := s.MessageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_type\"")
			}
		case "tn_type":
			if err := func() error {
				s.TnType.Reset()
				if err := s.TnType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tn_type\"")
			}
		case "carrier_passthrough_fee":
			if err := func() error {
				s.CarrierPassthroughFee.Reset()
				if err := s.CarrierPassthroughFee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"carrier_passthrough_fee\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MdrUsageRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MdrUsageRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MdrUsageRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MdrUsageReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MdrUsageReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.StartDate.Set {
			e.FieldStart("start_date")
			s.StartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndDate.Set {
			e.FieldStart("end_date")
			s.EndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Connections != nil {
			e.FieldStart("connections")
			e.ArrStart()
			for _, elem := range s.Connections {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AggregationType.Set {
			e.FieldStart("aggregation_type")
			s.AggregationType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ReportURL.Set {
			e.FieldStart("report_url")
			s.ReportURL.Encode(e)
		}
	}
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Profiles.Set {
			e.FieldStart("profiles")
			s.Profiles.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
}

var jsonFieldsNameOfMdrUsageReportResponse = [12]string{
	0:  "id",
	1:  "start_date",
	2:  "end_date",
	3:  "connections",
	4:  "aggregation_type",
	5:  "status",
	6:  "report_url",
	7:  "result",
	8:  "created_at",
	9:  "updated_at",
	10: "profiles",
	11: "record_type",
}

// Decode decodes MdrUsageReportResponse from json.
func (s *MdrUsageReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MdrUsageReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "start_date":
			if err := func() error {
				s.StartDate.Reset()
				if err := s.StartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "end_date":
			if err := func() error {
				s.EndDate.Reset()
				if err := s.EndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		case "connections":
			if err := func() error {
				s.Connections = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.Connections = append(s.Connections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connections\"")
			}
		case "aggregation_type":
			if err := func() error {
				s.AggregationType.Reset()
				if err := s.AggregationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aggregation_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "report_url":
			if err := func() error {
				s.ReportURL.Reset()
				if err := s.ReportURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"report_url\"")
			}
		case "result":
			if err := func() error {
				s.Result = make([]MdrUsageRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MdrUsageRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "profiles":
			if err := func() error {
				s.Profiles.Reset()
				if err := s.Profiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profiles\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MdrUsageReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MdrUsageReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MdrUsageReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MdrUsageReportResponseAggregationType as json.
func (s MdrUsageReportResponseAggregationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MdrUsageReportResponseAggregationType from json.
func (s *MdrUsageReportResponseAggregationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MdrUsageReportResponseAggregationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MdrUsageReportResponseAggregationType(v) {
	case MdrUsageReportResponseAggregationTypeNOAGGREGATION:
		*s = MdrUsageReportResponseAggregationTypeNOAGGREGATION
	case MdrUsageReportResponseAggregationTypePROFILE:
		*s = MdrUsageReportResponseAggregationTypePROFILE
	case MdrUsageReportResponseAggregationTypeTAGS:
		*s = MdrUsageReportResponseAggregationTypeTAGS
	default:
		*s = MdrUsageReportResponseAggregationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MdrUsageReportResponseAggregationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MdrUsageReportResponseAggregationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MdrUsageReportResponseStatus as json.
func (s MdrUsageReportResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MdrUsageReportResponseStatus from json.
func (s *MdrUsageReportResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MdrUsageReportResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MdrUsageReportResponseStatus(v) {
	case MdrUsageReportResponseStatusPENDING:
		*s = MdrUsageReportResponseStatusPENDING
	case MdrUsageReportResponseStatusCOMPLETE:
		*s = MdrUsageReportResponseStatusCOMPLETE
	case MdrUsageReportResponseStatusFAILED:
		*s = MdrUsageReportResponseStatusFAILED
	case MdrUsageReportResponseStatusEXPIRED:
		*s = MdrUsageReportResponseStatusEXPIRED
	default:
		*s = MdrUsageReportResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MdrUsageReportResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MdrUsageReportResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Meta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Meta) encodeFields(e *jx.Encoder) {
	{
		if s.TotalPages.Set {
			e.FieldStart("total_pages")
			s.TotalPages.Encode(e)
		}
	}
	{
		if s.TotalResults.Set {
			e.FieldStart("total_results")
			s.TotalResults.Encode(e)
		}
	}
	{
		if s.PageNumber.Set {
			e.FieldStart("page_number")
			s.PageNumber.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfMeta = [4]string{
	0: "total_pages",
	1: "total_results",
	2: "page_number",
	3: "page_size",
}

// Decode decodes Meta from json.
func (s *Meta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Meta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_pages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_pages\"")
			}
		case "total_results":
			if err := func() error {
				s.TotalResults.Reset()
				if err := s.TotalResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_results\"")
			}
		case "page_number":
			if err := func() error {
				s.PageNumber.Reset()
				if err := s.PageNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_number\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Meta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Meta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Meta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MetaResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MetaResponse) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfMetaResponse = [1]string{
	0: "url",
}

// Decode decodes MetaResponse from json.
func (s *MetaResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetaResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetaResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MetaResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MetaResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Name as json.
func (s Name) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Name from json.
func (s *Name) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Name to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Name(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Name) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Name) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewParticipantResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewParticipantResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.Coaching.Set {
			e.FieldStart("coaching")
			s.Coaching.Encode(e)
		}
	}
	{
		if s.CoachingCallSid.Set {
			e.FieldStart("coaching_call_sid")
			s.CoachingCallSid.Encode(e)
		}
	}
	{
		if s.EndConferenceOnExit.Set {
			e.FieldStart("end_conference_on_exit")
			s.EndConferenceOnExit.Encode(e)
		}
	}
	{
		if s.Hold.Set {
			e.FieldStart("hold")
			s.Hold.Encode(e)
		}
	}
	{
		if s.Muted.Set {
			e.FieldStart("muted")
			s.Muted.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfNewParticipantResource = [9]string{
	0: "account_sid",
	1: "call_sid",
	2: "coaching",
	3: "coaching_call_sid",
	4: "end_conference_on_exit",
	5: "hold",
	6: "muted",
	7: "status",
	8: "uri",
}

// Decode decodes NewParticipantResource from json.
func (s *NewParticipantResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewParticipantResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "coaching":
			if err := func() error {
				s.Coaching.Reset()
				if err := s.Coaching.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching\"")
			}
		case "coaching_call_sid":
			if err := func() error {
				s.CoachingCallSid.Reset()
				if err := s.CoachingCallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching_call_sid\"")
			}
		case "end_conference_on_exit":
			if err := func() error {
				s.EndConferenceOnExit.Reset()
				if err := s.EndConferenceOnExit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_conference_on_exit\"")
			}
		case "hold":
			if err := func() error {
				s.Hold.Reset()
				if err := s.Hold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold\"")
			}
		case "muted":
			if err := func() error {
				s.Muted.Reset()
				if err := s.Muted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muted\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewParticipantResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewParticipantResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewParticipantResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewParticipantResourceStatus as json.
func (s NewParticipantResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NewParticipantResourceStatus from json.
func (s *NewParticipantResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewParticipantResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NewParticipantResourceStatus(v) {
	case NewParticipantResourceStatusConnecting:
		*s = NewParticipantResourceStatusConnecting
	case NewParticipantResourceStatusConnected:
		*s = NewParticipantResourceStatusConnected
	case NewParticipantResourceStatusCompleted:
		*s = NewParticipantResourceStatusCompleted
	default:
		*s = NewParticipantResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NewParticipantResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewParticipantResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NoiseSuppressionDirection as json.
func (s NoiseSuppressionDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NoiseSuppressionDirection from json.
func (s *NoiseSuppressionDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NoiseSuppressionDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NoiseSuppressionDirection(v) {
	case NoiseSuppressionDirectionInbound:
		*s = NoiseSuppressionDirectionInbound
	case NoiseSuppressionDirectionOutbound:
		*s = NoiseSuppressionDirectionOutbound
	case NoiseSuppressionDirectionBoth:
		*s = NoiseSuppressionDirectionBoth
	default:
		*s = NoiseSuppressionDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NoiseSuppressionDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NoiseSuppressionDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NoiseSuppressionStart) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NoiseSuppressionStart) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
}

var jsonFieldsNameOfNoiseSuppressionStart = [3]string{
	0: "client_state",
	1: "command_id",
	2: "direction",
}

// Decode decodes NoiseSuppressionStart from json.
func (s *NoiseSuppressionStart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NoiseSuppressionStart to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NoiseSuppressionStart")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NoiseSuppressionStart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NoiseSuppressionStart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NoiseSuppressionStop) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NoiseSuppressionStop) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNoiseSuppressionStop = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes NoiseSuppressionStop from json.
func (s *NoiseSuppressionStop) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NoiseSuppressionStop to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NoiseSuppressionStop")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NoiseSuppressionStop) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NoiseSuppressionStop) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountSid as json.
func (o OptAccountSid) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccountSid from json.
func (o *OptAccountSid) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccountSid to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccountSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccountSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnchorsiteOverride as json.
func (o OptAnchorsiteOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AnchorsiteOverride from json.
func (o *OptAnchorsiteOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnchorsiteOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnchorsiteOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnchorsiteOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestPreferredCodecs as json.
func (o OptAnswerRequestPreferredCodecs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AnswerRequestPreferredCodecs from json.
func (o *OptAnswerRequestPreferredCodecs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnswerRequestPreferredCodecs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnswerRequestPreferredCodecs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnswerRequestPreferredCodecs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestStreamTrack as json.
func (o OptAnswerRequestStreamTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AnswerRequestStreamTrack from json.
func (o *OptAnswerRequestStreamTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnswerRequestStreamTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnswerRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnswerRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestWebhookURLMethod as json.
func (o OptAnswerRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AnswerRequestWebhookURLMethod from json.
func (o *OptAnswerRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnswerRequestWebhookURLMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnswerRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnswerRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ApplicationName as json.
func (o OptApplicationName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ApplicationName from json.
func (o *OptApplicationName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptApplicationName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptApplicationName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptApplicationName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttemptStatus as json.
func (o OptAttemptStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AttemptStatus from json.
func (o *OptAttemptStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAttemptStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAttemptStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAttemptStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AwsAccessKeyId as json.
func (o OptAwsAccessKeyId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AwsAccessKeyId from json.
func (o *OptAwsAccessKeyId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAwsAccessKeyId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAwsAccessKeyId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAwsAccessKeyId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AwsSecretAccessKey as json.
func (o OptAwsSecretAccessKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AwsSecretAccessKey from json.
func (o *OptAwsSecretAccessKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAwsSecretAccessKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAwsSecretAccessKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAwsSecretAccessKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AzureAccountKey as json.
func (o OptAzureAccountKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AzureAccountKey from json.
func (o *OptAzureAccountKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAzureAccountKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAzureAccountKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAzureAccountKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AzureAccountName as json.
func (o OptAzureAccountName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AzureAccountName from json.
func (o *OptAzureAccountName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAzureAccountName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAzureAccountName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAzureAccountName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Bucket as json.
func (o OptBucket) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Bucket from json.
func (o *OptBucket) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBucket to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBucket) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBucket) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkCredentialResponseData as json.
func (o OptBulkCredentialResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BulkCredentialResponseData from json.
func (o *OptBulkCredentialResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkCredentialResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkCredentialResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkCredentialResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteRoomRecordingsResponseData as json.
func (o OptBulkDeleteRoomRecordingsResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BulkDeleteRoomRecordingsResponseData from json.
func (o *OptBulkDeleteRoomRecordingsResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDeleteRoomRecordingsResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDeleteRoomRecordingsResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDeleteRoomRecordingsResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Call as json.
func (o OptCall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Call from json.
func (o *OptCall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCall to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplication as json.
func (o OptCallControlApplication) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallControlApplication from json.
func (o *OptCallControlApplication) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlApplication to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlApplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlApplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationAnchorsiteOverride as json.
func (o OptCallControlApplicationAnchorsiteOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallControlApplicationAnchorsiteOverride from json.
func (o *OptCallControlApplicationAnchorsiteOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlApplicationAnchorsiteOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlApplicationAnchorsiteOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlApplicationAnchorsiteOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationDtmfType as json.
func (o OptCallControlApplicationDtmfType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallControlApplicationDtmfType from json.
func (o *OptCallControlApplicationDtmfType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlApplicationDtmfType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlApplicationDtmfType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlApplicationDtmfType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationInbound as json.
func (o OptCallControlApplicationInbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallControlApplicationInbound from json.
func (o *OptCallControlApplicationInbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlApplicationInbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlApplicationInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlApplicationInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationInboundSipSubdomainReceiveSettings as json.
func (o OptCallControlApplicationInboundSipSubdomainReceiveSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallControlApplicationInboundSipSubdomainReceiveSettings from json.
func (o *OptCallControlApplicationInboundSipSubdomainReceiveSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlApplicationInboundSipSubdomainReceiveSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlApplicationInboundSipSubdomainReceiveSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlApplicationInboundSipSubdomainReceiveSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationOutbound as json.
func (o OptCallControlApplicationOutbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallControlApplicationOutbound from json.
func (o *OptCallControlApplicationOutbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlApplicationOutbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlApplicationOutbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlApplicationOutbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationRecordType as json.
func (o OptCallControlApplicationRecordType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallControlApplicationRecordType from json.
func (o *OptCallControlApplicationRecordType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlApplicationRecordType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlApplicationRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlApplicationRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlApplicationWebhookAPIVersion as json.
func (o OptCallControlApplicationWebhookAPIVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallControlApplicationWebhookAPIVersion from json.
func (o *OptCallControlApplicationWebhookAPIVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlApplicationWebhookAPIVersion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlApplicationWebhookAPIVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlApplicationWebhookAPIVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlCommandResult as json.
func (o OptCallControlCommandResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallControlCommandResult from json.
func (o *OptCallControlCommandResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlCommandResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlCommandResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlCommandResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlId as json.
func (o OptCallControlId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallControlId from json.
func (o *OptCallControlId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallReasonsItemGoogleVerificationStatus as json.
func (o OptCallReasonsItemGoogleVerificationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallReasonsItemGoogleVerificationStatus from json.
func (o *OptCallReasonsItemGoogleVerificationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallReasonsItemGoogleVerificationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallReasonsItemGoogleVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallReasonsItemGoogleVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestAnsweringMachineDetection as json.
func (o OptCallRequestAnsweringMachineDetection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestAnsweringMachineDetection from json.
func (o *OptCallRequestAnsweringMachineDetection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestAnsweringMachineDetection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestAnsweringMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestAnsweringMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestAnsweringMachineDetectionConfig as json.
func (o OptCallRequestAnsweringMachineDetectionConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallRequestAnsweringMachineDetectionConfig from json.
func (o *OptCallRequestAnsweringMachineDetectionConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestAnsweringMachineDetectionConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestAnsweringMachineDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestAnsweringMachineDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfig as json.
func (o OptCallRequestConferenceConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallRequestConferenceConfig from json.
func (o *OptCallRequestConferenceConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestConferenceConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestConferenceConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestConferenceConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfigBeepEnabled as json.
func (o OptCallRequestConferenceConfigBeepEnabled) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestConferenceConfigBeepEnabled from json.
func (o *OptCallRequestConferenceConfigBeepEnabled) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestConferenceConfigBeepEnabled to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestConferenceConfigBeepEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestConferenceConfigBeepEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfigSupervisorRole as json.
func (o OptCallRequestConferenceConfigSupervisorRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestConferenceConfigSupervisorRole from json.
func (o *OptCallRequestConferenceConfigSupervisorRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestConferenceConfigSupervisorRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestConferenceConfigSupervisorRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestConferenceConfigSupervisorRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestMediaEncryption as json.
func (o OptCallRequestMediaEncryption) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestMediaEncryption from json.
func (o *OptCallRequestMediaEncryption) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestMediaEncryption to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestMediaEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestMediaEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecord as json.
func (o OptCallRequestRecord) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestRecord from json.
func (o *OptCallRequestRecord) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestRecord to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordChannels as json.
func (o OptCallRequestRecordChannels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestRecordChannels from json.
func (o *OptCallRequestRecordChannels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestRecordChannels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestRecordChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestRecordChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordFormat as json.
func (o OptCallRequestRecordFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestRecordFormat from json.
func (o *OptCallRequestRecordFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestRecordFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestRecordFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestRecordFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordTrim as json.
func (o OptCallRequestRecordTrim) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestRecordTrim from json.
func (o *OptCallRequestRecordTrim) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestRecordTrim to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestRecordTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestRecordTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestSipTransportProtocol as json.
func (o OptCallRequestSipTransportProtocol) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestSipTransportProtocol from json.
func (o *OptCallRequestSipTransportProtocol) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestSipTransportProtocol to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestSipTransportProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestSipTransportProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestStreamTrack as json.
func (o OptCallRequestStreamTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestStreamTrack from json.
func (o *OptCallRequestStreamTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestStreamTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestWebhookURLMethod as json.
func (o OptCallRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestWebhookURLMethod from json.
func (o *OptCallRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestWebhookURLMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResource as json.
func (o OptCallResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallResource from json.
func (o *OptCallResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceAnsweredBy as json.
func (o OptCallResourceAnsweredBy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallResourceAnsweredBy from json.
func (o *OptCallResourceAnsweredBy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResourceAnsweredBy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResourceAnsweredBy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResourceAnsweredBy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceDirection as json.
func (o OptCallResourceDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallResourceDirection from json.
func (o *OptCallResourceDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResourceDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResourceDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResourceDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceIndex as json.
func (o OptCallResourceIndex) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallResourceIndex from json.
func (o *OptCallResourceIndex) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResourceIndex to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceStatus as json.
func (o OptCallResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallResourceStatus from json.
func (o *OptCallResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CdrUsageReportResponse as json.
func (o OptCdrUsageReportResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CdrUsageReportResponse from json.
func (o *OptCdrUsageReportResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCdrUsageReportResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCdrUsageReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCdrUsageReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CdrUsageReportResponseAggregationType as json.
func (o OptCdrUsageReportResponseAggregationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CdrUsageReportResponseAggregationType from json.
func (o *OptCdrUsageReportResponseAggregationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCdrUsageReportResponseAggregationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCdrUsageReportResponseAggregationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCdrUsageReportResponseAggregationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CdrUsageReportResponseProductBreakdown as json.
func (o OptCdrUsageReportResponseProductBreakdown) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CdrUsageReportResponseProductBreakdown from json.
func (o *OptCdrUsageReportResponseProductBreakdown) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCdrUsageReportResponseProductBreakdown to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCdrUsageReportResponseProductBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCdrUsageReportResponseProductBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CdrUsageReportResponseResult as json.
func (o OptCdrUsageReportResponseResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CdrUsageReportResponseResult from json.
func (o *OptCdrUsageReportResponseResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCdrUsageReportResponseResult to nil")
	}
	o.Set = true
	o.Value = make(CdrUsageReportResponseResult)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCdrUsageReportResponseResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCdrUsageReportResponseResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CdrUsageReportResponseStatus as json.
func (o OptCdrUsageReportResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CdrUsageReportResponseStatus from json.
func (o *OptCdrUsageReportResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCdrUsageReportResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCdrUsageReportResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCdrUsageReportResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceIndex as json.
func (o OptConferenceRecordingResourceIndex) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceRecordingResourceIndex from json.
func (o *OptConferenceRecordingResourceIndex) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceRecordingResourceIndex to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceRecordingResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceRecordingResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceSource as json.
func (o OptConferenceRecordingResourceSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConferenceRecordingResourceSource from json.
func (o *OptConferenceRecordingResourceSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceRecordingResourceSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceRecordingResourceSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceRecordingResourceSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceStatus as json.
func (o OptConferenceRecordingResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConferenceRecordingResourceStatus from json.
func (o *OptConferenceRecordingResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceRecordingResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceRecordingResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceRecordingResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceSubresourceUris as json.
func (o OptConferenceRecordingResourceSubresourceUris) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceRecordingResourceSubresourceUris from json.
func (o *OptConferenceRecordingResourceSubresourceUris) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceRecordingResourceSubresourceUris to nil")
	}
	o.Set = true
	o.Value = make(ConferenceRecordingResourceSubresourceUris)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceRecordingResourceSubresourceUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceRecordingResourceSubresourceUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResource as json.
func (o OptConferenceResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceResource from json.
func (o *OptConferenceResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceIndex as json.
func (o OptConferenceResourceIndex) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceResourceIndex from json.
func (o *OptConferenceResourceIndex) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResourceIndex to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceReasonConferenceEnded as json.
func (o OptConferenceResourceReasonConferenceEnded) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConferenceResourceReasonConferenceEnded from json.
func (o *OptConferenceResourceReasonConferenceEnded) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResourceReasonConferenceEnded to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResourceReasonConferenceEnded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResourceReasonConferenceEnded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceStatus as json.
func (o OptConferenceResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConferenceResourceStatus from json.
func (o *OptConferenceResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceSubresourceUris as json.
func (o OptConferenceResourceSubresourceUris) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceResourceSubresourceUris from json.
func (o *OptConferenceResourceSubresourceUris) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResourceSubresourceUris to nil")
	}
	o.Set = true
	o.Value = make(ConferenceResourceSubresourceUris)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResourceSubresourceUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResourceSubresourceUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConnectionActive as json.
func (o OptConnectionActive) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConnectionActive from json.
func (o *OptConnectionActive) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConnectionActive to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConnectionActive) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConnectionActive) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCallControlApplicationRequestAnchorsiteOverride as json.
func (o OptCreateCallControlApplicationRequestAnchorsiteOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateCallControlApplicationRequestAnchorsiteOverride from json.
func (o *OptCreateCallControlApplicationRequestAnchorsiteOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateCallControlApplicationRequestAnchorsiteOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateCallControlApplicationRequestAnchorsiteOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateCallControlApplicationRequestAnchorsiteOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCallControlApplicationRequestDtmfType as json.
func (o OptCreateCallControlApplicationRequestDtmfType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateCallControlApplicationRequestDtmfType from json.
func (o *OptCreateCallControlApplicationRequestDtmfType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateCallControlApplicationRequestDtmfType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateCallControlApplicationRequestDtmfType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateCallControlApplicationRequestDtmfType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCallControlApplicationRequestWebhookAPIVersion as json.
func (o OptCreateCallControlApplicationRequestWebhookAPIVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateCallControlApplicationRequestWebhookAPIVersion from json.
func (o *OptCreateCallControlApplicationRequestWebhookAPIVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateCallControlApplicationRequestWebhookAPIVersion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateCallControlApplicationRequestWebhookAPIVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateCallControlApplicationRequestWebhookAPIVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTeXMLSecretResult as json.
func (o OptCreateTeXMLSecretResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateTeXMLSecretResult from json.
func (o *OptCreateTeXMLSecretResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTeXMLSecretResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTeXMLSecretResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTeXMLSecretResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTeXMLSecretResultValue as json.
func (o OptCreateTeXMLSecretResultValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateTeXMLSecretResultValue from json.
func (o *OptCreateTeXMLSecretResultValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTeXMLSecretResultValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTeXMLSecretResultValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTeXMLSecretResultValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationRequestInbound as json.
func (o OptCreateTexmlApplicationRequestInbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateTexmlApplicationRequestInbound from json.
func (o *OptCreateTexmlApplicationRequestInbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTexmlApplicationRequestInbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTexmlApplicationRequestInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTexmlApplicationRequestInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings as json.
func (o OptCreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings from json.
func (o *OptCreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationRequestOutbound as json.
func (o OptCreateTexmlApplicationRequestOutbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateTexmlApplicationRequestOutbound from json.
func (o *OptCreateTexmlApplicationRequestOutbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTexmlApplicationRequestOutbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTexmlApplicationRequestOutbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTexmlApplicationRequestOutbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationRequestStatusCallbackMethod as json.
func (o OptCreateTexmlApplicationRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateTexmlApplicationRequestStatusCallbackMethod from json.
func (o *OptCreateTexmlApplicationRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTexmlApplicationRequestStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTexmlApplicationRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTexmlApplicationRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTexmlApplicationRequestVoiceMethod as json.
func (o OptCreateTexmlApplicationRequestVoiceMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateTexmlApplicationRequestVoiceMethod from json.
func (o *OptCreateTexmlApplicationRequestVoiceMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTexmlApplicationRequestVoiceMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTexmlApplicationRequestVoiceMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTexmlApplicationRequestVoiceMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVerifyProfileCallRequest as json.
func (o OptCreateVerifyProfileCallRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateVerifyProfileCallRequest from json.
func (o *OptCreateVerifyProfileCallRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateVerifyProfileCallRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateVerifyProfileCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateVerifyProfileCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVerifyProfileFlashcallRequest as json.
func (o OptCreateVerifyProfileFlashcallRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateVerifyProfileFlashcallRequest from json.
func (o *OptCreateVerifyProfileFlashcallRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateVerifyProfileFlashcallRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateVerifyProfileFlashcallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateVerifyProfileFlashcallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVerifyProfileSMSRequest as json.
func (o OptCreateVerifyProfileSMSRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateVerifyProfileSMSRequest from json.
func (o *OptCreateVerifyProfileSMSRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateVerifyProfileSMSRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateVerifyProfileSMSRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateVerifyProfileSMSRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatedAt as json.
func (o OptCreatedAt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreatedAt from json.
func (o *OptCreatedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreatedAt to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreatedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreatedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Credentials as json.
func (o OptCredentials) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Credentials from json.
func (o *OptCredentials) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCredentials to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Cursor as json.
func (o OptCursor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Cursor from json.
func (o *OptCursor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCursor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCursor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCursor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CursorPaginationMeta as json.
func (o OptCursorPaginationMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CursorPaginationMeta from json.
func (o *OptCursorPaginationMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCursorPaginationMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCursorPaginationMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCursorPaginationMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DateTimeRFC2822 as json.
func (o OptDateTimeRFC2822) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DateTimeRFC2822 from json.
func (o *OptDateTimeRFC2822) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTimeRFC2822 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTimeRFC2822) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTimeRFC2822) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DialogflowConfig as json.
func (o OptDialogflowConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DialogflowConfig from json.
func (o *OptDialogflowConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDialogflowConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDialogflowConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDialogflowConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisplayName as json.
func (o OptDisplayName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DisplayName from json.
func (o *OptDisplayName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDisplayName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDisplayName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDisplayName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DtmfType as json.
func (o OptDtmfType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DtmfType from json.
func (o *OptDtmfType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDtmfType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDtmfType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDtmfType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorMeta as json.
func (o OptErrorMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorMeta from json.
func (o *OptErrorMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorMeta to nil")
	}
	o.Set = true
	o.Value = make(ErrorMeta)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorSource as json.
func (o OptErrorSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorSource from json.
func (o *OptErrorSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FirstCommandTimeout as json.
func (o OptFirstCommandTimeout) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FirstCommandTimeout from json.
func (o *OptFirstCommandTimeout) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFirstCommandTimeout to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFirstCommandTimeout) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFirstCommandTimeout) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FirstCommandTimeoutSecs as json.
func (o OptFirstCommandTimeoutSecs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FirstCommandTimeoutSecs from json.
func (o *OptFirstCommandTimeoutSecs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFirstCommandTimeoutSecs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFirstCommandTimeoutSecs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFirstCommandTimeoutSecs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestLanguage as json.
func (o OptGatherUsingSpeakRequestLanguage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GatherUsingSpeakRequestLanguage from json.
func (o *OptGatherUsingSpeakRequestLanguage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatherUsingSpeakRequestLanguage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatherUsingSpeakRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatherUsingSpeakRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestPayloadType as json.
func (o OptGatherUsingSpeakRequestPayloadType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GatherUsingSpeakRequestPayloadType from json.
func (o *OptGatherUsingSpeakRequestPayloadType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatherUsingSpeakRequestPayloadType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatherUsingSpeakRequestPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatherUsingSpeakRequestPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestServiceLevel as json.
func (o OptGatherUsingSpeakRequestServiceLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GatherUsingSpeakRequestServiceLevel from json.
func (o *OptGatherUsingSpeakRequestServiceLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatherUsingSpeakRequestServiceLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatherUsingSpeakRequestServiceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatherUsingSpeakRequestServiceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestAsyncAmdStatusCallbackMethod as json.
func (o OptInitiateCallRequestAsyncAmdStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestAsyncAmdStatusCallbackMethod from json.
func (o *OptInitiateCallRequestAsyncAmdStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestAsyncAmdStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestAsyncAmdStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestAsyncAmdStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestDetectionMode as json.
func (o OptInitiateCallRequestDetectionMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestDetectionMode from json.
func (o *OptInitiateCallRequestDetectionMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestDetectionMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestDetectionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestDetectionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestMachineDetection as json.
func (o OptInitiateCallRequestMachineDetection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestMachineDetection from json.
func (o *OptInitiateCallRequestMachineDetection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestMachineDetection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingChannels as json.
func (o OptInitiateCallRequestRecordingChannels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestRecordingChannels from json.
func (o *OptInitiateCallRequestRecordingChannels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestRecordingChannels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestRecordingChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestRecordingChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingStatusCallbackMethod as json.
func (o OptInitiateCallRequestRecordingStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestRecordingStatusCallbackMethod from json.
func (o *OptInitiateCallRequestRecordingStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestRecordingStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestRecordingStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestRecordingStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingTrack as json.
func (o OptInitiateCallRequestRecordingTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestRecordingTrack from json.
func (o *OptInitiateCallRequestRecordingTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestRecordingTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestStatusCallbackEvent as json.
func (o OptInitiateCallRequestStatusCallbackEvent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestStatusCallbackEvent from json.
func (o *OptInitiateCallRequestStatusCallbackEvent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestStatusCallbackEvent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestStatusCallbackEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestStatusCallbackEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestStatusCallbackMethod as json.
func (o OptInitiateCallRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestStatusCallbackMethod from json.
func (o *OptInitiateCallRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestTrim as json.
func (o OptInitiateCallRequestTrim) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestTrim from json.
func (o *OptInitiateCallRequestTrim) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestTrim to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestUrlMethod as json.
func (o OptInitiateCallRequestUrlMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestUrlMethod from json.
func (o *OptInitiateCallRequestUrlMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestUrlMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestUrlMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestUrlMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallResult as json.
func (o OptInitiateCallResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InitiateCallResult from json.
func (o *OptInitiateCallResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IntId as json.
func (o OptIntId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IntId from json.
func (o *OptIntId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIntId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIntId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIntId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogoURL as json.
func (o OptLogoURL) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LogoURL from json.
func (o *OptLogoURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLogoURL to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLogoURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLogoURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Loopcount as json.
func (o OptLoopcount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Loopcount from json.
func (o *OptLoopcount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoopcount to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoopcount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoopcount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MdrUsageReportResponse as json.
func (o OptMdrUsageReportResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MdrUsageReportResponse from json.
func (o *OptMdrUsageReportResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMdrUsageReportResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMdrUsageReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMdrUsageReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MdrUsageReportResponseAggregationType as json.
func (o OptMdrUsageReportResponseAggregationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MdrUsageReportResponseAggregationType from json.
func (o *OptMdrUsageReportResponseAggregationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMdrUsageReportResponseAggregationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMdrUsageReportResponseAggregationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMdrUsageReportResponseAggregationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MdrUsageReportResponseStatus as json.
func (o OptMdrUsageReportResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MdrUsageReportResponseStatus from json.
func (o *OptMdrUsageReportResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMdrUsageReportResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMdrUsageReportResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMdrUsageReportResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MetaResponse as json.
func (o OptMetaResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MetaResponse from json.
func (o *OptMetaResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMetaResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMetaResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMetaResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewParticipantResource as json.
func (o OptNewParticipantResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NewParticipantResource from json.
func (o *OptNewParticipantResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNewParticipantResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNewParticipantResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNewParticipantResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewParticipantResourceStatus as json.
func (o OptNewParticipantResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NewParticipantResourceStatus from json.
func (o *OptNewParticipantResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNewParticipantResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNewParticipantResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNewParticipantResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceSid as json.
func (o OptNilConferenceSid) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceSid from json.
func (o *OptNilConferenceSid) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConferenceSid to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConferenceSid
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConferenceSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConferenceSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlErrorCode as json.
func (o OptNilTexmlErrorCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlErrorCode from json.
func (o *OptNilTexmlErrorCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTexmlErrorCode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TexmlErrorCode
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTexmlErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTexmlErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlPriceUnit as json.
func (o OptNilTexmlPriceUnit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlPriceUnit from json.
func (o *OptNilTexmlPriceUnit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTexmlPriceUnit to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TexmlPriceUnit
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTexmlPriceUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTexmlPriceUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingDuration as json.
func (o OptNilTexmlRecordingDuration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlRecordingDuration from json.
func (o *OptNilTexmlRecordingDuration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTexmlRecordingDuration to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TexmlRecordingDuration
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTexmlRecordingDuration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTexmlRecordingDuration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingPrice as json.
func (o OptNilTexmlRecordingPrice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlRecordingPrice from json.
func (o *OptNilTexmlRecordingPrice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTexmlRecordingPrice to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TexmlRecordingPrice
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTexmlRecordingPrice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTexmlRecordingPrice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptNilURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NoiseSuppressionDirection as json.
func (o OptNoiseSuppressionDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NoiseSuppressionDirection from json.
func (o *OptNoiseSuppressionDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNoiseSuppressionDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNoiseSuppressionDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNoiseSuppressionDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OutboundVoiceProfileId as json.
func (o OptOutboundVoiceProfileId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OutboundVoiceProfileId from json.
func (o *OptOutboundVoiceProfileId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOutboundVoiceProfileId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOutboundVoiceProfileId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOutboundVoiceProfileId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaginationData as json.
func (o OptPaginationData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PaginationData from json.
func (o *OptPaginationData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPaginationData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPaginationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPaginationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaginationMeta as json.
func (o OptPaginationMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PaginationMeta from json.
func (o *OptPaginationMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPaginationMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPaginationMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPaginationMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantResource as json.
func (o OptParticipantResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ParticipantResource from json.
func (o *OptParticipantResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParticipantResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParticipantResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParticipantResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantResourceIndex as json.
func (o OptParticipantResourceIndex) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ParticipantResourceIndex from json.
func (o *OptParticipantResourceIndex) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParticipantResourceIndex to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParticipantResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParticipantResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantResourceStatus as json.
func (o OptParticipantResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ParticipantResourceStatus from json.
func (o *OptParticipantResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParticipantResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParticipantResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParticipantResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhoneNumbersItemGoogleVerificationStatus as json.
func (o OptPhoneNumbersItemGoogleVerificationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PhoneNumbersItemGoogleVerificationStatus from json.
func (o *OptPhoneNumbersItemGoogleVerificationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPhoneNumbersItemGoogleVerificationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPhoneNumbersItemGoogleVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPhoneNumbersItemGoogleVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayAudioUrlRequestAudioType as json.
func (o OptPlayAudioUrlRequestAudioType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayAudioUrlRequestAudioType from json.
func (o *OptPlayAudioUrlRequestAudioType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayAudioUrlRequestAudioType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayAudioUrlRequestAudioType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayAudioUrlRequestAudioType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueueCall as json.
func (o OptQueueCall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QueueCall from json.
func (o *OptQueueCall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQueueCall to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQueueCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQueueCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseData as json.
func (o OptRecordingResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecordingResponseData from json.
func (o *OptRecordingResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataChannels as json.
func (o OptRecordingResponseDataChannels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecordingResponseDataChannels from json.
func (o *OptRecordingResponseDataChannels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingResponseDataChannels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingResponseDataChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingResponseDataChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataDownloadUrls as json.
func (o OptRecordingResponseDataDownloadUrls) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecordingResponseDataDownloadUrls from json.
func (o *OptRecordingResponseDataDownloadUrls) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingResponseDataDownloadUrls to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingResponseDataDownloadUrls) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingResponseDataDownloadUrls) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataRecordType as json.
func (o OptRecordingResponseDataRecordType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecordingResponseDataRecordType from json.
func (o *OptRecordingResponseDataRecordType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingResponseDataRecordType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingResponseDataRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingResponseDataRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataSource as json.
func (o OptRecordingResponseDataSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecordingResponseDataSource from json.
func (o *OptRecordingResponseDataSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingResponseDataSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingResponseDataSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingResponseDataSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataStatus as json.
func (o OptRecordingResponseDataStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecordingResponseDataStatus from json.
func (o *OptRecordingResponseDataStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingResponseDataStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingResponseDataStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingResponseDataStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingSource as json.
func (o OptRecordingSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecordingSource from json.
func (o *OptRecordingSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingTrack as json.
func (o OptRecordingTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecordingTrack from json.
func (o *OptRecordingTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Region as json.
func (o OptRegion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Region from json.
func (o *OptRegion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterCallResponseData as json.
func (o OptRegisterCallResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RegisterCallResponseData from json.
func (o *OptRegisterCallResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegisterCallResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegisterCallResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegisterCallResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoomRecording as json.
func (o OptRoomRecording) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RoomRecording from json.
func (o *OptRoomRecording) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRoomRecording to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRoomRecording) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRoomRecording) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoomRecordingStatus as json.
func (o OptRoomRecordingStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RoomRecordingStatus from json.
func (o *OptRoomRecordingStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRoomRecordingStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRoomRecordingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRoomRecordingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoomRecordingType as json.
func (o OptRoomRecordingType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RoomRecordingType from json.
func (o *OptRoomRecordingType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRoomRecordingType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRoomRecordingType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRoomRecordingType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SoundModifications as json.
func (o OptSoundModifications) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SoundModifications from json.
func (o *OptSoundModifications) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSoundModifications to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSoundModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSoundModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SourceResponse as json.
func (o OptSourceResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SourceResponse from json.
func (o *OptSourceResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSourceResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSourceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSourceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestLanguage as json.
func (o OptSpeakRequestLanguage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeakRequestLanguage from json.
func (o *OptSpeakRequestLanguage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeakRequestLanguage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeakRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeakRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestPayloadType as json.
func (o OptSpeakRequestPayloadType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeakRequestPayloadType from json.
func (o *OptSpeakRequestPayloadType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeakRequestPayloadType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeakRequestPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeakRequestPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestServiceLevel as json.
func (o OptSpeakRequestServiceLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeakRequestServiceLevel from json.
func (o *OptSpeakRequestServiceLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeakRequestServiceLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeakRequestServiceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeakRequestServiceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartForkingRequestStreamType as json.
func (o OptStartForkingRequestStreamType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartForkingRequestStreamType from json.
func (o *OptStartForkingRequestStreamType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartForkingRequestStreamType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartForkingRequestStreamType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartForkingRequestStreamType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestRecordingTrack as json.
func (o OptStartRecordingRequestRecordingTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartRecordingRequestRecordingTrack from json.
func (o *OptStartRecordingRequestRecordingTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartRecordingRequestRecordingTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartRecordingRequestRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartRecordingRequestRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestTrim as json.
func (o OptStartRecordingRequestTrim) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartRecordingRequestTrim from json.
func (o *OptStartRecordingRequestTrim) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartRecordingRequestTrim to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartRecordingRequestTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartRecordingRequestTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartStreamingRequestStreamTrack as json.
func (o OptStartStreamingRequestStreamTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartStreamingRequestStreamTrack from json.
func (o *OptStartStreamingRequestStreamTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartStreamingRequestStreamTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartStreamingRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartStreamingRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StopForkingRequestStreamType as json.
func (o OptStopForkingRequestStreamType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StopForkingRequestStreamType from json.
func (o *OptStopForkingRequestStreamType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStopForkingRequestStreamType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStopForkingRequestStreamType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStopForkingRequestStreamType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptStringInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeStringInt64(e, o.Value)
}

// Decode decodes int64 from json.
func (o *OptStringInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStringInt64 to nil")
	}
	o.Set = true
	v, err := json.DecodeStringInt64(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStringInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStringInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TelephonyCredential as json.
func (o OptTelephonyCredential) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TelephonyCredential from json.
func (o *OptTelephonyCredential) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTelephonyCredential to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTelephonyCredential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTelephonyCredential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplication as json.
func (o OptTexmlApplication) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlApplication from json.
func (o *OptTexmlApplication) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlApplication to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlApplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlApplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplicationInbound as json.
func (o OptTexmlApplicationInbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlApplicationInbound from json.
func (o *OptTexmlApplicationInbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlApplicationInbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlApplicationInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlApplicationInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplicationInboundSipSubdomainReceiveSettings as json.
func (o OptTexmlApplicationInboundSipSubdomainReceiveSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TexmlApplicationInboundSipSubdomainReceiveSettings from json.
func (o *OptTexmlApplicationInboundSipSubdomainReceiveSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlApplicationInboundSipSubdomainReceiveSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlApplicationInboundSipSubdomainReceiveSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlApplicationInboundSipSubdomainReceiveSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplicationOutbound as json.
func (o OptTexmlApplicationOutbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlApplicationOutbound from json.
func (o *OptTexmlApplicationOutbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlApplicationOutbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlApplicationOutbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlApplicationOutbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplicationStatusCallbackMethod as json.
func (o OptTexmlApplicationStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TexmlApplicationStatusCallbackMethod from json.
func (o *OptTexmlApplicationStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlApplicationStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlApplicationStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlApplicationStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplicationVoiceMethod as json.
func (o OptTexmlApplicationVoiceMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TexmlApplicationVoiceMethod from json.
func (o *OptTexmlApplicationVoiceMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlApplicationVoiceMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlApplicationVoiceMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlApplicationVoiceMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingMediaUrl as json.
func (o OptTexmlRecordingMediaUrl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlRecordingMediaUrl from json.
func (o *OptTexmlRecordingMediaUrl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlRecordingMediaUrl to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlRecordingMediaUrl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlRecordingMediaUrl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingStatus as json.
func (o OptTexmlRecordingStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TexmlRecordingStatus from json.
func (o *OptTexmlRecordingStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlRecordingStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlRecordingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlRecordingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingSubresourcesUris as json.
func (o OptTexmlRecordingSubresourcesUris) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlRecordingSubresourcesUris from json.
func (o *OptTexmlRecordingSubresourcesUris) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlRecordingSubresourcesUris to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlRecordingSubresourcesUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlRecordingSubresourcesUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingTranscriptionStatus as json.
func (o OptTexmlRecordingTranscriptionStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TexmlRecordingTranscriptionStatus from json.
func (o *OptTexmlRecordingTranscriptionStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlRecordingTranscriptionStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlRecordingTranscriptionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlRecordingTranscriptionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlSid as json.
func (o OptTexmlSid) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlSid from json.
func (o *OptTexmlSid) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlSid to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscriptionStartRequestLanguage as json.
func (o OptTranscriptionStartRequestLanguage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TranscriptionStartRequestLanguage from json.
func (o *OptTranscriptionStartRequestLanguage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTranscriptionStartRequestLanguage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTranscriptionStartRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTranscriptionStartRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscriptionStartRequestTranscriptionEngine as json.
func (o OptTranscriptionStartRequestTranscriptionEngine) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TranscriptionStartRequestTranscriptionEngine from json.
func (o *OptTranscriptionStartRequestTranscriptionEngine) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTranscriptionStartRequestTranscriptionEngine to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTranscriptionStartRequestTranscriptionEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTranscriptionStartRequestTranscriptionEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestAnsweringMachineDetection as json.
func (o OptTransferCallRequestAnsweringMachineDetection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferCallRequestAnsweringMachineDetection from json.
func (o *OptTransferCallRequestAnsweringMachineDetection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestAnsweringMachineDetection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestAnsweringMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestAnsweringMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestAnsweringMachineDetectionConfig as json.
func (o OptTransferCallRequestAnsweringMachineDetectionConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TransferCallRequestAnsweringMachineDetectionConfig from json.
func (o *OptTransferCallRequestAnsweringMachineDetectionConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestAnsweringMachineDetectionConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestAnsweringMachineDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestAnsweringMachineDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestMediaEncryption as json.
func (o OptTransferCallRequestMediaEncryption) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferCallRequestMediaEncryption from json.
func (o *OptTransferCallRequestMediaEncryption) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestMediaEncryption to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestMediaEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestMediaEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestSipTransportProtocol as json.
func (o OptTransferCallRequestSipTransportProtocol) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferCallRequestSipTransportProtocol from json.
func (o *OptTransferCallRequestSipTransportProtocol) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestSipTransportProtocol to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestSipTransportProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestSipTransportProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestWebhookURLMethod as json.
func (o OptTransferCallRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferCallRequestWebhookURLMethod from json.
func (o *OptTransferCallRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestWebhookURLMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TwimlRecordingChannels as json.
func (o OptTwimlRecordingChannels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes TwimlRecordingChannels from json.
func (o *OptTwimlRecordingChannels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTwimlRecordingChannels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTwimlRecordingChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTwimlRecordingChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallControlApplicationRequestAnchorsiteOverride as json.
func (o OptUpdateCallControlApplicationRequestAnchorsiteOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallControlApplicationRequestAnchorsiteOverride from json.
func (o *OptUpdateCallControlApplicationRequestAnchorsiteOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallControlApplicationRequestAnchorsiteOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallControlApplicationRequestAnchorsiteOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallControlApplicationRequestAnchorsiteOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallControlApplicationRequestDtmfType as json.
func (o OptUpdateCallControlApplicationRequestDtmfType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallControlApplicationRequestDtmfType from json.
func (o *OptUpdateCallControlApplicationRequestDtmfType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallControlApplicationRequestDtmfType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallControlApplicationRequestDtmfType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallControlApplicationRequestDtmfType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallControlApplicationRequestWebhookAPIVersion as json.
func (o OptUpdateCallControlApplicationRequestWebhookAPIVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallControlApplicationRequestWebhookAPIVersion from json.
func (o *OptUpdateCallControlApplicationRequestWebhookAPIVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallControlApplicationRequestWebhookAPIVersion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallControlApplicationRequestWebhookAPIVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallControlApplicationRequestWebhookAPIVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestFallbackMethod as json.
func (o OptUpdateCallRequestFallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallRequestFallbackMethod from json.
func (o *OptUpdateCallRequestFallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallRequestFallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallRequestFallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallRequestFallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestMethod as json.
func (o OptUpdateCallRequestMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallRequestMethod from json.
func (o *OptUpdateCallRequestMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallRequestMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallRequestMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallRequestMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestStatusCallbackMethod as json.
func (o OptUpdateCallRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallRequestStatusCallbackMethod from json.
func (o *OptUpdateCallRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallRequestStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCommandResult as json.
func (o OptUpdateCommandResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateCommandResult from json.
func (o *OptUpdateCommandResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCommandResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCommandResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCommandResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationRequestInbound as json.
func (o OptUpdateTexmlApplicationRequestInbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateTexmlApplicationRequestInbound from json.
func (o *OptUpdateTexmlApplicationRequestInbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateTexmlApplicationRequestInbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateTexmlApplicationRequestInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateTexmlApplicationRequestInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings as json.
func (o OptUpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings from json.
func (o *OptUpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationRequestOutbound as json.
func (o OptUpdateTexmlApplicationRequestOutbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateTexmlApplicationRequestOutbound from json.
func (o *OptUpdateTexmlApplicationRequestOutbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateTexmlApplicationRequestOutbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateTexmlApplicationRequestOutbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateTexmlApplicationRequestOutbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationRequestStatusCallbackMethod as json.
func (o OptUpdateTexmlApplicationRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateTexmlApplicationRequestStatusCallbackMethod from json.
func (o *OptUpdateTexmlApplicationRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateTexmlApplicationRequestStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateTexmlApplicationRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateTexmlApplicationRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationRequestVoiceMethod as json.
func (o OptUpdateTexmlApplicationRequestVoiceMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateTexmlApplicationRequestVoiceMethod from json.
func (o *OptUpdateTexmlApplicationRequestVoiceMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateTexmlApplicationRequestVoiceMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateTexmlApplicationRequestVoiceMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateTexmlApplicationRequestVoiceMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVerifyProfileCallRequest as json.
func (o OptUpdateVerifyProfileCallRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateVerifyProfileCallRequest from json.
func (o *OptUpdateVerifyProfileCallRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateVerifyProfileCallRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateVerifyProfileCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateVerifyProfileCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVerifyProfileFlashcallRequest as json.
func (o OptUpdateVerifyProfileFlashcallRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateVerifyProfileFlashcallRequest from json.
func (o *OptUpdateVerifyProfileFlashcallRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateVerifyProfileFlashcallRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateVerifyProfileFlashcallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateVerifyProfileFlashcallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateVerifyProfileSMSRequest as json.
func (o OptUpdateVerifyProfileSMSRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateVerifyProfileSMSRequest from json.
func (o *OptUpdateVerifyProfileSMSRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateVerifyProfileSMSRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateVerifyProfileSMSRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateVerifyProfileSMSRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatedAt as json.
func (o OptUpdatedAt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdatedAt from json.
func (o *OptUpdatedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdatedAt to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdatedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdatedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBalance as json.
func (o OptUserBalance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserBalance from json.
func (o *OptUserBalance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserBalance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBalanceRecordType as json.
func (o OptUserBalanceRecordType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserBalanceRecordType from json.
func (o *OptUserBalanceRecordType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserBalanceRecordType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserBalanceRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserBalanceRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerificationProfileRecordType as json.
func (o OptVerificationProfileRecordType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VerificationProfileRecordType from json.
func (o *OptVerificationProfileRecordType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerificationProfileRecordType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerificationProfileRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerificationProfileRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerificationRecordType as json.
func (o OptVerificationRecordType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VerificationRecordType from json.
func (o *OptVerificationRecordType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerificationRecordType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerificationRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerificationRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerificationStatus as json.
func (o OptVerificationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VerificationStatus from json.
func (o *OptVerificationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerificationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerificationType as json.
func (o OptVerificationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VerificationType from json.
func (o *OptVerificationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerificationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedCallsDisplayProfile as json.
func (o OptVerifiedCallsDisplayProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VerifiedCallsDisplayProfile from json.
func (o *OptVerifiedCallsDisplayProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifiedCallsDisplayProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifiedCallsDisplayProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifiedCallsDisplayProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedCallsDisplayProfileBusinessIdentity as json.
func (o OptVerifiedCallsDisplayProfileBusinessIdentity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VerifiedCallsDisplayProfileBusinessIdentity from json.
func (o *OptVerifiedCallsDisplayProfileBusinessIdentity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifiedCallsDisplayProfileBusinessIdentity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifiedCallsDisplayProfileBusinessIdentity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifiedCallsDisplayProfileBusinessIdentity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus as json.
func (o OptVerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus from json.
func (o *OptVerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus as json.
func (o OptVerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus from json.
func (o *OptVerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedCallsDisplayProfileStatus as json.
func (o OptVerifiedCallsDisplayProfileStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VerifiedCallsDisplayProfileStatus from json.
func (o *OptVerifiedCallsDisplayProfileStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifiedCallsDisplayProfileStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifiedCallsDisplayProfileStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifiedCallsDisplayProfileStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedNumberRecordType as json.
func (o OptVerifiedNumberRecordType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VerifiedNumberRecordType from json.
func (o *OptVerifiedNumberRecordType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifiedNumberRecordType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifiedNumberRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifiedNumberRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedNumberResponse as json.
func (o OptVerifiedNumberResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VerifiedNumberResponse from json.
func (o *OptVerifiedNumberResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifiedNumberResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifiedNumberResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifiedNumberResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifyProfileCallResponse as json.
func (o OptVerifyProfileCallResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VerifyProfileCallResponse from json.
func (o *OptVerifyProfileCallResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifyProfileCallResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifyProfileCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifyProfileCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifyProfileFlashcallResponse as json.
func (o OptVerifyProfileFlashcallResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VerifyProfileFlashcallResponse from json.
func (o *OptVerifyProfileFlashcallResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifyProfileFlashcallResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifyProfileFlashcallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifyProfileFlashcallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifyProfileResponse as json.
func (o OptVerifyProfileResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VerifyProfileResponse from json.
func (o *OptVerifyProfileResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifyProfileResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifyProfileResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifyProfileResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifyProfileSMSResponse as json.
func (o OptVerifyProfileSMSResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VerifyProfileSMSResponse from json.
func (o *OptVerifyProfileSMSResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerifyProfileSMSResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVerifyProfileSMSResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVerifyProfileSMSResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDelivery as json.
func (o OptWebhookDelivery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookDelivery from json.
func (o *OptWebhookDelivery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookDelivery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookDelivery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookDelivery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDeliveryStatus as json.
func (o OptWebhookDeliveryStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WebhookDeliveryStatus from json.
func (o *OptWebhookDeliveryStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookDeliveryStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookDeliveryStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookDeliveryStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDeliveryWebhook as json.
func (o OptWebhookDeliveryWebhook) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookDeliveryWebhook from json.
func (o *OptWebhookDeliveryWebhook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookDeliveryWebhook to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookDeliveryWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookDeliveryWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDeliveryWebhookPayload as json.
func (o OptWebhookDeliveryWebhookPayload) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookDeliveryWebhookPayload from json.
func (o *OptWebhookDeliveryWebhookPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookDeliveryWebhookPayload to nil")
	}
	o.Set = true
	o.Value = make(WebhookDeliveryWebhookPayload)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookDeliveryWebhookPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookDeliveryWebhookPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDeliveryWebhookRecordType as json.
func (o OptWebhookDeliveryWebhookRecordType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WebhookDeliveryWebhookRecordType from json.
func (o *OptWebhookDeliveryWebhookRecordType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookDeliveryWebhookRecordType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookDeliveryWebhookRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookDeliveryWebhookRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OutboundVoiceProfileId as json.
func (s OutboundVoiceProfileId) Encode(e *jx.Encoder) {
	unwrapped := int64(s)

	json.EncodeStringInt64(e, unwrapped)
}

// Decode decodes OutboundVoiceProfileId from json.
func (s *OutboundVoiceProfileId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OutboundVoiceProfileId to nil")
	}
	var unwrapped int64
	if err := func() error {
		v, err := json.DecodeStringInt64(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OutboundVoiceProfileId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OutboundVoiceProfileId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OutboundVoiceProfileId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginationData) encodeFields(e *jx.Encoder) {
	{
		if s.TotalPages.Set {
			e.FieldStart("total_pages")
			s.TotalPages.Encode(e)
		}
	}
	{
		if s.TotalResults.Set {
			e.FieldStart("total_results")
			s.TotalResults.Encode(e)
		}
	}
	{
		if s.PageNumber.Set {
			e.FieldStart("page_number")
			s.PageNumber.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfPaginationData = [4]string{
	0: "total_pages",
	1: "total_results",
	2: "page_number",
	3: "page_size",
}

// Decode decodes PaginationData from json.
func (s *PaginationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginationData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_pages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_pages\"")
			}
		case "total_results":
			if err := func() error {
				s.TotalResults.Reset()
				if err := s.TotalResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_results\"")
			}
		case "page_number":
			if err := func() error {
				s.PageNumber.Reset()
				if err := s.PageNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_number\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginationData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginationMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginationMeta) encodeFields(e *jx.Encoder) {
	{
		if s.TotalPages.Set {
			e.FieldStart("total_pages")
			s.TotalPages.Encode(e)
		}
	}
	{
		if s.TotalResults.Set {
			e.FieldStart("total_results")
			s.TotalResults.Encode(e)
		}
	}
	{
		if s.PageNumber.Set {
			e.FieldStart("page_number")
			s.PageNumber.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfPaginationMeta = [4]string{
	0: "total_pages",
	1: "total_results",
	2: "page_number",
	3: "page_size",
}

// Decode decodes PaginationMeta from json.
func (s *PaginationMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginationMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_pages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_pages\"")
			}
		case "total_results":
			if err := func() error {
				s.TotalResults.Reset()
				if err := s.TotalResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_results\"")
			}
		case "page_number":
			if err := func() error {
				s.PageNumber.Reset()
				if err := s.PageNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_number\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginationMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginationMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginationMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.CallSidLegacy.Set {
			e.FieldStart("call_sid_legacy")
			s.CallSidLegacy.Encode(e)
		}
	}
	{
		if s.Coaching.Set {
			e.FieldStart("coaching")
			s.Coaching.Encode(e)
		}
	}
	{
		if s.CoachingCallSid.Set {
			e.FieldStart("coaching_call_sid")
			s.CoachingCallSid.Encode(e)
		}
	}
	{
		if s.CoachingCallSidLegacy.Set {
			e.FieldStart("coaching_call_sid_legacy")
			s.CoachingCallSidLegacy.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.EndConferenceOnExit.Set {
			e.FieldStart("end_conference_on_exit")
			s.EndConferenceOnExit.Encode(e)
		}
	}
	{
		if s.Hold.Set {
			e.FieldStart("hold")
			s.Hold.Encode(e)
		}
	}
	{
		if s.Muted.Set {
			e.FieldStart("muted")
			s.Muted.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipantResource = [14]string{
	0:  "account_sid",
	1:  "api_version",
	2:  "call_sid",
	3:  "call_sid_legacy",
	4:  "coaching",
	5:  "coaching_call_sid",
	6:  "coaching_call_sid_legacy",
	7:  "date_created",
	8:  "date_updated",
	9:  "end_conference_on_exit",
	10: "hold",
	11: "muted",
	12: "status",
	13: "uri",
}

// Decode decodes ParticipantResource from json.
func (s *ParticipantResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "call_sid_legacy":
			if err := func() error {
				s.CallSidLegacy.Reset()
				if err := s.CallSidLegacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid_legacy\"")
			}
		case "coaching":
			if err := func() error {
				s.Coaching.Reset()
				if err := s.Coaching.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching\"")
			}
		case "coaching_call_sid":
			if err := func() error {
				s.CoachingCallSid.Reset()
				if err := s.CoachingCallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching_call_sid\"")
			}
		case "coaching_call_sid_legacy":
			if err := func() error {
				s.CoachingCallSidLegacy.Reset()
				if err := s.CoachingCallSidLegacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching_call_sid_legacy\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "end_conference_on_exit":
			if err := func() error {
				s.EndConferenceOnExit.Reset()
				if err := s.EndConferenceOnExit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_conference_on_exit\"")
			}
		case "hold":
			if err := func() error {
				s.Hold.Reset()
				if err := s.Hold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold\"")
			}
		case "muted":
			if err := func() error {
				s.Muted.Reset()
				if err := s.Muted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muted\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantResourceIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantResourceIndex) encodeFields(e *jx.Encoder) {
	{
		if s.Participants != nil {
			e.FieldStart("participants")
			e.ArrStart()
			for _, elem := range s.Participants {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipantResourceIndex = [8]string{
	0: "participants",
	1: "end",
	2: "first_page_uri",
	3: "next_page_uri",
	4: "page",
	5: "page_size",
	6: "start",
	7: "uri",
}

// Decode decodes ParticipantResourceIndex from json.
func (s *ParticipantResourceIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantResourceIndex to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participants":
			if err := func() error {
				s.Participants = make([]ParticipantResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParticipantResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantResourceIndex")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantResourceStatus as json.
func (s ParticipantResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParticipantResourceStatus from json.
func (s *ParticipantResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParticipantResourceStatus(v) {
	case ParticipantResourceStatusConnecting:
		*s = ParticipantResourceStatusConnecting
	case ParticipantResourceStatusConnected:
		*s = ParticipantResourceStatusConnected
	case ParticipantResourceStatusCompleted:
		*s = ParticipantResourceStatusCompleted
	default:
		*s = ParticipantResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParticipantResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PauseRecordingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PauseRecordingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPauseRecordingRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes PauseRecordingRequest from json.
func (s *PauseRecordingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PauseRecordingRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PauseRecordingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PauseRecordingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PauseRecordingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhoneNumbers as json.
func (s PhoneNumbers) Encode(e *jx.Encoder) {
	unwrapped := []PhoneNumbersItem(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes PhoneNumbers from json.
func (s *PhoneNumbers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhoneNumbers to nil")
	}
	var unwrapped []PhoneNumbersItem
	if err := func() error {
		unwrapped = make([]PhoneNumbersItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PhoneNumbersItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PhoneNumbers(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PhoneNumbers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhoneNumbers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PhoneNumbersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PhoneNumbersItem) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.GoogleVerificationStatus.Set {
			e.FieldStart("google_verification_status")
			s.GoogleVerificationStatus.Encode(e)
		}
	}
	{
		if s.GoogleApprovalInfo.Set {
			e.FieldStart("google_approval_info")
			s.GoogleApprovalInfo.Encode(e)
		}
	}
	{
		if s.DisplayProfileID.Set {
			e.FieldStart("display_profile_id")
			s.DisplayProfileID.Encode(e)
		}
	}
	{
		if s.Delete.Set {
			e.FieldStart("delete")
			s.Delete.Encode(e)
		}
	}
}

var jsonFieldsNameOfPhoneNumbersItem = [7]string{
	0: "record_type",
	1: "id",
	2: "phone_number",
	3: "google_verification_status",
	4: "google_approval_info",
	5: "display_profile_id",
	6: "delete",
}

// Decode decodes PhoneNumbersItem from json.
func (s *PhoneNumbersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhoneNumbersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "google_verification_status":
			if err := func() error {
				s.GoogleVerificationStatus.Reset()
				if err := s.GoogleVerificationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_verification_status\"")
			}
		case "google_approval_info":
			if err := func() error {
				s.GoogleApprovalInfo.Reset()
				if err := s.GoogleApprovalInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_approval_info\"")
			}
		case "display_profile_id":
			if err := func() error {
				s.DisplayProfileID.Reset()
				if err := s.DisplayProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_profile_id\"")
			}
		case "delete":
			if err := func() error {
				s.Delete.Reset()
				if err := s.Delete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PhoneNumbersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PhoneNumbersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhoneNumbersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhoneNumbersItemGoogleVerificationStatus as json.
func (s PhoneNumbersItemGoogleVerificationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PhoneNumbersItemGoogleVerificationStatus from json.
func (s *PhoneNumbersItemGoogleVerificationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhoneNumbersItemGoogleVerificationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PhoneNumbersItemGoogleVerificationStatus(v) {
	case PhoneNumbersItemGoogleVerificationStatusSTATEUNSPECIFIED:
		*s = PhoneNumbersItemGoogleVerificationStatusSTATEUNSPECIFIED
	case PhoneNumbersItemGoogleVerificationStatusPENDINGAPPROVAL:
		*s = PhoneNumbersItemGoogleVerificationStatusPENDINGAPPROVAL
	case PhoneNumbersItemGoogleVerificationStatusAPPROVED:
		*s = PhoneNumbersItemGoogleVerificationStatusAPPROVED
	case PhoneNumbersItemGoogleVerificationStatusDENIED:
		*s = PhoneNumbersItemGoogleVerificationStatusDENIED
	case PhoneNumbersItemGoogleVerificationStatusPENDINGREMOVAL:
		*s = PhoneNumbersItemGoogleVerificationStatusPENDINGREMOVAL
	default:
		*s = PhoneNumbersItemGoogleVerificationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PhoneNumbersItemGoogleVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhoneNumbersItemGoogleVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayAudioUrlRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayAudioUrlRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		if s.MediaName.Set {
			e.FieldStart("media_name")
			s.MediaName.Encode(e)
		}
	}
	{
		if s.Loop.Set {
			e.FieldStart("loop")
			s.Loop.Encode(e)
		}
	}
	{
		if s.Overlay.Set {
			e.FieldStart("overlay")
			s.Overlay.Encode(e)
		}
	}
	{
		if s.Stop.Set {
			e.FieldStart("stop")
			s.Stop.Encode(e)
		}
	}
	{
		if s.TargetLegs.Set {
			e.FieldStart("target_legs")
			s.TargetLegs.Encode(e)
		}
	}
	{
		if s.CacheAudio.Set {
			e.FieldStart("cache_audio")
			s.CacheAudio.Encode(e)
		}
	}
	{
		if s.AudioType.Set {
			e.FieldStart("audio_type")
			s.AudioType.Encode(e)
		}
	}
	{
		if s.PlaybackContent.Set {
			e.FieldStart("playback_content")
			s.PlaybackContent.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayAudioUrlRequest = [11]string{
	0:  "audio_url",
	1:  "media_name",
	2:  "loop",
	3:  "overlay",
	4:  "stop",
	5:  "target_legs",
	6:  "cache_audio",
	7:  "audio_type",
	8:  "playback_content",
	9:  "client_state",
	10: "command_id",
}

// Decode decodes PlayAudioUrlRequest from json.
func (s *PlayAudioUrlRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayAudioUrlRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "media_name":
			if err := func() error {
				s.MediaName.Reset()
				if err := s.MediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_name\"")
			}
		case "loop":
			if err := func() error {
				s.Loop.Reset()
				if err := s.Loop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loop\"")
			}
		case "overlay":
			if err := func() error {
				s.Overlay.Reset()
				if err := s.Overlay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overlay\"")
			}
		case "stop":
			if err := func() error {
				s.Stop.Reset()
				if err := s.Stop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop\"")
			}
		case "target_legs":
			if err := func() error {
				s.TargetLegs.Reset()
				if err := s.TargetLegs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_legs\"")
			}
		case "cache_audio":
			if err := func() error {
				s.CacheAudio.Reset()
				if err := s.CacheAudio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_audio\"")
			}
		case "audio_type":
			if err := func() error {
				s.AudioType.Reset()
				if err := s.AudioType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_type\"")
			}
		case "playback_content":
			if err := func() error {
				s.PlaybackContent.Reset()
				if err := s.PlaybackContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playback_content\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayAudioUrlRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayAudioUrlRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayAudioUrlRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayAudioUrlRequestAudioType as json.
func (s PlayAudioUrlRequestAudioType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayAudioUrlRequestAudioType from json.
func (s *PlayAudioUrlRequestAudioType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayAudioUrlRequestAudioType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayAudioUrlRequestAudioType(v) {
	case PlayAudioUrlRequestAudioTypeMp3:
		*s = PlayAudioUrlRequestAudioTypeMp3
	case PlayAudioUrlRequestAudioTypeWav:
		*s = PlayAudioUrlRequestAudioTypeWav
	default:
		*s = PlayAudioUrlRequestAudioType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayAudioUrlRequestAudioType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayAudioUrlRequestAudioType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlaybackStopRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlaybackStopRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Overlay.Set {
			e.FieldStart("overlay")
			s.Overlay.Encode(e)
		}
	}
	{
		if s.Stop.Set {
			e.FieldStart("stop")
			s.Stop.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlaybackStopRequest = [4]string{
	0: "overlay",
	1: "stop",
	2: "client_state",
	3: "command_id",
}

// Decode decodes PlaybackStopRequest from json.
func (s *PlaybackStopRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlaybackStopRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "overlay":
			if err := func() error {
				s.Overlay.Reset()
				if err := s.Overlay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overlay\"")
			}
		case "stop":
			if err := func() error {
				s.Stop.Reset()
				if err := s.Stop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlaybackStopRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlaybackStopRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlaybackStopRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueueCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueueCall) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("record_type")
		s.RecordType.Encode(e)
	}
	{
		e.FieldStart("call_session_id")
		e.Str(s.CallSessionID)
	}
	{
		e.FieldStart("call_leg_id")
		e.Str(s.CallLegID)
	}
	{
		e.FieldStart("call_control_id")
		e.Str(s.CallControlID)
	}
	{
		e.FieldStart("connection_id")
		e.Str(s.ConnectionID)
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		e.FieldStart("enqueued_at")
		e.Str(s.EnqueuedAt)
	}
	{
		e.FieldStart("wait_time_secs")
		e.Int(s.WaitTimeSecs)
	}
	{
		e.FieldStart("queue_position")
		e.Int(s.QueuePosition)
	}
	{
		e.FieldStart("queue_id")
		e.Str(s.QueueID)
	}
}

var jsonFieldsNameOfQueueCall = [11]string{
	0:  "record_type",
	1:  "call_session_id",
	2:  "call_leg_id",
	3:  "call_control_id",
	4:  "connection_id",
	5:  "from",
	6:  "to",
	7:  "enqueued_at",
	8:  "wait_time_secs",
	9:  "queue_position",
	10: "queue_id",
}

// Decode decodes QueueCall from json.
func (s *QueueCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueueCall to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "call_session_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CallSessionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_session_id\"")
			}
		case "call_leg_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CallLegID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_leg_id\"")
			}
		case "call_control_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CallControlID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_control_id\"")
			}
		case "connection_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "enqueued_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.EnqueuedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enqueued_at\"")
			}
		case "wait_time_secs":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.WaitTimeSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wait_time_secs\"")
			}
		case "queue_position":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.QueuePosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_position\"")
			}
		case "queue_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.QueueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueueCall")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueueCall) {
					name = jsonFieldsNameOfQueueCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueueCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueueCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueueCallRecordType as json.
func (s QueueCallRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QueueCallRecordType from json.
func (s *QueueCallRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueueCallRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QueueCallRecordType(v) {
	case QueueCallRecordTypeQueueCall:
		*s = QueueCallRecordTypeQueueCall
	default:
		*s = QueueCallRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QueueCallRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueueCallRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueueCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueueCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfQueueCallResponse = [1]string{
	0: "data",
}

// Decode decodes QueueCallResponse from json.
func (s *QueueCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueueCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueueCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueueCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueueCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordType) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.ProductDimensions != nil {
			e.FieldStart("product_dimensions")
			e.ArrStart()
			for _, elem := range s.ProductDimensions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProductMetrics != nil {
			e.FieldStart("product_metrics")
			e.ArrStart()
			for _, elem := range s.ProductMetrics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRecordType = [3]string{
	0: "record_type",
	1: "product_dimensions",
	2: "product_metrics",
}

// Decode decodes RecordType from json.
func (s *RecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "product_dimensions":
			if err := func() error {
				s.ProductDimensions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ProductDimensions = append(s.ProductDimensions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product_dimensions\"")
			}
		case "product_metrics":
			if err := func() error {
				s.ProductMetrics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ProductMetrics = append(s.ProductMetrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product_metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordingResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordingResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecordingResponse = [1]string{
	0: "data",
}

// Decode decodes RecordingResponse from json.
func (s *RecordingResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordingResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordingResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordingResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordingResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.CallControlID.Set {
			e.FieldStart("call_control_id")
			s.CallControlID.Encode(e)
		}
	}
	{
		if s.CallLegID.Set {
			e.FieldStart("call_leg_id")
			s.CallLegID.Encode(e)
		}
	}
	{
		if s.CallSessionID.Set {
			e.FieldStart("call_session_id")
			s.CallSessionID.Encode(e)
		}
	}
	{
		if s.Channels.Set {
			e.FieldStart("channels")
			s.Channels.Encode(e)
		}
	}
	{
		if s.ConferenceID.Set {
			e.FieldStart("conference_id")
			s.ConferenceID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.DownloadUrls.Set {
			e.FieldStart("download_urls")
			s.DownloadUrls.Encode(e)
		}
	}
	{
		if s.DurationMillis.Set {
			e.FieldStart("duration_millis")
			s.DurationMillis.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.RecordingStartedAt.Set {
			e.FieldStart("recording_started_at")
			s.RecordingStartedAt.Encode(e)
		}
	}
	{
		if s.RecordingEndedAt.Set {
			e.FieldStart("recording_ended_at")
			s.RecordingEndedAt.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecordingResponseData = [15]string{
	0:  "call_control_id",
	1:  "call_leg_id",
	2:  "call_session_id",
	3:  "channels",
	4:  "conference_id",
	5:  "created_at",
	6:  "download_urls",
	7:  "duration_millis",
	8:  "id",
	9:  "record_type",
	10: "recording_started_at",
	11: "recording_ended_at",
	12: "source",
	13: "status",
	14: "updated_at",
}

// Decode decodes RecordingResponseData from json.
func (s *RecordingResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "call_control_id":
			if err := func() error {
				s.CallControlID.Reset()
				if err := s.CallControlID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_control_id\"")
			}
		case "call_leg_id":
			if err := func() error {
				s.CallLegID.Reset()
				if err := s.CallLegID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_leg_id\"")
			}
		case "call_session_id":
			if err := func() error {
				s.CallSessionID.Reset()
				if err := s.CallSessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_session_id\"")
			}
		case "channels":
			if err := func() error {
				s.Channels.Reset()
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "conference_id":
			if err := func() error {
				s.ConferenceID.Reset()
				if err := s.ConferenceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "download_urls":
			if err := func() error {
				s.DownloadUrls.Reset()
				if err := s.DownloadUrls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_urls\"")
			}
		case "duration_millis":
			if err := func() error {
				s.DurationMillis.Reset()
				if err := s.DurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_millis\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "recording_started_at":
			if err := func() error {
				s.RecordingStartedAt.Reset()
				if err := s.RecordingStartedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_started_at\"")
			}
		case "recording_ended_at":
			if err := func() error {
				s.RecordingEndedAt.Reset()
				if err := s.RecordingEndedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_ended_at\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordingResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordingResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataChannels as json.
func (s RecordingResponseDataChannels) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordingResponseDataChannels from json.
func (s *RecordingResponseDataChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingResponseDataChannels to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordingResponseDataChannels(v) {
	case RecordingResponseDataChannelsSingle:
		*s = RecordingResponseDataChannelsSingle
	case RecordingResponseDataChannelsDual:
		*s = RecordingResponseDataChannelsDual
	default:
		*s = RecordingResponseDataChannels(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingResponseDataChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingResponseDataChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordingResponseDataDownloadUrls) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordingResponseDataDownloadUrls) encodeFields(e *jx.Encoder) {
	{
		if s.Mp3.Set {
			e.FieldStart("mp3")
			s.Mp3.Encode(e)
		}
	}
	{
		if s.Wav.Set {
			e.FieldStart("wav")
			s.Wav.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecordingResponseDataDownloadUrls = [2]string{
	0: "mp3",
	1: "wav",
}

// Decode decodes RecordingResponseDataDownloadUrls from json.
func (s *RecordingResponseDataDownloadUrls) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingResponseDataDownloadUrls to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mp3":
			if err := func() error {
				s.Mp3.Reset()
				if err := s.Mp3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mp3\"")
			}
		case "wav":
			if err := func() error {
				s.Wav.Reset()
				if err := s.Wav.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wav\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordingResponseDataDownloadUrls")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordingResponseDataDownloadUrls) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingResponseDataDownloadUrls) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataRecordType as json.
func (s RecordingResponseDataRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordingResponseDataRecordType from json.
func (s *RecordingResponseDataRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingResponseDataRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordingResponseDataRecordType(v) {
	case RecordingResponseDataRecordTypeRecording:
		*s = RecordingResponseDataRecordTypeRecording
	default:
		*s = RecordingResponseDataRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingResponseDataRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingResponseDataRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataSource as json.
func (s RecordingResponseDataSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordingResponseDataSource from json.
func (s *RecordingResponseDataSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingResponseDataSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordingResponseDataSource(v) {
	case RecordingResponseDataSourceConference:
		*s = RecordingResponseDataSourceConference
	case RecordingResponseDataSourceCall:
		*s = RecordingResponseDataSourceCall
	default:
		*s = RecordingResponseDataSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingResponseDataSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingResponseDataSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseDataStatus as json.
func (s RecordingResponseDataStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordingResponseDataStatus from json.
func (s *RecordingResponseDataStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingResponseDataStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordingResponseDataStatus(v) {
	case RecordingResponseDataStatusCompleted:
		*s = RecordingResponseDataStatusCompleted
	default:
		*s = RecordingResponseDataStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingResponseDataStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingResponseDataStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingSource as json.
func (s RecordingSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordingSource from json.
func (s *RecordingSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordingSource(v) {
	case RecordingSourceStartCallRecordingAPI:
		*s = RecordingSourceStartCallRecordingAPI
	case RecordingSourceStartConferenceRecordingAPI:
		*s = RecordingSourceStartConferenceRecordingAPI
	case RecordingSourceOutboundAPI:
		*s = RecordingSourceOutboundAPI
	case RecordingSourceDialVerb:
		*s = RecordingSourceDialVerb
	case RecordingSourceConference:
		*s = RecordingSourceConference
	case RecordingSourceRecordVerb:
		*s = RecordingSourceRecordVerb
	case RecordingSourceTrunking:
		*s = RecordingSourceTrunking
	default:
		*s = RecordingSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingTrack as json.
func (s RecordingTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordingTrack from json.
func (s *RecordingTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordingTrack(v) {
	case RecordingTrackInbound:
		*s = RecordingTrackInbound
	case RecordingTrackOutbound:
		*s = RecordingTrackOutbound
	case RecordingTrackBoth:
		*s = RecordingTrackBoth
	default:
		*s = RecordingTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReferRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReferRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sip_address")
		e.Str(s.SipAddress)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.CustomHeaders != nil {
			e.FieldStart("custom_headers")
			e.ArrStart()
			for _, elem := range s.CustomHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SipAuthUsername.Set {
			e.FieldStart("sip_auth_username")
			s.SipAuthUsername.Encode(e)
		}
	}
	{
		if s.SipAuthPassword.Set {
			e.FieldStart("sip_auth_password")
			s.SipAuthPassword.Encode(e)
		}
	}
	{
		if s.SipHeaders != nil {
			e.FieldStart("sip_headers")
			e.ArrStart()
			for _, elem := range s.SipHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReferRequest = [7]string{
	0: "sip_address",
	1: "client_state",
	2: "command_id",
	3: "custom_headers",
	4: "sip_auth_username",
	5: "sip_auth_password",
	6: "sip_headers",
}

// Decode decodes ReferRequest from json.
func (s *ReferRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReferRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sip_address":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SipAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_address\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "custom_headers":
			if err := func() error {
				s.CustomHeaders = make([]CustomSipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomSipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomHeaders = append(s.CustomHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_headers\"")
			}
		case "sip_auth_username":
			if err := func() error {
				s.SipAuthUsername.Reset()
				if err := s.SipAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_username\"")
			}
		case "sip_auth_password":
			if err := func() error {
				s.SipAuthPassword.Reset()
				if err := s.SipAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_password\"")
			}
		case "sip_headers":
			if err := func() error {
				s.SipHeaders = make([]SipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SipHeaders = append(s.SipHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_headers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReferRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReferRequest) {
					name = jsonFieldsNameOfReferRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReferRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReferRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Region as json.
func (s Region) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Region from json.
func (s *Region) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Region to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Region(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Region) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Region) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterCallRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
}

var jsonFieldsNameOfRegisterCallRequest = [3]string{
	0: "from",
	1: "to",
	2: "reason",
}

// Decode decodes RegisterCallRequest from json.
func (s *RegisterCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterCallRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterCallRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterCallRequest) {
					name = jsonFieldsNameOfRegisterCallRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegisterCallResponse = [1]string{
	0: "data",
}

// Decode decodes RegisterCallResponse from json.
func (s *RegisterCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterCallResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterCallResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegisterCallResponseData = [1]string{
	0: "result",
}

// Decode decodes RegisterCallResponseData from json.
func (s *RegisterCallResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterCallResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterCallResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterCallResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterCallResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RejectRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RejectRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		e.FieldStart("cause")
		s.Cause.Encode(e)
	}
}

var jsonFieldsNameOfRejectRequest = [3]string{
	0: "client_state",
	1: "command_id",
	2: "cause",
}

// Decode decodes RejectRequest from json.
func (s *RejectRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RejectRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "cause":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Cause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cause\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RejectRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRejectRequest) {
					name = jsonFieldsNameOfRejectRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RejectRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RejectRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RejectRequestCause as json.
func (s RejectRequestCause) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RejectRequestCause from json.
func (s *RejectRequestCause) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RejectRequestCause to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RejectRequestCause(v) {
	case RejectRequestCauseCALLREJECTED:
		*s = RejectRequestCauseCALLREJECTED
	case RejectRequestCauseUSERBUSY:
		*s = RejectRequestCauseUSERBUSY
	default:
		*s = RejectRequestCause(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RejectRequestCause) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RejectRequestCause) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResumeRecordingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResumeRecordingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfResumeRecordingRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes ResumeRecordingRequest from json.
func (s *ResumeRecordingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResumeRecordingRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResumeRecordingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResumeRecordingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResumeRecordingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RetrieveCallStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RetrieveCallStatusResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfRetrieveCallStatusResponse = [1]string{
	0: "data",
}

// Decode decodes RetrieveCallStatusResponse from json.
func (s *RetrieveCallStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveCallStatusResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RetrieveCallStatusResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveCallStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveCallStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RetrieveVerificationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RetrieveVerificationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfRetrieveVerificationResponse = [1]string{
	0: "data",
}

// Decode decodes RetrieveVerificationResponse from json.
func (s *RetrieveVerificationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveVerificationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RetrieveVerificationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRetrieveVerificationResponse) {
					name = jsonFieldsNameOfRetrieveVerificationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveVerificationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveVerificationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RoomRecording) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RoomRecording) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.RoomID.Set {
			e.FieldStart("room_id")
			s.RoomID.Encode(e)
		}
	}
	{
		if s.SessionID.Set {
			e.FieldStart("session_id")
			s.SessionID.Encode(e)
		}
	}
	{
		if s.ParticipantID.Set {
			e.FieldStart("participant_id")
			s.ParticipantID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.SizeMB.Set {
			e.FieldStart("size_mb")
			s.SizeMB.Encode(e)
		}
	}
	{
		if s.DownloadURL.Set {
			e.FieldStart("download_url")
			s.DownloadURL.Encode(e)
		}
	}
	{
		if s.Codec.Set {
			e.FieldStart("codec")
			s.Codec.Encode(e)
		}
	}
	{
		if s.DurationSecs.Set {
			e.FieldStart("duration_secs")
			s.DurationSecs.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.EndedAt.Set {
			e.FieldStart("ended_at")
			s.EndedAt.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e)
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
}

var jsonFieldsNameOfRoomRecording = [16]string{
	0:  "id",
	1:  "room_id",
	2:  "session_id",
	3:  "participant_id",
	4:  "status",
	5:  "type",
	6:  "size_mb",
	7:  "download_url",
	8:  "codec",
	9:  "duration_secs",
	10: "created_at",
	11: "updated_at",
	12: "ended_at",
	13: "started_at",
	14: "completed_at",
	15: "record_type",
}

// Decode decodes RoomRecording from json.
func (s *RoomRecording) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoomRecording to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "room_id":
			if err := func() error {
				s.RoomID.Reset()
				if err := s.RoomID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"room_id\"")
			}
		case "session_id":
			if err := func() error {
				s.SessionID.Reset()
				if err := s.SessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_id\"")
			}
		case "participant_id":
			if err := func() error {
				s.ParticipantID.Reset()
				if err := s.ParticipantID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participant_id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "size_mb":
			if err := func() error {
				s.SizeMB.Reset()
				if err := s.SizeMB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size_mb\"")
			}
		case "download_url":
			if err := func() error {
				s.DownloadURL.Reset()
				if err := s.DownloadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "codec":
			if err := func() error {
				s.Codec.Reset()
				if err := s.Codec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"codec\"")
			}
		case "duration_secs":
			if err := func() error {
				s.DurationSecs.Reset()
				if err := s.DurationSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_secs\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "ended_at":
			if err := func() error {
				s.EndedAt.Reset()
				if err := s.EndedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ended_at\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RoomRecording")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RoomRecording) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoomRecording) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoomRecordingStatus as json.
func (s RoomRecordingStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RoomRecordingStatus from json.
func (s *RoomRecordingStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoomRecordingStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RoomRecordingStatus(v) {
	case RoomRecordingStatusCompleted:
		*s = RoomRecordingStatusCompleted
	case RoomRecordingStatusProcessing:
		*s = RoomRecordingStatusProcessing
	default:
		*s = RoomRecordingStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RoomRecordingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoomRecordingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoomRecordingType as json.
func (s RoomRecordingType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RoomRecordingType from json.
func (s *RoomRecordingType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoomRecordingType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RoomRecordingType(v) {
	case RoomRecordingTypeAudio:
		*s = RoomRecordingTypeAudio
	case RoomRecordingTypeVideo:
		*s = RoomRecordingTypeVideo
	default:
		*s = RoomRecordingType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RoomRecordingType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoomRecordingType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *S3ConfigurationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *S3ConfigurationData) encodeFields(e *jx.Encoder) {
	{
		if s.Bucket.Set {
			e.FieldStart("bucket")
			s.Bucket.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.AWSAccessKeyID.Set {
			e.FieldStart("aws_access_key_id")
			s.AWSAccessKeyID.Encode(e)
		}
	}
	{
		if s.AWSSecretAccessKey.Set {
			e.FieldStart("aws_secret_access_key")
			s.AWSSecretAccessKey.Encode(e)
		}
	}
}

var jsonFieldsNameOfS3ConfigurationData = [4]string{
	0: "bucket",
	1: "region",
	2: "aws_access_key_id",
	3: "aws_secret_access_key",
}

// Decode decodes S3ConfigurationData from json.
func (s *S3ConfigurationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode S3ConfigurationData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bucket":
			if err := func() error {
				s.Bucket.Reset()
				if err := s.Bucket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucket\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "aws_access_key_id":
			if err := func() error {
				s.AWSAccessKeyID.Reset()
				if err := s.AWSAccessKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aws_access_key_id\"")
			}
		case "aws_secret_access_key":
			if err := func() error {
				s.AWSSecretAccessKey.Reset()
				if err := s.AWSSecretAccessKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aws_secret_access_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode S3ConfigurationData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *S3ConfigurationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *S3ConfigurationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendDTMFRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendDTMFRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("digits")
		e.Str(s.Digits)
	}
	{
		if s.DurationMillis.Set {
			e.FieldStart("duration_millis")
			s.DurationMillis.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendDTMFRequest = [4]string{
	0: "digits",
	1: "duration_millis",
	2: "client_state",
	3: "command_id",
}

// Decode decodes SendDTMFRequest from json.
func (s *SendDTMFRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendDTMFRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "digits":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Digits = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"digits\"")
			}
		case "duration_millis":
			if err := func() error {
				s.DurationMillis.Reset()
				if err := s.DurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_millis\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendDTMFRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendDTMFRequest) {
					name = jsonFieldsNameOfSendDTMFRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendDTMFRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendDTMFRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SipHeader) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SipHeader) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSipHeader = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes SipHeader from json.
func (s *SipHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SipHeader to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SipHeader")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSipHeader) {
					name = jsonFieldsNameOfSipHeader[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SipHeader) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SipHeader) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SipHeaderName as json.
func (s SipHeaderName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SipHeaderName from json.
func (s *SipHeaderName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SipHeaderName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SipHeaderName(v) {
	case SipHeaderNameUserToUser:
		*s = SipHeaderNameUserToUser
	default:
		*s = SipHeaderName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SipHeaderName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SipHeaderName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SoundModifications) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SoundModifications) encodeFields(e *jx.Encoder) {
	{
		if s.Pitch.Set {
			e.FieldStart("pitch")
			s.Pitch.Encode(e)
		}
	}
	{
		if s.Semitone.Set {
			e.FieldStart("semitone")
			s.Semitone.Encode(e)
		}
	}
	{
		if s.Octaves.Set {
			e.FieldStart("octaves")
			s.Octaves.Encode(e)
		}
	}
	{
		if s.Track.Set {
			e.FieldStart("track")
			s.Track.Encode(e)
		}
	}
}

var jsonFieldsNameOfSoundModifications = [4]string{
	0: "pitch",
	1: "semitone",
	2: "octaves",
	3: "track",
}

// Decode decodes SoundModifications from json.
func (s *SoundModifications) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SoundModifications to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pitch":
			if err := func() error {
				s.Pitch.Reset()
				if err := s.Pitch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pitch\"")
			}
		case "semitone":
			if err := func() error {
				s.Semitone.Reset()
				if err := s.Semitone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"semitone\"")
			}
		case "octaves":
			if err := func() error {
				s.Octaves.Reset()
				if err := s.Octaves.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"octaves\"")
			}
		case "track":
			if err := func() error {
				s.Track.Reset()
				if err := s.Track.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"track\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SoundModifications")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SoundModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SoundModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SourceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SourceResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Pointer.Set {
			e.FieldStart("pointer")
			s.Pointer.Encode(e)
		}
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfSourceResponse = [2]string{
	0: "pointer",
	1: "parameter",
}

// Decode decodes SourceResponse from json.
func (s *SourceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SourceResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pointer":
			if err := func() error {
				s.Pointer.Reset()
				if err := s.Pointer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pointer\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SourceResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SourceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SourceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		if s.PayloadType.Set {
			e.FieldStart("payload_type")
			s.PayloadType.Encode(e)
		}
	}
	{
		if s.ServiceLevel.Set {
			e.FieldStart("service_level")
			s.ServiceLevel.Encode(e)
		}
	}
	{
		if s.Stop.Set {
			e.FieldStart("stop")
			s.Stop.Encode(e)
		}
	}
	{
		e.FieldStart("voice")
		s.Voice.Encode(e)
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpeakRequest = [8]string{
	0: "payload",
	1: "payload_type",
	2: "service_level",
	3: "stop",
	4: "voice",
	5: "language",
	6: "client_state",
	7: "command_id",
}

// Decode decodes SpeakRequest from json.
func (s *SpeakRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "payload":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "payload_type":
			if err := func() error {
				s.PayloadType.Reset()
				if err := s.PayloadType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload_type\"")
			}
		case "service_level":
			if err := func() error {
				s.ServiceLevel.Reset()
				if err := s.ServiceLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_level\"")
			}
		case "stop":
			if err := func() error {
				s.Stop.Reset()
				if err := s.Stop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop\"")
			}
		case "voice":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Voice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakRequest) {
					name = jsonFieldsNameOfSpeakRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestLanguage as json.
func (s SpeakRequestLanguage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakRequestLanguage from json.
func (s *SpeakRequestLanguage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequestLanguage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakRequestLanguage(v) {
	case SpeakRequestLanguageArb:
		*s = SpeakRequestLanguageArb
	case SpeakRequestLanguageCmnCN:
		*s = SpeakRequestLanguageCmnCN
	case SpeakRequestLanguageCyGB:
		*s = SpeakRequestLanguageCyGB
	case SpeakRequestLanguageDaDK:
		*s = SpeakRequestLanguageDaDK
	case SpeakRequestLanguageDeDE:
		*s = SpeakRequestLanguageDeDE
	case SpeakRequestLanguageEnAU:
		*s = SpeakRequestLanguageEnAU
	case SpeakRequestLanguageEnGB:
		*s = SpeakRequestLanguageEnGB
	case SpeakRequestLanguageEnGBWLS:
		*s = SpeakRequestLanguageEnGBWLS
	case SpeakRequestLanguageEnIN:
		*s = SpeakRequestLanguageEnIN
	case SpeakRequestLanguageEnUS:
		*s = SpeakRequestLanguageEnUS
	case SpeakRequestLanguageEsES:
		*s = SpeakRequestLanguageEsES
	case SpeakRequestLanguageEsMX:
		*s = SpeakRequestLanguageEsMX
	case SpeakRequestLanguageEsUS:
		*s = SpeakRequestLanguageEsUS
	case SpeakRequestLanguageFrCA:
		*s = SpeakRequestLanguageFrCA
	case SpeakRequestLanguageFrFR:
		*s = SpeakRequestLanguageFrFR
	case SpeakRequestLanguageHiIN:
		*s = SpeakRequestLanguageHiIN
	case SpeakRequestLanguageIsIS:
		*s = SpeakRequestLanguageIsIS
	case SpeakRequestLanguageItIT:
		*s = SpeakRequestLanguageItIT
	case SpeakRequestLanguageJaJP:
		*s = SpeakRequestLanguageJaJP
	case SpeakRequestLanguageKoKR:
		*s = SpeakRequestLanguageKoKR
	case SpeakRequestLanguageNbNO:
		*s = SpeakRequestLanguageNbNO
	case SpeakRequestLanguageNlNL:
		*s = SpeakRequestLanguageNlNL
	case SpeakRequestLanguagePlPL:
		*s = SpeakRequestLanguagePlPL
	case SpeakRequestLanguagePtBR:
		*s = SpeakRequestLanguagePtBR
	case SpeakRequestLanguagePtPT:
		*s = SpeakRequestLanguagePtPT
	case SpeakRequestLanguageRoRO:
		*s = SpeakRequestLanguageRoRO
	case SpeakRequestLanguageRuRU:
		*s = SpeakRequestLanguageRuRU
	case SpeakRequestLanguageSvSE:
		*s = SpeakRequestLanguageSvSE
	case SpeakRequestLanguageTrTR:
		*s = SpeakRequestLanguageTrTR
	default:
		*s = SpeakRequestLanguage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestPayloadType as json.
func (s SpeakRequestPayloadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakRequestPayloadType from json.
func (s *SpeakRequestPayloadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequestPayloadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakRequestPayloadType(v) {
	case SpeakRequestPayloadTypeText:
		*s = SpeakRequestPayloadTypeText
	case SpeakRequestPayloadTypeSsml:
		*s = SpeakRequestPayloadTypeSsml
	default:
		*s = SpeakRequestPayloadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakRequestPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequestPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestServiceLevel as json.
func (s SpeakRequestServiceLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakRequestServiceLevel from json.
func (s *SpeakRequestServiceLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequestServiceLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakRequestServiceLevel(v) {
	case SpeakRequestServiceLevelBasic:
		*s = SpeakRequestServiceLevelBasic
	case SpeakRequestServiceLevelPremium:
		*s = SpeakRequestServiceLevelPremium
	default:
		*s = SpeakRequestServiceLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakRequestServiceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequestServiceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestVoice as json.
func (s SpeakRequestVoice) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakRequestVoice from json.
func (s *SpeakRequestVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequestVoice to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakRequestVoice(v) {
	case SpeakRequestVoiceMale:
		*s = SpeakRequestVoiceMale
	case SpeakRequestVoiceFemale:
		*s = SpeakRequestVoiceFemale
	default:
		*s = SpeakRequestVoice(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakRequestVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequestVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartForkingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartForkingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Target.Set {
			e.FieldStart("target")
			s.Target.Encode(e)
		}
	}
	{
		if s.Rx.Set {
			e.FieldStart("rx")
			s.Rx.Encode(e)
		}
	}
	{
		if s.StreamType.Set {
			e.FieldStart("stream_type")
			s.StreamType.Encode(e)
		}
	}
	{
		if s.Tx.Set {
			e.FieldStart("tx")
			s.Tx.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartForkingRequest = [6]string{
	0: "target",
	1: "rx",
	2: "stream_type",
	3: "tx",
	4: "client_state",
	5: "command_id",
}

// Decode decodes StartForkingRequest from json.
func (s *StartForkingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartForkingRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target":
			if err := func() error {
				s.Target.Reset()
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "rx":
			if err := func() error {
				s.Rx.Reset()
				if err := s.Rx.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rx\"")
			}
		case "stream_type":
			if err := func() error {
				s.StreamType.Reset()
				if err := s.StreamType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_type\"")
			}
		case "tx":
			if err := func() error {
				s.Tx.Reset()
				if err := s.Tx.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tx\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartForkingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartForkingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartForkingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartForkingRequestStreamType as json.
func (s StartForkingRequestStreamType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartForkingRequestStreamType from json.
func (s *StartForkingRequestStreamType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartForkingRequestStreamType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartForkingRequestStreamType(v) {
	case StartForkingRequestStreamTypeRaw:
		*s = StartForkingRequestStreamTypeRaw
	case StartForkingRequestStreamTypeDecrypted:
		*s = StartForkingRequestStreamTypeDecrypted
	default:
		*s = StartForkingRequestStreamType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartForkingRequestStreamType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartForkingRequestStreamType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartRecordingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartRecordingRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		e.FieldStart("channels")
		s.Channels.Encode(e)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.PlayBeep.Set {
			e.FieldStart("play_beep")
			s.PlayBeep.Encode(e)
		}
	}
	{
		if s.MaxLength.Set {
			e.FieldStart("max_length")
			s.MaxLength.Encode(e)
		}
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
	{
		if s.RecordingTrack.Set {
			e.FieldStart("recording_track")
			s.RecordingTrack.Encode(e)
		}
	}
	{
		if s.Trim.Set {
			e.FieldStart("trim")
			s.Trim.Encode(e)
		}
	}
	{
		if s.CustomFileName.Set {
			e.FieldStart("custom_file_name")
			s.CustomFileName.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartRecordingRequest = [10]string{
	0: "format",
	1: "channels",
	2: "client_state",
	3: "command_id",
	4: "play_beep",
	5: "max_length",
	6: "timeout_secs",
	7: "recording_track",
	8: "trim",
	9: "custom_file_name",
}

// Decode decodes StartRecordingRequest from json.
func (s *StartRecordingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "channels":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "play_beep":
			if err := func() error {
				s.PlayBeep.Reset()
				if err := s.PlayBeep.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"play_beep\"")
			}
		case "max_length":
			if err := func() error {
				s.MaxLength.Reset()
				if err := s.MaxLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_length\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		case "recording_track":
			if err := func() error {
				s.RecordingTrack.Reset()
				if err := s.RecordingTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_track\"")
			}
		case "trim":
			if err := func() error {
				s.Trim.Reset()
				if err := s.Trim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trim\"")
			}
		case "custom_file_name":
			if err := func() error {
				s.CustomFileName.Reset()
				if err := s.CustomFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_file_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartRecordingRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartRecordingRequest) {
					name = jsonFieldsNameOfStartRecordingRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartRecordingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestChannels as json.
func (s StartRecordingRequestChannels) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartRecordingRequestChannels from json.
func (s *StartRecordingRequestChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequestChannels to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartRecordingRequestChannels(v) {
	case StartRecordingRequestChannelsSingle:
		*s = StartRecordingRequestChannelsSingle
	case StartRecordingRequestChannelsDual:
		*s = StartRecordingRequestChannelsDual
	default:
		*s = StartRecordingRequestChannels(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartRecordingRequestChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequestChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestFormat as json.
func (s StartRecordingRequestFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartRecordingRequestFormat from json.
func (s *StartRecordingRequestFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequestFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartRecordingRequestFormat(v) {
	case StartRecordingRequestFormatWav:
		*s = StartRecordingRequestFormatWav
	case StartRecordingRequestFormatMp3:
		*s = StartRecordingRequestFormatMp3
	default:
		*s = StartRecordingRequestFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartRecordingRequestFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequestFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestRecordingTrack as json.
func (s StartRecordingRequestRecordingTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartRecordingRequestRecordingTrack from json.
func (s *StartRecordingRequestRecordingTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequestRecordingTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartRecordingRequestRecordingTrack(v) {
	case StartRecordingRequestRecordingTrackBoth:
		*s = StartRecordingRequestRecordingTrackBoth
	case StartRecordingRequestRecordingTrackInbound:
		*s = StartRecordingRequestRecordingTrackInbound
	case StartRecordingRequestRecordingTrackOutbound:
		*s = StartRecordingRequestRecordingTrackOutbound
	default:
		*s = StartRecordingRequestRecordingTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartRecordingRequestRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequestRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestTrim as json.
func (s StartRecordingRequestTrim) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartRecordingRequestTrim from json.
func (s *StartRecordingRequestTrim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequestTrim to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartRecordingRequestTrim(v) {
	case StartRecordingRequestTrimTrimSilence:
		*s = StartRecordingRequestTrimTrimSilence
	default:
		*s = StartRecordingRequestTrim(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartRecordingRequestTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequestTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartStreamingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartStreamingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.StreamURL.Set {
			e.FieldStart("stream_url")
			s.StreamURL.Encode(e)
		}
	}
	{
		if s.StreamTrack.Set {
			e.FieldStart("stream_track")
			s.StreamTrack.Encode(e)
		}
	}
	{
		if s.EnableDialogflow.Set {
			e.FieldStart("enable_dialogflow")
			s.EnableDialogflow.Encode(e)
		}
	}
	{
		if s.DialogflowConfig.Set {
			e.FieldStart("dialogflow_config")
			s.DialogflowConfig.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartStreamingRequest = [6]string{
	0: "stream_url",
	1: "stream_track",
	2: "enable_dialogflow",
	3: "dialogflow_config",
	4: "client_state",
	5: "command_id",
}

// Decode decodes StartStreamingRequest from json.
func (s *StartStreamingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartStreamingRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stream_url":
			if err := func() error {
				s.StreamURL.Reset()
				if err := s.StreamURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_url\"")
			}
		case "stream_track":
			if err := func() error {
				s.StreamTrack.Reset()
				if err := s.StreamTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_track\"")
			}
		case "enable_dialogflow":
			if err := func() error {
				s.EnableDialogflow.Reset()
				if err := s.EnableDialogflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_dialogflow\"")
			}
		case "dialogflow_config":
			if err := func() error {
				s.DialogflowConfig.Reset()
				if err := s.DialogflowConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogflow_config\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartStreamingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartStreamingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartStreamingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartStreamingRequestStreamTrack as json.
func (s StartStreamingRequestStreamTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartStreamingRequestStreamTrack from json.
func (s *StartStreamingRequestStreamTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartStreamingRequestStreamTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartStreamingRequestStreamTrack(v) {
	case StartStreamingRequestStreamTrackInboundTrack:
		*s = StartStreamingRequestStreamTrackInboundTrack
	case StartStreamingRequestStreamTrackOutboundTrack:
		*s = StartStreamingRequestStreamTrackOutboundTrack
	case StartStreamingRequestStreamTrackBothTracks:
		*s = StartStreamingRequestStreamTrackBothTracks
	default:
		*s = StartStreamingRequestStreamTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartStreamingRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartStreamingRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopForkingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopForkingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.StreamType.Set {
			e.FieldStart("stream_type")
			s.StreamType.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopForkingRequest = [3]string{
	0: "client_state",
	1: "command_id",
	2: "stream_type",
}

// Decode decodes StopForkingRequest from json.
func (s *StopForkingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopForkingRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "stream_type":
			if err := func() error {
				s.StreamType.Reset()
				if err := s.StreamType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopForkingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopForkingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopForkingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StopForkingRequestStreamType as json.
func (s StopForkingRequestStreamType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StopForkingRequestStreamType from json.
func (s *StopForkingRequestStreamType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopForkingRequestStreamType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StopForkingRequestStreamType(v) {
	case StopForkingRequestStreamTypeRaw:
		*s = StopForkingRequestStreamTypeRaw
	case StopForkingRequestStreamTypeDecrypted:
		*s = StopForkingRequestStreamTypeDecrypted
	default:
		*s = StopForkingRequestStreamType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StopForkingRequestStreamType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopForkingRequestStreamType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopGatherRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopGatherRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopGatherRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes StopGatherRequest from json.
func (s *StopGatherRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopGatherRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopGatherRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopGatherRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopGatherRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopRecordingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopRecordingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopRecordingRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes StopRecordingRequest from json.
func (s *StopRecordingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopRecordingRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopRecordingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopRecordingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopRecordingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopStreamingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopStreamingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopStreamingRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes StopStreamingRequest from json.
func (s *StopStreamingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopStreamingRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopStreamingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopStreamingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopStreamingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelephonyCredential) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelephonyCredential) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ResourceID.Set {
			e.FieldStart("resource_id")
			s.ResourceID.Encode(e)
		}
	}
	{
		if s.Expired.Set {
			e.FieldStart("expired")
			s.Expired.Encode(e)
		}
	}
	{
		if s.SipUsername.Set {
			e.FieldStart("sip_username")
			s.SipUsername.Encode(e)
		}
	}
	{
		if s.SipPassword.Set {
			e.FieldStart("sip_password")
			s.SipPassword.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfTelephonyCredential = [10]string{
	0: "id",
	1: "record_type",
	2: "name",
	3: "resource_id",
	4: "expired",
	5: "sip_username",
	6: "sip_password",
	7: "created_at",
	8: "updated_at",
	9: "expires_at",
}

// Decode decodes TelephonyCredential from json.
func (s *TelephonyCredential) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelephonyCredential to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "resource_id":
			if err := func() error {
				s.ResourceID.Reset()
				if err := s.ResourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_id\"")
			}
		case "expired":
			if err := func() error {
				s.Expired.Reset()
				if err := s.Expired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired\"")
			}
		case "sip_username":
			if err := func() error {
				s.SipUsername.Reset()
				if err := s.SipUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_username\"")
			}
		case "sip_password":
			if err := func() error {
				s.SipPassword.Reset()
				if err := s.SipPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_password\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelephonyCredential")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelephonyCredential) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelephonyCredential) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelephonyCredentialCreateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelephonyCredentialCreateRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		e.FieldStart("connection_id")
		e.Str(s.ConnectionID)
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfTelephonyCredentialCreateRequest = [4]string{
	0: "name",
	1: "tag",
	2: "connection_id",
	3: "expires_at",
}

// Decode decodes TelephonyCredentialCreateRequest from json.
func (s *TelephonyCredentialCreateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelephonyCredentialCreateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "connection_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_id\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelephonyCredentialCreateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTelephonyCredentialCreateRequest) {
					name = jsonFieldsNameOfTelephonyCredentialCreateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelephonyCredentialCreateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelephonyCredentialCreateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelephonyCredentialResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelephonyCredentialResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfTelephonyCredentialResponse = [1]string{
	0: "data",
}

// Decode decodes TelephonyCredentialResponse from json.
func (s *TelephonyCredentialResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelephonyCredentialResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelephonyCredentialResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelephonyCredentialResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelephonyCredentialResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelephonyCredentialUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelephonyCredentialUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.ConnectionID.Set {
			e.FieldStart("connection_id")
			s.ConnectionID.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfTelephonyCredentialUpdateRequest = [4]string{
	0: "name",
	1: "tag",
	2: "connection_id",
	3: "expires_at",
}

// Decode decodes TelephonyCredentialUpdateRequest from json.
func (s *TelephonyCredentialUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelephonyCredentialUpdateRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "connection_id":
			if err := func() error {
				s.ConnectionID.Reset()
				if err := s.ConnectionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_id\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelephonyCredentialUpdateRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelephonyCredentialUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelephonyCredentialUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlApplication) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlApplication) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.FriendlyName.Set {
			e.FieldStart("friendly_name")
			s.FriendlyName.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.AnchorsiteOverride.Set {
			e.FieldStart("anchorsite_override")
			s.AnchorsiteOverride.Encode(e)
		}
	}
	{
		if s.DtmfType.Set {
			e.FieldStart("dtmf_type")
			s.DtmfType.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeout.Set {
			e.FieldStart("first_command_timeout")
			s.FirstCommandTimeout.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeoutSecs.Set {
			e.FieldStart("first_command_timeout_secs")
			s.FirstCommandTimeoutSecs.Encode(e)
		}
	}
	{
		if s.VoiceURL.Set {
			e.FieldStart("voice_url")
			s.VoiceURL.Encode(e)
		}
	}
	{
		if s.VoiceFallbackURL.Set {
			e.FieldStart("voice_fallback_url")
			s.VoiceFallbackURL.Encode(e)
		}
	}
	{
		if s.VoiceMethod.Set {
			e.FieldStart("voice_method")
			s.VoiceMethod.Encode(e)
		}
	}
	{
		if s.StatusCallback.Set {
			e.FieldStart("status_callback")
			s.StatusCallback.Encode(e)
		}
	}
	{
		if s.StatusCallbackMethod.Set {
			e.FieldStart("status_callback_method")
			s.StatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlApplication = [17]string{
	0:  "id",
	1:  "record_type",
	2:  "friendly_name",
	3:  "active",
	4:  "anchorsite_override",
	5:  "dtmf_type",
	6:  "first_command_timeout",
	7:  "first_command_timeout_secs",
	8:  "voice_url",
	9:  "voice_fallback_url",
	10: "voice_method",
	11: "status_callback",
	12: "status_callback_method",
	13: "inbound",
	14: "outbound",
	15: "created_at",
	16: "updated_at",
}

// Decode decodes TexmlApplication from json.
func (s *TexmlApplication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlApplication to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "friendly_name":
			if err := func() error {
				s.FriendlyName.Reset()
				if err := s.FriendlyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friendly_name\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "anchorsite_override":
			if err := func() error {
				s.AnchorsiteOverride.Reset()
				if err := s.AnchorsiteOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anchorsite_override\"")
			}
		case "dtmf_type":
			if err := func() error {
				s.DtmfType.Reset()
				if err := s.DtmfType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtmf_type\"")
			}
		case "first_command_timeout":
			if err := func() error {
				s.FirstCommandTimeout.Reset()
				if err := s.FirstCommandTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout\"")
			}
		case "first_command_timeout_secs":
			if err := func() error {
				s.FirstCommandTimeoutSecs.Reset()
				if err := s.FirstCommandTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout_secs\"")
			}
		case "voice_url":
			if err := func() error {
				s.VoiceURL.Reset()
				if err := s.VoiceURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_url\"")
			}
		case "voice_fallback_url":
			if err := func() error {
				s.VoiceFallbackURL.Reset()
				if err := s.VoiceFallbackURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_fallback_url\"")
			}
		case "voice_method":
			if err := func() error {
				s.VoiceMethod.Reset()
				if err := s.VoiceMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_method\"")
			}
		case "status_callback":
			if err := func() error {
				s.StatusCallback.Reset()
				if err := s.StatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_callback\"")
			}
		case "status_callback_method":
			if err := func() error {
				s.StatusCallbackMethod.Reset()
				if err := s.StatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_callback_method\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlApplication")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlApplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlApplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlApplicationInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlApplicationInbound) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelLimit.Set {
			e.FieldStart("channel_limit")
			s.ChannelLimit.Encode(e)
		}
	}
	{
		if s.ShakenStirEnabled.Set {
			e.FieldStart("shaken_stir_enabled")
			s.ShakenStirEnabled.Encode(e)
		}
	}
	{
		if s.SipSubdomain.Set {
			e.FieldStart("sip_subdomain")
			s.SipSubdomain.Encode(e)
		}
	}
	{
		if s.SipSubdomainReceiveSettings.Set {
			e.FieldStart("sip_subdomain_receive_settings")
			s.SipSubdomainReceiveSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlApplicationInbound = [4]string{
	0: "channel_limit",
	1: "shaken_stir_enabled",
	2: "sip_subdomain",
	3: "sip_subdomain_receive_settings",
}

// Decode decodes TexmlApplicationInbound from json.
func (s *TexmlApplicationInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlApplicationInbound to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_limit":
			if err := func() error {
				s.ChannelLimit.Reset()
				if err := s.ChannelLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_limit\"")
			}
		case "shaken_stir_enabled":
			if err := func() error {
				s.ShakenStirEnabled.Reset()
				if err := s.ShakenStirEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shaken_stir_enabled\"")
			}
		case "sip_subdomain":
			if err := func() error {
				s.SipSubdomain.Reset()
				if err := s.SipSubdomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_subdomain\"")
			}
		case "sip_subdomain_receive_settings":
			if err := func() error {
				s.SipSubdomainReceiveSettings.Reset()
				if err := s.SipSubdomainReceiveSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_subdomain_receive_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlApplicationInbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlApplicationInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlApplicationInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplicationInboundSipSubdomainReceiveSettings as json.
func (s TexmlApplicationInboundSipSubdomainReceiveSettings) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TexmlApplicationInboundSipSubdomainReceiveSettings from json.
func (s *TexmlApplicationInboundSipSubdomainReceiveSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlApplicationInboundSipSubdomainReceiveSettings to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TexmlApplicationInboundSipSubdomainReceiveSettings(v) {
	case TexmlApplicationInboundSipSubdomainReceiveSettingsOnlyMyConnections:
		*s = TexmlApplicationInboundSipSubdomainReceiveSettingsOnlyMyConnections
	case TexmlApplicationInboundSipSubdomainReceiveSettingsFromAnyone:
		*s = TexmlApplicationInboundSipSubdomainReceiveSettingsFromAnyone
	default:
		*s = TexmlApplicationInboundSipSubdomainReceiveSettings(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlApplicationInboundSipSubdomainReceiveSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlApplicationInboundSipSubdomainReceiveSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlApplicationOutbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlApplicationOutbound) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelLimit.Set {
			e.FieldStart("channel_limit")
			s.ChannelLimit.Encode(e)
		}
	}
	{
		if s.OutboundVoiceProfileID.Set {
			e.FieldStart("outbound_voice_profile_id")
			s.OutboundVoiceProfileID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlApplicationOutbound = [2]string{
	0: "channel_limit",
	1: "outbound_voice_profile_id",
}

// Decode decodes TexmlApplicationOutbound from json.
func (s *TexmlApplicationOutbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlApplicationOutbound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_limit":
			if err := func() error {
				s.ChannelLimit.Reset()
				if err := s.ChannelLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_limit\"")
			}
		case "outbound_voice_profile_id":
			if err := func() error {
				s.OutboundVoiceProfileID.Reset()
				if err := s.OutboundVoiceProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound_voice_profile_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlApplicationOutbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlApplicationOutbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlApplicationOutbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlApplicationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlApplicationResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlApplicationResponse = [1]string{
	0: "data",
}

// Decode decodes TexmlApplicationResponse from json.
func (s *TexmlApplicationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlApplicationResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlApplicationResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlApplicationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlApplicationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplicationStatusCallbackMethod as json.
func (s TexmlApplicationStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TexmlApplicationStatusCallbackMethod from json.
func (s *TexmlApplicationStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlApplicationStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TexmlApplicationStatusCallbackMethod(v) {
	case TexmlApplicationStatusCallbackMethodGet:
		*s = TexmlApplicationStatusCallbackMethodGet
	case TexmlApplicationStatusCallbackMethodPost:
		*s = TexmlApplicationStatusCallbackMethodPost
	default:
		*s = TexmlApplicationStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlApplicationStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlApplicationStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlApplicationVoiceMethod as json.
func (s TexmlApplicationVoiceMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TexmlApplicationVoiceMethod from json.
func (s *TexmlApplicationVoiceMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlApplicationVoiceMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TexmlApplicationVoiceMethod(v) {
	case TexmlApplicationVoiceMethodGet:
		*s = TexmlApplicationVoiceMethodGet
	case TexmlApplicationVoiceMethodPost:
		*s = TexmlApplicationVoiceMethodPost
	default:
		*s = TexmlApplicationVoiceMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlApplicationVoiceMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlApplicationVoiceMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlCreateCallRecordingResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlCreateCallRecordingResponseBody) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.ConferenceSid.Set {
			e.FieldStart("conference_sid")
			s.ConferenceSid.Encode(e)
		}
	}
	{
		if s.Channels.Set {
			e.FieldStart("channels")
			s.Channels.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.PriceUnit.Set {
			e.FieldStart("price_unit")
			s.PriceUnit.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.Track.Set {
			e.FieldStart("track")
			s.Track.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlCreateCallRecordingResponseBody = [15]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "conference_sid",
	3:  "channels",
	4:  "date_created",
	5:  "date_updated",
	6:  "start_time",
	7:  "price",
	8:  "price_unit",
	9:  "duration",
	10: "sid",
	11: "source",
	12: "error_code",
	13: "track",
	14: "uri",
}

// Decode decodes TexmlCreateCallRecordingResponseBody from json.
func (s *TexmlCreateCallRecordingResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlCreateCallRecordingResponseBody to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "conference_sid":
			if err := func() error {
				s.ConferenceSid.Reset()
				if err := s.ConferenceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_sid\"")
			}
		case "channels":
			if err := func() error {
				s.Channels.Reset()
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "price_unit":
			if err := func() error {
				s.PriceUnit.Reset()
				if err := s.PriceUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price_unit\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "track":
			if err := func() error {
				s.Track.Reset()
				if err := s.Track.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"track\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlCreateCallRecordingResponseBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlCreateCallRecordingResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlCreateCallRecordingResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlErrorCode as json.
func (s TexmlErrorCode) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlErrorCode from json.
func (s *TexmlErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlErrorCode to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlErrorCode(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlGetCallRecordingResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlGetCallRecordingResponseBody) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.ConferenceSid.Set {
			e.FieldStart("conference_sid")
			s.ConferenceSid.Encode(e)
		}
	}
	{
		if s.Channels.Set {
			e.FieldStart("channels")
			s.Channels.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.SubresourcesUris.Set {
			e.FieldStart("subresources_uris")
			s.SubresourcesUris.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.MediaURL.Set {
			e.FieldStart("media_url")
			s.MediaURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlGetCallRecordingResponseBody = [15]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "conference_sid",
	3:  "channels",
	4:  "date_created",
	5:  "date_updated",
	6:  "start_time",
	7:  "duration",
	8:  "sid",
	9:  "source",
	10: "status",
	11: "error_code",
	12: "subresources_uris",
	13: "uri",
	14: "media_url",
}

// Decode decodes TexmlGetCallRecordingResponseBody from json.
func (s *TexmlGetCallRecordingResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlGetCallRecordingResponseBody to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "conference_sid":
			if err := func() error {
				s.ConferenceSid.Reset()
				if err := s.ConferenceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_sid\"")
			}
		case "channels":
			if err := func() error {
				s.Channels.Reset()
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "subresources_uris":
			if err := func() error {
				s.SubresourcesUris.Reset()
				if err := s.SubresourcesUris.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresources_uris\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "media_url":
			if err := func() error {
				s.MediaURL.Reset()
				if err := s.MediaURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlGetCallRecordingResponseBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlGetCallRecordingResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlGetCallRecordingResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlGetCallRecordingsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlGetCallRecordingsResponseBody) encodeFields(e *jx.Encoder) {
	{
		if s.Recordings != nil {
			e.FieldStart("recordings")
			e.ArrStart()
			for _, elem := range s.Recordings {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.PreviousPageURI.Set {
			e.FieldStart("previous_page_uri")
			s.PreviousPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlGetCallRecordingsResponseBody = [9]string{
	0: "recordings",
	1: "end",
	2: "first_page_uri",
	3: "previous_page_uri",
	4: "next_page_uri",
	5: "page",
	6: "page_size",
	7: "start",
	8: "uri",
}

// Decode decodes TexmlGetCallRecordingsResponseBody from json.
func (s *TexmlGetCallRecordingsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlGetCallRecordingsResponseBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recordings":
			if err := func() error {
				s.Recordings = make([]TexmlGetCallRecordingResponseBody, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TexmlGetCallRecordingResponseBody
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Recordings = append(s.Recordings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordings\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "previous_page_uri":
			if err := func() error {
				s.PreviousPageURI.Reset()
				if err := s.PreviousPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlGetCallRecordingsResponseBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlGetCallRecordingsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlGetCallRecordingsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlListRecordingTranscriptionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlListRecordingTranscriptionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Transcriptions != nil {
			e.FieldStart("transcriptions")
			e.ArrStart()
			for _, elem := range s.Transcriptions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.PreviousPageURI.Set {
			e.FieldStart("previous_page_uri")
			s.PreviousPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlListRecordingTranscriptionResponse = [9]string{
	0: "transcriptions",
	1: "end",
	2: "first_page_uri",
	3: "previous_page_uri",
	4: "next_page_uri",
	5: "page",
	6: "page_size",
	7: "start",
	8: "uri",
}

// Decode decodes TexmlListRecordingTranscriptionResponse from json.
func (s *TexmlListRecordingTranscriptionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlListRecordingTranscriptionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transcriptions":
			if err := func() error {
				s.Transcriptions = make([]TexmlRecordingTranscription, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TexmlRecordingTranscription
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transcriptions = append(s.Transcriptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcriptions\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "previous_page_uri":
			if err := func() error {
				s.PreviousPageURI.Reset()
				if err := s.PreviousPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlListRecordingTranscriptionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlListRecordingTranscriptionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlListRecordingTranscriptionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlPriceUnit as json.
func (s TexmlPriceUnit) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlPriceUnit from json.
func (s *TexmlPriceUnit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlPriceUnit to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlPriceUnit(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlPriceUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlPriceUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingDuration as json.
func (s TexmlRecordingDuration) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlRecordingDuration from json.
func (s *TexmlRecordingDuration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingDuration to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlRecordingDuration(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingDuration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingDuration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingMediaUrl as json.
func (s TexmlRecordingMediaUrl) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)

	json.EncodeURI(e, unwrapped)
}

// Decode decodes TexmlRecordingMediaUrl from json.
func (s *TexmlRecordingMediaUrl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingMediaUrl to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlRecordingMediaUrl(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingMediaUrl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingMediaUrl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingPrice as json.
func (s TexmlRecordingPrice) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlRecordingPrice from json.
func (s *TexmlRecordingPrice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingPrice to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlRecordingPrice(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingPrice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingPrice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingStatus as json.
func (s TexmlRecordingStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TexmlRecordingStatus from json.
func (s *TexmlRecordingStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TexmlRecordingStatus(v) {
	case TexmlRecordingStatusInProgress:
		*s = TexmlRecordingStatusInProgress
	case TexmlRecordingStatusCompleted:
		*s = TexmlRecordingStatusCompleted
	case TexmlRecordingStatusPaused:
		*s = TexmlRecordingStatusPaused
	case TexmlRecordingStatusStopped:
		*s = TexmlRecordingStatusStopped
	default:
		*s = TexmlRecordingStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlRecordingSubresourcesUris) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlRecordingSubresourcesUris) encodeFields(e *jx.Encoder) {
	{
		if s.Transcriptions.Set {
			e.FieldStart("transcriptions")
			s.Transcriptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlRecordingSubresourcesUris = [1]string{
	0: "transcriptions",
}

// Decode decodes TexmlRecordingSubresourcesUris from json.
func (s *TexmlRecordingSubresourcesUris) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingSubresourcesUris to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transcriptions":
			if err := func() error {
				s.Transcriptions.Reset()
				if err := s.Transcriptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcriptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlRecordingSubresourcesUris")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlRecordingSubresourcesUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingSubresourcesUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlRecordingTranscription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlRecordingTranscription) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.RecordingSid.Set {
			e.FieldStart("recording_sid")
			s.RecordingSid.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TranscriptionText.Set {
			e.FieldStart("transcription_text")
			s.TranscriptionText.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlRecordingTranscription = [11]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "api_version",
	3:  "date_created",
	4:  "date_updated",
	5:  "duration",
	6:  "sid",
	7:  "recording_sid",
	8:  "status",
	9:  "transcription_text",
	10: "uri",
}

// Decode decodes TexmlRecordingTranscription from json.
func (s *TexmlRecordingTranscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingTranscription to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "recording_sid":
			if err := func() error {
				s.RecordingSid.Reset()
				if err := s.RecordingSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_sid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "transcription_text":
			if err := func() error {
				s.TranscriptionText.Reset()
				if err := s.TranscriptionText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription_text\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlRecordingTranscription")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlRecordingTranscription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingTranscription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingTranscriptionStatus as json.
func (s TexmlRecordingTranscriptionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TexmlRecordingTranscriptionStatus from json.
func (s *TexmlRecordingTranscriptionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingTranscriptionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TexmlRecordingTranscriptionStatus(v) {
	case TexmlRecordingTranscriptionStatusInProgress:
		*s = TexmlRecordingTranscriptionStatusInProgress
	case TexmlRecordingTranscriptionStatusCompleted:
		*s = TexmlRecordingTranscriptionStatusCompleted
	default:
		*s = TexmlRecordingTranscriptionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingTranscriptionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingTranscriptionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlSid as json.
func (s TexmlSid) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlSid from json.
func (s *TexmlSid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlSid to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlSid(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TranscriptionStartRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TranscriptionStartRequest) encodeFields(e *jx.Encoder) {
	{
		if s.TranscriptionEngine.Set {
			e.FieldStart("transcription_engine")
			s.TranscriptionEngine.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.InterimResults.Set {
			e.FieldStart("interim_results")
			s.InterimResults.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.TranscriptionTracks.Set {
			e.FieldStart("transcription_tracks")
			s.TranscriptionTracks.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTranscriptionStartRequest = [6]string{
	0: "transcription_engine",
	1: "language",
	2: "interim_results",
	3: "client_state",
	4: "transcription_tracks",
	5: "command_id",
}

// Decode decodes TranscriptionStartRequest from json.
func (s *TranscriptionStartRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionStartRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transcription_engine":
			if err := func() error {
				s.TranscriptionEngine.Reset()
				if err := s.TranscriptionEngine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription_engine\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "interim_results":
			if err := func() error {
				s.InterimResults.Reset()
				if err := s.InterimResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interim_results\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "transcription_tracks":
			if err := func() error {
				s.TranscriptionTracks.Reset()
				if err := s.TranscriptionTracks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription_tracks\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TranscriptionStartRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TranscriptionStartRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionStartRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscriptionStartRequestLanguage as json.
func (s TranscriptionStartRequestLanguage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TranscriptionStartRequestLanguage from json.
func (s *TranscriptionStartRequestLanguage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionStartRequestLanguage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TranscriptionStartRequestLanguage(v) {
	case TranscriptionStartRequestLanguageDe:
		*s = TranscriptionStartRequestLanguageDe
	case TranscriptionStartRequestLanguageEn:
		*s = TranscriptionStartRequestLanguageEn
	case TranscriptionStartRequestLanguageEs:
		*s = TranscriptionStartRequestLanguageEs
	case TranscriptionStartRequestLanguageFr:
		*s = TranscriptionStartRequestLanguageFr
	case TranscriptionStartRequestLanguageIt:
		*s = TranscriptionStartRequestLanguageIt
	case TranscriptionStartRequestLanguagePl:
		*s = TranscriptionStartRequestLanguagePl
	default:
		*s = TranscriptionStartRequestLanguage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TranscriptionStartRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionStartRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscriptionStartRequestTranscriptionEngine as json.
func (s TranscriptionStartRequestTranscriptionEngine) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TranscriptionStartRequestTranscriptionEngine from json.
func (s *TranscriptionStartRequestTranscriptionEngine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionStartRequestTranscriptionEngine to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TranscriptionStartRequestTranscriptionEngine(v) {
	case TranscriptionStartRequestTranscriptionEngineA:
		*s = TranscriptionStartRequestTranscriptionEngineA
	case TranscriptionStartRequestTranscriptionEngineB:
		*s = TranscriptionStartRequestTranscriptionEngineB
	default:
		*s = TranscriptionStartRequestTranscriptionEngine(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TranscriptionStartRequestTranscriptionEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionStartRequestTranscriptionEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TranscriptionStopRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TranscriptionStopRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTranscriptionStopRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes TranscriptionStopRequest from json.
func (s *TranscriptionStopRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionStopRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TranscriptionStopRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TranscriptionStopRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionStopRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferCallRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.FromDisplayName.Set {
			e.FieldStart("from_display_name")
			s.FromDisplayName.Encode(e)
		}
	}
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		if s.MediaName.Set {
			e.FieldStart("media_name")
			s.MediaName.Encode(e)
		}
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
	{
		if s.TimeLimitSecs.Set {
			e.FieldStart("time_limit_secs")
			s.TimeLimitSecs.Encode(e)
		}
	}
	{
		if s.AnsweringMachineDetection.Set {
			e.FieldStart("answering_machine_detection")
			s.AnsweringMachineDetection.Encode(e)
		}
	}
	{
		if s.AnsweringMachineDetectionConfig.Set {
			e.FieldStart("answering_machine_detection_config")
			s.AnsweringMachineDetectionConfig.Encode(e)
		}
	}
	{
		if s.CustomHeaders != nil {
			e.FieldStart("custom_headers")
			e.ArrStart()
			for _, elem := range s.CustomHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.TargetLegClientState.Set {
			e.FieldStart("target_leg_client_state")
			s.TargetLegClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.MediaEncryption.Set {
			e.FieldStart("media_encryption")
			s.MediaEncryption.Encode(e)
		}
	}
	{
		if s.SipAuthUsername.Set {
			e.FieldStart("sip_auth_username")
			s.SipAuthUsername.Encode(e)
		}
	}
	{
		if s.SipAuthPassword.Set {
			e.FieldStart("sip_auth_password")
			s.SipAuthPassword.Encode(e)
		}
	}
	{
		if s.SipHeaders != nil {
			e.FieldStart("sip_headers")
			e.ArrStart()
			for _, elem := range s.SipHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SipTransportProtocol.Set {
			e.FieldStart("sip_transport_protocol")
			s.SipTransportProtocol.Encode(e)
		}
	}
	{
		if s.SoundModifications.Set {
			e.FieldStart("sound_modifications")
			s.SoundModifications.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookURLMethod.Set {
			e.FieldStart("webhook_url_method")
			s.WebhookURLMethod.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransferCallRequest = [21]string{
	0:  "to",
	1:  "from",
	2:  "from_display_name",
	3:  "audio_url",
	4:  "media_name",
	5:  "timeout_secs",
	6:  "time_limit_secs",
	7:  "answering_machine_detection",
	8:  "answering_machine_detection_config",
	9:  "custom_headers",
	10: "client_state",
	11: "target_leg_client_state",
	12: "command_id",
	13: "media_encryption",
	14: "sip_auth_username",
	15: "sip_auth_password",
	16: "sip_headers",
	17: "sip_transport_protocol",
	18: "sound_modifications",
	19: "webhook_url",
	20: "webhook_url_method",
}

// Decode decodes TransferCallRequest from json.
func (s *TransferCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequest to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "to":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "from_display_name":
			if err := func() error {
				s.FromDisplayName.Reset()
				if err := s.FromDisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_display_name\"")
			}
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "media_name":
			if err := func() error {
				s.MediaName.Reset()
				if err := s.MediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_name\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		case "time_limit_secs":
			if err := func() error {
				s.TimeLimitSecs.Reset()
				if err := s.TimeLimitSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit_secs\"")
			}
		case "answering_machine_detection":
			if err := func() error {
				s.AnsweringMachineDetection.Reset()
				if err := s.AnsweringMachineDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answering_machine_detection\"")
			}
		case "answering_machine_detection_config":
			if err := func() error {
				s.AnsweringMachineDetectionConfig.Reset()
				if err := s.AnsweringMachineDetectionConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answering_machine_detection_config\"")
			}
		case "custom_headers":
			if err := func() error {
				s.CustomHeaders = make([]CustomSipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomSipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomHeaders = append(s.CustomHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_headers\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "target_leg_client_state":
			if err := func() error {
				s.TargetLegClientState.Reset()
				if err := s.TargetLegClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_leg_client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "media_encryption":
			if err := func() error {
				s.MediaEncryption.Reset()
				if err := s.MediaEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_encryption\"")
			}
		case "sip_auth_username":
			if err := func() error {
				s.SipAuthUsername.Reset()
				if err := s.SipAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_username\"")
			}
		case "sip_auth_password":
			if err := func() error {
				s.SipAuthPassword.Reset()
				if err := s.SipAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_password\"")
			}
		case "sip_headers":
			if err := func() error {
				s.SipHeaders = make([]SipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SipHeaders = append(s.SipHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_headers\"")
			}
		case "sip_transport_protocol":
			if err := func() error {
				s.SipTransportProtocol.Reset()
				if err := s.SipTransportProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_transport_protocol\"")
			}
		case "sound_modifications":
			if err := func() error {
				s.SoundModifications.Reset()
				if err := s.SoundModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sound_modifications\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_url_method":
			if err := func() error {
				s.WebhookURLMethod.Reset()
				if err := s.WebhookURLMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url_method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferCallRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransferCallRequest) {
					name = jsonFieldsNameOfTransferCallRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestAnsweringMachineDetection as json.
func (s TransferCallRequestAnsweringMachineDetection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferCallRequestAnsweringMachineDetection from json.
func (s *TransferCallRequestAnsweringMachineDetection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestAnsweringMachineDetection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferCallRequestAnsweringMachineDetection(v) {
	case TransferCallRequestAnsweringMachineDetectionPremium:
		*s = TransferCallRequestAnsweringMachineDetectionPremium
	case TransferCallRequestAnsweringMachineDetectionDetect:
		*s = TransferCallRequestAnsweringMachineDetectionDetect
	case TransferCallRequestAnsweringMachineDetectionDetectBeep:
		*s = TransferCallRequestAnsweringMachineDetectionDetectBeep
	case TransferCallRequestAnsweringMachineDetectionDetectWords:
		*s = TransferCallRequestAnsweringMachineDetectionDetectWords
	case TransferCallRequestAnsweringMachineDetectionGreetingEnd:
		*s = TransferCallRequestAnsweringMachineDetectionGreetingEnd
	case TransferCallRequestAnsweringMachineDetectionDisabled:
		*s = TransferCallRequestAnsweringMachineDetectionDisabled
	default:
		*s = TransferCallRequestAnsweringMachineDetection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferCallRequestAnsweringMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestAnsweringMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) encodeFields(e *jx.Encoder) {
	{
		if s.TotalAnalysisTimeMillis.Set {
			e.FieldStart("total_analysis_time_millis")
			s.TotalAnalysisTimeMillis.Encode(e)
		}
	}
	{
		if s.AfterGreetingSilenceMillis.Set {
			e.FieldStart("after_greeting_silence_millis")
			s.AfterGreetingSilenceMillis.Encode(e)
		}
	}
	{
		if s.BetweenWordsSilenceMillis.Set {
			e.FieldStart("between_words_silence_millis")
			s.BetweenWordsSilenceMillis.Encode(e)
		}
	}
	{
		if s.GreetingDurationMillis.Set {
			e.FieldStart("greeting_duration_millis")
			s.GreetingDurationMillis.Encode(e)
		}
	}
	{
		if s.InitialSilenceMillis.Set {
			e.FieldStart("initial_silence_millis")
			s.InitialSilenceMillis.Encode(e)
		}
	}
	{
		if s.MaximumNumberOfWords.Set {
			e.FieldStart("maximum_number_of_words")
			s.MaximumNumberOfWords.Encode(e)
		}
	}
	{
		if s.MaximumWordLengthMillis.Set {
			e.FieldStart("maximum_word_length_millis")
			s.MaximumWordLengthMillis.Encode(e)
		}
	}
	{
		if s.SilenceThreshold.Set {
			e.FieldStart("silence_threshold")
			s.SilenceThreshold.Encode(e)
		}
	}
	{
		if s.GreetingTotalAnalysisTimeMillis.Set {
			e.FieldStart("greeting_total_analysis_time_millis")
			s.GreetingTotalAnalysisTimeMillis.Encode(e)
		}
	}
	{
		if s.GreetingSilenceDurationMillis.Set {
			e.FieldStart("greeting_silence_duration_millis")
			s.GreetingSilenceDurationMillis.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransferCallRequestAnsweringMachineDetectionConfig = [10]string{
	0: "total_analysis_time_millis",
	1: "after_greeting_silence_millis",
	2: "between_words_silence_millis",
	3: "greeting_duration_millis",
	4: "initial_silence_millis",
	5: "maximum_number_of_words",
	6: "maximum_word_length_millis",
	7: "silence_threshold",
	8: "greeting_total_analysis_time_millis",
	9: "greeting_silence_duration_millis",
}

// Decode decodes TransferCallRequestAnsweringMachineDetectionConfig from json.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestAnsweringMachineDetectionConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_analysis_time_millis":
			if err := func() error {
				s.TotalAnalysisTimeMillis.Reset()
				if err := s.TotalAnalysisTimeMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_analysis_time_millis\"")
			}
		case "after_greeting_silence_millis":
			if err := func() error {
				s.AfterGreetingSilenceMillis.Reset()
				if err := s.AfterGreetingSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"after_greeting_silence_millis\"")
			}
		case "between_words_silence_millis":
			if err := func() error {
				s.BetweenWordsSilenceMillis.Reset()
				if err := s.BetweenWordsSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"between_words_silence_millis\"")
			}
		case "greeting_duration_millis":
			if err := func() error {
				s.GreetingDurationMillis.Reset()
				if err := s.GreetingDurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_duration_millis\"")
			}
		case "initial_silence_millis":
			if err := func() error {
				s.InitialSilenceMillis.Reset()
				if err := s.InitialSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_silence_millis\"")
			}
		case "maximum_number_of_words":
			if err := func() error {
				s.MaximumNumberOfWords.Reset()
				if err := s.MaximumNumberOfWords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_number_of_words\"")
			}
		case "maximum_word_length_millis":
			if err := func() error {
				s.MaximumWordLengthMillis.Reset()
				if err := s.MaximumWordLengthMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_word_length_millis\"")
			}
		case "silence_threshold":
			if err := func() error {
				s.SilenceThreshold.Reset()
				if err := s.SilenceThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"silence_threshold\"")
			}
		case "greeting_total_analysis_time_millis":
			if err := func() error {
				s.GreetingTotalAnalysisTimeMillis.Reset()
				if err := s.GreetingTotalAnalysisTimeMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_total_analysis_time_millis\"")
			}
		case "greeting_silence_duration_millis":
			if err := func() error {
				s.GreetingSilenceDurationMillis.Reset()
				if err := s.GreetingSilenceDurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_silence_duration_millis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferCallRequestAnsweringMachineDetectionConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestMediaEncryption as json.
func (s TransferCallRequestMediaEncryption) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferCallRequestMediaEncryption from json.
func (s *TransferCallRequestMediaEncryption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestMediaEncryption to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferCallRequestMediaEncryption(v) {
	case TransferCallRequestMediaEncryptionDisabled:
		*s = TransferCallRequestMediaEncryptionDisabled
	case TransferCallRequestMediaEncryptionSRTP:
		*s = TransferCallRequestMediaEncryptionSRTP
	default:
		*s = TransferCallRequestMediaEncryption(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferCallRequestMediaEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestMediaEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestSipTransportProtocol as json.
func (s TransferCallRequestSipTransportProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferCallRequestSipTransportProtocol from json.
func (s *TransferCallRequestSipTransportProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestSipTransportProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferCallRequestSipTransportProtocol(v) {
	case TransferCallRequestSipTransportProtocolUDP:
		*s = TransferCallRequestSipTransportProtocolUDP
	case TransferCallRequestSipTransportProtocolTCP:
		*s = TransferCallRequestSipTransportProtocolTCP
	case TransferCallRequestSipTransportProtocolTLS:
		*s = TransferCallRequestSipTransportProtocolTLS
	default:
		*s = TransferCallRequestSipTransportProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferCallRequestSipTransportProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestSipTransportProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestWebhookURLMethod as json.
func (s TransferCallRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferCallRequestWebhookURLMethod from json.
func (s *TransferCallRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestWebhookURLMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferCallRequestWebhookURLMethod(v) {
	case TransferCallRequestWebhookURLMethodPOST:
		*s = TransferCallRequestWebhookURLMethodPOST
	case TransferCallRequestWebhookURLMethodGET:
		*s = TransferCallRequestWebhookURLMethodGET
	default:
		*s = TransferCallRequestWebhookURLMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferCallRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TwimlRecordingChannels as json.
func (s TwimlRecordingChannels) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes TwimlRecordingChannels from json.
func (s *TwimlRecordingChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TwimlRecordingChannels to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = TwimlRecordingChannels(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TwimlRecordingChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TwimlRecordingChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCallControlApplicationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCallControlApplicationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("application_name")
		e.Str(s.ApplicationName)
	}
	{
		e.FieldStart("webhook_event_url")
		e.Str(s.WebhookEventURL)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.AnchorsiteOverride.Set {
			e.FieldStart("anchorsite_override")
			s.AnchorsiteOverride.Encode(e)
		}
	}
	{
		if s.DtmfType.Set {
			e.FieldStart("dtmf_type")
			s.DtmfType.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeout.Set {
			e.FieldStart("first_command_timeout")
			s.FirstCommandTimeout.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeoutSecs.Set {
			e.FieldStart("first_command_timeout_secs")
			s.FirstCommandTimeoutSecs.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
	{
		if s.WebhookAPIVersion.Set {
			e.FieldStart("webhook_api_version")
			s.WebhookAPIVersion.Encode(e)
		}
	}
	{
		if s.WebhookEventFailoverURL.Set {
			e.FieldStart("webhook_event_failover_url")
			s.WebhookEventFailoverURL.Encode(e)
		}
	}
	{
		if s.WebhookTimeoutSecs.Set {
			e.FieldStart("webhook_timeout_secs")
			s.WebhookTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCallControlApplicationRequest = [12]string{
	0:  "application_name",
	1:  "webhook_event_url",
	2:  "active",
	3:  "anchorsite_override",
	4:  "dtmf_type",
	5:  "first_command_timeout",
	6:  "first_command_timeout_secs",
	7:  "inbound",
	8:  "outbound",
	9:  "webhook_api_version",
	10: "webhook_event_failover_url",
	11: "webhook_timeout_secs",
}

// Decode decodes UpdateCallControlApplicationRequest from json.
func (s *UpdateCallControlApplicationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallControlApplicationRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "application_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApplicationName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"application_name\"")
			}
		case "webhook_event_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WebhookEventURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_event_url\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "anchorsite_override":
			if err := func() error {
				s.AnchorsiteOverride.Reset()
				if err := s.AnchorsiteOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anchorsite_override\"")
			}
		case "dtmf_type":
			if err := func() error {
				s.DtmfType.Reset()
				if err := s.DtmfType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtmf_type\"")
			}
		case "first_command_timeout":
			if err := func() error {
				s.FirstCommandTimeout.Reset()
				if err := s.FirstCommandTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout\"")
			}
		case "first_command_timeout_secs":
			if err := func() error {
				s.FirstCommandTimeoutSecs.Reset()
				if err := s.FirstCommandTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout_secs\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		case "webhook_api_version":
			if err := func() error {
				s.WebhookAPIVersion.Reset()
				if err := s.WebhookAPIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_api_version\"")
			}
		case "webhook_event_failover_url":
			if err := func() error {
				s.WebhookEventFailoverURL.Reset()
				if err := s.WebhookEventFailoverURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_event_failover_url\"")
			}
		case "webhook_timeout_secs":
			if err := func() error {
				s.WebhookTimeoutSecs.Reset()
				if err := s.WebhookTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCallControlApplicationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateCallControlApplicationRequest) {
					name = jsonFieldsNameOfUpdateCallControlApplicationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallControlApplicationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallControlApplicationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallControlApplicationRequestAnchorsiteOverride as json.
func (s UpdateCallControlApplicationRequestAnchorsiteOverride) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallControlApplicationRequestAnchorsiteOverride from json.
func (s *UpdateCallControlApplicationRequestAnchorsiteOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallControlApplicationRequestAnchorsiteOverride to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallControlApplicationRequestAnchorsiteOverride(v) {
	case UpdateCallControlApplicationRequestAnchorsiteOverrideLatency:
		*s = UpdateCallControlApplicationRequestAnchorsiteOverrideLatency
	case UpdateCallControlApplicationRequestAnchorsiteOverrideChicagoIL:
		*s = UpdateCallControlApplicationRequestAnchorsiteOverrideChicagoIL
	case UpdateCallControlApplicationRequestAnchorsiteOverrideAshburnVA:
		*s = UpdateCallControlApplicationRequestAnchorsiteOverrideAshburnVA
	case UpdateCallControlApplicationRequestAnchorsiteOverrideSanJoseCA:
		*s = UpdateCallControlApplicationRequestAnchorsiteOverrideSanJoseCA
	default:
		*s = UpdateCallControlApplicationRequestAnchorsiteOverride(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallControlApplicationRequestAnchorsiteOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallControlApplicationRequestAnchorsiteOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallControlApplicationRequestDtmfType as json.
func (s UpdateCallControlApplicationRequestDtmfType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallControlApplicationRequestDtmfType from json.
func (s *UpdateCallControlApplicationRequestDtmfType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallControlApplicationRequestDtmfType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallControlApplicationRequestDtmfType(v) {
	case UpdateCallControlApplicationRequestDtmfTypeRFC2833:
		*s = UpdateCallControlApplicationRequestDtmfTypeRFC2833
	case UpdateCallControlApplicationRequestDtmfTypeInband:
		*s = UpdateCallControlApplicationRequestDtmfTypeInband
	case UpdateCallControlApplicationRequestDtmfTypeSIPINFO:
		*s = UpdateCallControlApplicationRequestDtmfTypeSIPINFO
	default:
		*s = UpdateCallControlApplicationRequestDtmfType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallControlApplicationRequestDtmfType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallControlApplicationRequestDtmfType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallControlApplicationRequestWebhookAPIVersion as json.
func (s UpdateCallControlApplicationRequestWebhookAPIVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallControlApplicationRequestWebhookAPIVersion from json.
func (s *UpdateCallControlApplicationRequestWebhookAPIVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallControlApplicationRequestWebhookAPIVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallControlApplicationRequestWebhookAPIVersion(v) {
	case UpdateCallControlApplicationRequestWebhookAPIVersion1:
		*s = UpdateCallControlApplicationRequestWebhookAPIVersion1
	case UpdateCallControlApplicationRequestWebhookAPIVersion2:
		*s = UpdateCallControlApplicationRequestWebhookAPIVersion2
	default:
		*s = UpdateCallControlApplicationRequestWebhookAPIVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallControlApplicationRequestWebhookAPIVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallControlApplicationRequestWebhookAPIVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCallRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("Status")
			s.Status.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("Url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("Method")
			s.Method.Encode(e)
		}
	}
	{
		if s.FallbackUrl.Set {
			e.FieldStart("FallbackUrl")
			s.FallbackUrl.Encode(e)
		}
	}
	{
		if s.FallbackMethod.Set {
			e.FieldStart("FallbackMethod")
			s.FallbackMethod.Encode(e)
		}
	}
	{
		if s.StatusCallback.Set {
			e.FieldStart("StatusCallback")
			s.StatusCallback.Encode(e)
		}
	}
	{
		if s.StatusCallbackMethod.Set {
			e.FieldStart("StatusCallbackMethod")
			s.StatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.Texml.Set {
			e.FieldStart("Texml")
			s.Texml.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCallRequest = [8]string{
	0: "Status",
	1: "Url",
	2: "Method",
	3: "FallbackUrl",
	4: "FallbackMethod",
	5: "StatusCallback",
	6: "StatusCallbackMethod",
	7: "Texml",
}

// Decode decodes UpdateCallRequest from json.
func (s *UpdateCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Status\"")
			}
		case "Url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Url\"")
			}
		case "Method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Method\"")
			}
		case "FallbackUrl":
			if err := func() error {
				s.FallbackUrl.Reset()
				if err := s.FallbackUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FallbackUrl\"")
			}
		case "FallbackMethod":
			if err := func() error {
				s.FallbackMethod.Reset()
				if err := s.FallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FallbackMethod\"")
			}
		case "StatusCallback":
			if err := func() error {
				s.StatusCallback.Reset()
				if err := s.StatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallback\"")
			}
		case "StatusCallbackMethod":
			if err := func() error {
				s.StatusCallbackMethod.Reset()
				if err := s.StatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallbackMethod\"")
			}
		case "Texml":
			if err := func() error {
				s.Texml.Reset()
				if err := s.Texml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Texml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCallRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestFallbackMethod as json.
func (s UpdateCallRequestFallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallRequestFallbackMethod from json.
func (s *UpdateCallRequestFallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallRequestFallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallRequestFallbackMethod(v) {
	case UpdateCallRequestFallbackMethodGET:
		*s = UpdateCallRequestFallbackMethodGET
	case UpdateCallRequestFallbackMethodPOST:
		*s = UpdateCallRequestFallbackMethodPOST
	default:
		*s = UpdateCallRequestFallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallRequestFallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallRequestFallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestMethod as json.
func (s UpdateCallRequestMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallRequestMethod from json.
func (s *UpdateCallRequestMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallRequestMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallRequestMethod(v) {
	case UpdateCallRequestMethodGET:
		*s = UpdateCallRequestMethodGET
	case UpdateCallRequestMethodPOST:
		*s = UpdateCallRequestMethodPOST
	default:
		*s = UpdateCallRequestMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallRequestMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallRequestMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestStatusCallbackMethod as json.
func (s UpdateCallRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallRequestStatusCallbackMethod from json.
func (s *UpdateCallRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallRequestStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallRequestStatusCallbackMethod(v) {
	case UpdateCallRequestStatusCallbackMethodGET:
		*s = UpdateCallRequestStatusCallbackMethodGET
	case UpdateCallRequestStatusCallbackMethodPOST:
		*s = UpdateCallRequestStatusCallbackMethodPOST
	default:
		*s = UpdateCallRequestStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCommandResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCommandResult) encodeFields(e *jx.Encoder) {
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCommandResult = [2]string{
	0: "sid",
	1: "status",
}

// Decode decodes UpdateCommandResult from json.
func (s *UpdateCommandResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCommandResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCommandResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCommandResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCommandResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTeXMLCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTeXMLCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTeXMLCallResponse = [1]string{
	0: "data",
}

// Decode decodes UpdateTeXMLCallResponse from json.
func (s *UpdateTeXMLCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTeXMLCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTeXMLCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTeXMLCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTeXMLCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationBadRequest as json.
func (s *UpdateTexmlApplicationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTexmlApplicationBadRequest from json.
func (s *UpdateTexmlApplicationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTexmlApplicationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTexmlApplicationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationNotFound as json.
func (s *UpdateTexmlApplicationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTexmlApplicationNotFound from json.
func (s *UpdateTexmlApplicationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTexmlApplicationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTexmlApplicationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTexmlApplicationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTexmlApplicationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("friendly_name")
		s.FriendlyName.Encode(e)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.AnchorsiteOverride.Set {
			e.FieldStart("anchorsite_override")
			s.AnchorsiteOverride.Encode(e)
		}
	}
	{
		if s.DtmfType.Set {
			e.FieldStart("dtmf_type")
			s.DtmfType.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeout.Set {
			e.FieldStart("first_command_timeout")
			s.FirstCommandTimeout.Encode(e)
		}
	}
	{
		if s.FirstCommandTimeoutSecs.Set {
			e.FieldStart("first_command_timeout_secs")
			s.FirstCommandTimeoutSecs.Encode(e)
		}
	}
	{
		e.FieldStart("voice_url")
		e.Str(s.VoiceURL)
	}
	{
		if s.VoiceFallbackURL.Set {
			e.FieldStart("voice_fallback_url")
			s.VoiceFallbackURL.Encode(e)
		}
	}
	{
		if s.VoiceMethod.Set {
			e.FieldStart("voice_method")
			s.VoiceMethod.Encode(e)
		}
	}
	{
		if s.StatusCallback.Set {
			e.FieldStart("status_callback")
			s.StatusCallback.Encode(e)
		}
	}
	{
		if s.StatusCallbackMethod.Set {
			e.FieldStart("status_callback_method")
			s.StatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Outbound.Set {
			e.FieldStart("outbound")
			s.Outbound.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTexmlApplicationRequest = [13]string{
	0:  "friendly_name",
	1:  "active",
	2:  "anchorsite_override",
	3:  "dtmf_type",
	4:  "first_command_timeout",
	5:  "first_command_timeout_secs",
	6:  "voice_url",
	7:  "voice_fallback_url",
	8:  "voice_method",
	9:  "status_callback",
	10: "status_callback_method",
	11: "inbound",
	12: "outbound",
}

// Decode decodes UpdateTexmlApplicationRequest from json.
func (s *UpdateTexmlApplicationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "friendly_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FriendlyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friendly_name\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "anchorsite_override":
			if err := func() error {
				s.AnchorsiteOverride.Reset()
				if err := s.AnchorsiteOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anchorsite_override\"")
			}
		case "dtmf_type":
			if err := func() error {
				s.DtmfType.Reset()
				if err := s.DtmfType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtmf_type\"")
			}
		case "first_command_timeout":
			if err := func() error {
				s.FirstCommandTimeout.Reset()
				if err := s.FirstCommandTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout\"")
			}
		case "first_command_timeout_secs":
			if err := func() error {
				s.FirstCommandTimeoutSecs.Reset()
				if err := s.FirstCommandTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_command_timeout_secs\"")
			}
		case "voice_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.VoiceURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_url\"")
			}
		case "voice_fallback_url":
			if err := func() error {
				s.VoiceFallbackURL.Reset()
				if err := s.VoiceFallbackURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_fallback_url\"")
			}
		case "voice_method":
			if err := func() error {
				s.VoiceMethod.Reset()
				if err := s.VoiceMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_method\"")
			}
		case "status_callback":
			if err := func() error {
				s.StatusCallback.Reset()
				if err := s.StatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_callback\"")
			}
		case "status_callback_method":
			if err := func() error {
				s.StatusCallbackMethod.Reset()
				if err := s.StatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_callback_method\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "outbound":
			if err := func() error {
				s.Outbound.Reset()
				if err := s.Outbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTexmlApplicationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTexmlApplicationRequest) {
					name = jsonFieldsNameOfUpdateTexmlApplicationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTexmlApplicationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTexmlApplicationRequestInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTexmlApplicationRequestInbound) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelLimit.Set {
			e.FieldStart("channel_limit")
			s.ChannelLimit.Encode(e)
		}
	}
	{
		if s.ShakenStirEnabled.Set {
			e.FieldStart("shaken_stir_enabled")
			s.ShakenStirEnabled.Encode(e)
		}
	}
	{
		if s.SipSubdomain.Set {
			e.FieldStart("sip_subdomain")
			s.SipSubdomain.Encode(e)
		}
	}
	{
		if s.SipSubdomainReceiveSettings.Set {
			e.FieldStart("sip_subdomain_receive_settings")
			s.SipSubdomainReceiveSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTexmlApplicationRequestInbound = [4]string{
	0: "channel_limit",
	1: "shaken_stir_enabled",
	2: "sip_subdomain",
	3: "sip_subdomain_receive_settings",
}

// Decode decodes UpdateTexmlApplicationRequestInbound from json.
func (s *UpdateTexmlApplicationRequestInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationRequestInbound to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_limit":
			if err := func() error {
				s.ChannelLimit.Reset()
				if err := s.ChannelLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_limit\"")
			}
		case "shaken_stir_enabled":
			if err := func() error {
				s.ShakenStirEnabled.Reset()
				if err := s.ShakenStirEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shaken_stir_enabled\"")
			}
		case "sip_subdomain":
			if err := func() error {
				s.SipSubdomain.Reset()
				if err := s.SipSubdomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_subdomain\"")
			}
		case "sip_subdomain_receive_settings":
			if err := func() error {
				s.SipSubdomainReceiveSettings.Reset()
				if err := s.SipSubdomainReceiveSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_subdomain_receive_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTexmlApplicationRequestInbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTexmlApplicationRequestInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationRequestInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings as json.
func (s UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings from json.
func (s *UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings(v) {
	case UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettingsOnlyMyConnections:
		*s = UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettingsOnlyMyConnections
	case UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettingsFromAnyone:
		*s = UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettingsFromAnyone
	default:
		*s = UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationRequestInboundSipSubdomainReceiveSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTexmlApplicationRequestOutbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTexmlApplicationRequestOutbound) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelLimit.Set {
			e.FieldStart("channel_limit")
			s.ChannelLimit.Encode(e)
		}
	}
	{
		if s.OutboundVoiceProfileID.Set {
			e.FieldStart("outbound_voice_profile_id")
			s.OutboundVoiceProfileID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTexmlApplicationRequestOutbound = [2]string{
	0: "channel_limit",
	1: "outbound_voice_profile_id",
}

// Decode decodes UpdateTexmlApplicationRequestOutbound from json.
func (s *UpdateTexmlApplicationRequestOutbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationRequestOutbound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_limit":
			if err := func() error {
				s.ChannelLimit.Reset()
				if err := s.ChannelLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_limit\"")
			}
		case "outbound_voice_profile_id":
			if err := func() error {
				s.OutboundVoiceProfileID.Reset()
				if err := s.OutboundVoiceProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound_voice_profile_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTexmlApplicationRequestOutbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTexmlApplicationRequestOutbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationRequestOutbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationRequestStatusCallbackMethod as json.
func (s UpdateTexmlApplicationRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTexmlApplicationRequestStatusCallbackMethod from json.
func (s *UpdateTexmlApplicationRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationRequestStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTexmlApplicationRequestStatusCallbackMethod(v) {
	case UpdateTexmlApplicationRequestStatusCallbackMethodGet:
		*s = UpdateTexmlApplicationRequestStatusCallbackMethodGet
	case UpdateTexmlApplicationRequestStatusCallbackMethodPost:
		*s = UpdateTexmlApplicationRequestStatusCallbackMethodPost
	default:
		*s = UpdateTexmlApplicationRequestStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTexmlApplicationRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationRequestVoiceMethod as json.
func (s UpdateTexmlApplicationRequestVoiceMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTexmlApplicationRequestVoiceMethod from json.
func (s *UpdateTexmlApplicationRequestVoiceMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationRequestVoiceMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTexmlApplicationRequestVoiceMethod(v) {
	case UpdateTexmlApplicationRequestVoiceMethodGet:
		*s = UpdateTexmlApplicationRequestVoiceMethodGet
	case UpdateTexmlApplicationRequestVoiceMethodPost:
		*s = UpdateTexmlApplicationRequestVoiceMethodPost
	default:
		*s = UpdateTexmlApplicationRequestVoiceMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTexmlApplicationRequestVoiceMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationRequestVoiceMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationUnauthorized as json.
func (s *UpdateTexmlApplicationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTexmlApplicationUnauthorized from json.
func (s *UpdateTexmlApplicationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTexmlApplicationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTexmlApplicationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTexmlApplicationUnprocessableEntity as json.
func (s *UpdateTexmlApplicationUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTexmlApplicationUnprocessableEntity from json.
func (s *UpdateTexmlApplicationUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTexmlApplicationUnprocessableEntity to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTexmlApplicationUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTexmlApplicationUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTexmlApplicationUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateVerifiedCallsDisplayProfileRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateVerifiedCallsDisplayProfileRequest) encodeFields(e *jx.Encoder) {
	{
		if s.CallReasons != nil {
			e.FieldStart("call_reasons")
			s.CallReasons.Encode(e)
		}
	}
	{
		if s.PhoneNumbers != nil {
			e.FieldStart("phone_numbers")
			s.PhoneNumbers.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateVerifiedCallsDisplayProfileRequest = [2]string{
	0: "call_reasons",
	1: "phone_numbers",
}

// Decode decodes UpdateVerifiedCallsDisplayProfileRequest from json.
func (s *UpdateVerifiedCallsDisplayProfileRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVerifiedCallsDisplayProfileRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "call_reasons":
			if err := func() error {
				if err := s.CallReasons.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_reasons\"")
			}
		case "phone_numbers":
			if err := func() error {
				if err := s.PhoneNumbers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_numbers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVerifiedCallsDisplayProfileRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVerifiedCallsDisplayProfileRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVerifiedCallsDisplayProfileRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateVerifyProfileCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateVerifyProfileCallRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MessagingTemplateID.Set {
			e.FieldStart("messaging_template_id")
			s.MessagingTemplateID.Encode(e)
		}
	}
	{
		if s.AppName.Set {
			e.FieldStart("app_name")
			s.AppName.Encode(e)
		}
	}
	{
		if s.WhitelistedDestinations != nil {
			e.FieldStart("whitelisted_destinations")
			e.ArrStart()
			for _, elem := range s.WhitelistedDestinations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateVerifyProfileCallRequest = [4]string{
	0: "messaging_template_id",
	1: "app_name",
	2: "whitelisted_destinations",
	3: "default_verification_timeout_secs",
}

// Decode decodes UpdateVerifyProfileCallRequest from json.
func (s *UpdateVerifyProfileCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVerifyProfileCallRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messaging_template_id":
			if err := func() error {
				s.MessagingTemplateID.Reset()
				if err := s.MessagingTemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_template_id\"")
			}
		case "app_name":
			if err := func() error {
				s.AppName.Reset()
				if err := s.AppName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_name\"")
			}
		case "whitelisted_destinations":
			if err := func() error {
				s.WhitelistedDestinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedDestinations = append(s.WhitelistedDestinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_destinations\"")
			}
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVerifyProfileCallRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVerifyProfileCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVerifyProfileCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateVerifyProfileFlashcallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateVerifyProfileFlashcallRequest) encodeFields(e *jx.Encoder) {
	{
		if s.WhitelistedDestinations != nil {
			e.FieldStart("whitelisted_destinations")
			e.ArrStart()
			for _, elem := range s.WhitelistedDestinations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateVerifyProfileFlashcallRequest = [2]string{
	0: "whitelisted_destinations",
	1: "default_verification_timeout_secs",
}

// Decode decodes UpdateVerifyProfileFlashcallRequest from json.
func (s *UpdateVerifyProfileFlashcallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVerifyProfileFlashcallRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "whitelisted_destinations":
			if err := func() error {
				s.WhitelistedDestinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedDestinations = append(s.WhitelistedDestinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_destinations\"")
			}
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVerifyProfileFlashcallRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVerifyProfileFlashcallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVerifyProfileFlashcallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateVerifyProfileReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateVerifyProfileReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookFailoverURL.Set {
			e.FieldStart("webhook_failover_url")
			s.WebhookFailoverURL.Encode(e)
		}
	}
	{
		if s.SMS.Set {
			e.FieldStart("sms")
			s.SMS.Encode(e)
		}
	}
	{
		if s.Call.Set {
			e.FieldStart("call")
			s.Call.Encode(e)
		}
	}
	{
		if s.Flashcall.Set {
			e.FieldStart("flashcall")
			s.Flashcall.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateVerifyProfileReq = [7]string{
	0: "name",
	1: "webhook_url",
	2: "webhook_failover_url",
	3: "sms",
	4: "call",
	5: "flashcall",
	6: "language",
}

// Decode decodes UpdateVerifyProfileReq from json.
func (s *UpdateVerifyProfileReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVerifyProfileReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_failover_url":
			if err := func() error {
				s.WebhookFailoverURL.Reset()
				if err := s.WebhookFailoverURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_failover_url\"")
			}
		case "sms":
			if err := func() error {
				s.SMS.Reset()
				if err := s.SMS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms\"")
			}
		case "call":
			if err := func() error {
				s.Call.Reset()
				if err := s.Call.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call\"")
			}
		case "flashcall":
			if err := func() error {
				s.Flashcall.Reset()
				if err := s.Flashcall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flashcall\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVerifyProfileReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVerifyProfileReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVerifyProfileReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateVerifyProfileSMSRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateVerifyProfileSMSRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MessagingTemplateID.Set {
			e.FieldStart("messaging_template_id")
			s.MessagingTemplateID.Encode(e)
		}
	}
	{
		if s.AppName.Set {
			e.FieldStart("app_name")
			s.AppName.Encode(e)
		}
	}
	{
		if s.AlphaSender.Set {
			e.FieldStart("alpha_sender")
			s.AlphaSender.Encode(e)
		}
	}
	{
		if s.WhitelistedDestinations != nil {
			e.FieldStart("whitelisted_destinations")
			e.ArrStart()
			for _, elem := range s.WhitelistedDestinations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateVerifyProfileSMSRequest = [5]string{
	0: "messaging_template_id",
	1: "app_name",
	2: "alpha_sender",
	3: "whitelisted_destinations",
	4: "default_verification_timeout_secs",
}

// Decode decodes UpdateVerifyProfileSMSRequest from json.
func (s *UpdateVerifyProfileSMSRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateVerifyProfileSMSRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messaging_template_id":
			if err := func() error {
				s.MessagingTemplateID.Reset()
				if err := s.MessagingTemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_template_id\"")
			}
		case "app_name":
			if err := func() error {
				s.AppName.Reset()
				if err := s.AppName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_name\"")
			}
		case "alpha_sender":
			if err := func() error {
				s.AlphaSender.Reset()
				if err := s.AlphaSender.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpha_sender\"")
			}
		case "whitelisted_destinations":
			if err := func() error {
				s.WhitelistedDestinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedDestinations = append(s.WhitelistedDestinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_destinations\"")
			}
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateVerifyProfileSMSRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateVerifyProfileSMSRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateVerifyProfileSMSRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatedAt as json.
func (s UpdatedAt) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes UpdatedAt from json.
func (s *UpdatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatedAt to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatedAt(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdatedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsageReportsOptionsRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsageReportsOptionsRecord) encodeFields(e *jx.Encoder) {
	{
		if s.Product.Set {
			e.FieldStart("product")
			s.Product.Encode(e)
		}
	}
	{
		if s.ProductDimensions != nil {
			e.FieldStart("product_dimensions")
			e.ArrStart()
			for _, elem := range s.ProductDimensions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ProductMetrics != nil {
			e.FieldStart("product_metrics")
			e.ArrStart()
			for _, elem := range s.ProductMetrics {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RecordTypes != nil {
			e.FieldStart("record_types")
			e.ArrStart()
			for _, elem := range s.RecordTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsageReportsOptionsRecord = [4]string{
	0: "product",
	1: "product_dimensions",
	2: "product_metrics",
	3: "record_types",
}

// Decode decodes UsageReportsOptionsRecord from json.
func (s *UsageReportsOptionsRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsageReportsOptionsRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "product":
			if err := func() error {
				s.Product.Reset()
				if err := s.Product.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product\"")
			}
		case "product_dimensions":
			if err := func() error {
				s.ProductDimensions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ProductDimensions = append(s.ProductDimensions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product_dimensions\"")
			}
		case "product_metrics":
			if err := func() error {
				s.ProductMetrics = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ProductMetrics = append(s.ProductMetrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product_metrics\"")
			}
		case "record_types":
			if err := func() error {
				s.RecordTypes = make([]RecordType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecordType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RecordTypes = append(s.RecordTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsageReportsOptionsRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsageReportsOptionsRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsageReportsOptionsRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsageReportsOptionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsageReportsOptionsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsageReportsOptionsResponse = [1]string{
	0: "data",
}

// Decode decodes UsageReportsOptionsResponse from json.
func (s *UsageReportsOptionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsageReportsOptionsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]UsageReportsOptionsRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsageReportsOptionsRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsageReportsOptionsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsageReportsOptionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsageReportsOptionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsageReportsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsageReportsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsageReportsResponse = [2]string{
	0: "meta",
	1: "data",
}

// Decode decodes UsageReportsResponse from json.
func (s *UsageReportsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsageReportsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]UsageReportsResponseDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsageReportsResponseDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsageReportsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsageReportsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsageReportsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UsageReportsResponseDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UsageReportsResponseDataItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes UsageReportsResponseDataItem from json.
func (s *UsageReportsResponseDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsageReportsResponseDataItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsageReportsResponseDataItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsageReportsResponseDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsageReportsResponseDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserBalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserBalance) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
	{
		if s.CreditLimit.Set {
			e.FieldStart("credit_limit")
			s.CreditLimit.Encode(e)
		}
	}
	{
		if s.AvailableCredit.Set {
			e.FieldStart("available_credit")
			s.AvailableCredit.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserBalance = [5]string{
	0: "record_type",
	1: "balance",
	2: "credit_limit",
	3: "available_credit",
	4: "currency",
}

// Decode decodes UserBalance from json.
func (s *UserBalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBalance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "credit_limit":
			if err := func() error {
				s.CreditLimit.Reset()
				if err := s.CreditLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credit_limit\"")
			}
		case "available_credit":
			if err := func() error {
				s.AvailableCredit.Reset()
				if err := s.AvailableCredit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_credit\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserBalance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBalanceRecordType as json.
func (s UserBalanceRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBalanceRecordType from json.
func (s *UserBalanceRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBalanceRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBalanceRecordType(v) {
	case UserBalanceRecordTypeBalance:
		*s = UserBalanceRecordTypeBalance
	default:
		*s = UserBalanceRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBalanceRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBalanceRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserBalanceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserBalanceResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserBalanceResponse = [1]string{
	0: "data",
}

// Decode decodes UserBalanceResponse from json.
func (s *UserBalanceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBalanceResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserBalanceResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserBalanceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBalanceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("loc")
		e.ArrStart()
		for _, elem := range s.Loc {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("msg")
		e.Str(s.Msg)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfValidationError = [3]string{
	0: "loc",
	1: "msg",
	2: "type",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loc":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Loc = make([]ValidationErrorLocItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationErrorLocItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Loc = append(s.Loc, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loc\"")
			}
		case "msg":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Msg = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"msg\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationError) {
					name = jsonFieldsNameOfValidationError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationErrorLocItem as json.
func (s ValidationErrorLocItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringValidationErrorLocItem:
		e.Str(s.String)
	case IntValidationErrorLocItem:
		e.Int(s.Int)
	}
}

// Decode decodes ValidationErrorLocItem from json.
func (s *ValidationErrorLocItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorLocItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntValidationErrorLocItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringValidationErrorLocItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Verification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Verification) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.VerifyProfileID.Set {
			e.FieldStart("verify_profile_id")
			s.VerifyProfileID.Encode(e)
		}
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerification = [9]string{
	0: "id",
	1: "type",
	2: "record_type",
	3: "phone_number",
	4: "verify_profile_id",
	5: "timeout_secs",
	6: "status",
	7: "created_at",
	8: "updated_at",
}

// Decode decodes Verification from json.
func (s *Verification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Verification to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "verify_profile_id":
			if err := func() error {
				s.VerifyProfileID.Reset()
				if err := s.VerifyProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_profile_id\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Verification")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Verification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Verification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerificationProfileRecordType as json.
func (s VerificationProfileRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerificationProfileRecordType from json.
func (s *VerificationProfileRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerificationProfileRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerificationProfileRecordType(v) {
	case VerificationProfileRecordTypeVerificationProfile:
		*s = VerificationProfileRecordTypeVerificationProfile
	default:
		*s = VerificationProfileRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerificationProfileRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerificationProfileRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerificationRecordType as json.
func (s VerificationRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerificationRecordType from json.
func (s *VerificationRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerificationRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerificationRecordType(v) {
	case VerificationRecordTypeVerification:
		*s = VerificationRecordTypeVerification
	default:
		*s = VerificationRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerificationRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerificationRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerificationStatus as json.
func (s VerificationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerificationStatus from json.
func (s *VerificationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerificationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerificationStatus(v) {
	case VerificationStatusPending:
		*s = VerificationStatusPending
	case VerificationStatusAccepted:
		*s = VerificationStatusAccepted
	case VerificationStatusInvalid:
		*s = VerificationStatusInvalid
	case VerificationStatusExpired:
		*s = VerificationStatusExpired
	case VerificationStatusError:
		*s = VerificationStatusError
	default:
		*s = VerificationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerificationType as json.
func (s VerificationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerificationType from json.
func (s *VerificationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerificationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerificationType(v) {
	case VerificationTypeSMS:
		*s = VerificationTypeSMS
	case VerificationTypeCall:
		*s = VerificationTypeCall
	case VerificationTypeFlashcall:
		*s = VerificationTypeFlashcall
	default:
		*s = VerificationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifiedCallsDisplayProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifiedCallsDisplayProfile) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("display_name")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.LogoURL.Set {
			e.FieldStart("logo_url")
			s.LogoURL.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.BusinessIdentity.Set {
			e.FieldStart("business_identity")
			s.BusinessIdentity.Encode(e)
		}
	}
	{
		if s.PhoneNumbers != nil {
			e.FieldStart("phone_numbers")
			e.ArrStart()
			for _, elem := range s.PhoneNumbers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CallReasons != nil {
			e.FieldStart("call_reasons")
			e.ArrStart()
			for _, elem := range s.CallReasons {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifiedCallsDisplayProfile = [11]string{
	0:  "record_type",
	1:  "id",
	2:  "name",
	3:  "display_name",
	4:  "logo_url",
	5:  "status",
	6:  "business_identity",
	7:  "phone_numbers",
	8:  "call_reasons",
	9:  "created_at",
	10: "updated_at",
}

// Decode decodes VerifiedCallsDisplayProfile from json.
func (s *VerifiedCallsDisplayProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedCallsDisplayProfile to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "logo_url":
			if err := func() error {
				s.LogoURL.Reset()
				if err := s.LogoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logo_url\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "business_identity":
			if err := func() error {
				s.BusinessIdentity.Reset()
				if err := s.BusinessIdentity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_identity\"")
			}
		case "phone_numbers":
			if err := func() error {
				s.PhoneNumbers = make([]VerifiedCallsDisplayProfilePhoneNumbersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VerifiedCallsDisplayProfilePhoneNumbersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PhoneNumbers = append(s.PhoneNumbers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_numbers\"")
			}
		case "call_reasons":
			if err := func() error {
				s.CallReasons = make([]VerifiedCallsDisplayProfileCallReasonsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VerifiedCallsDisplayProfileCallReasonsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CallReasons = append(s.CallReasons, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_reasons\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifiedCallsDisplayProfile")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifiedCallsDisplayProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedCallsDisplayProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifiedCallsDisplayProfileBusinessIdentity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifiedCallsDisplayProfileBusinessIdentity) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifiedCallsDisplayProfileBusinessIdentity = [2]string{
	0: "record_type",
	1: "name",
}

// Decode decodes VerifiedCallsDisplayProfileBusinessIdentity from json.
func (s *VerifiedCallsDisplayProfileBusinessIdentity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedCallsDisplayProfileBusinessIdentity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifiedCallsDisplayProfileBusinessIdentity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifiedCallsDisplayProfileBusinessIdentity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedCallsDisplayProfileBusinessIdentity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifiedCallsDisplayProfileCallReasonsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifiedCallsDisplayProfileCallReasonsItem) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.GoogleVerificationStatus.Set {
			e.FieldStart("google_verification_status")
			s.GoogleVerificationStatus.Encode(e)
		}
	}
	{
		if s.GoogleApprovalInfo.Set {
			e.FieldStart("google_approval_info")
			s.GoogleApprovalInfo.Encode(e)
		}
	}
	{
		if s.DisplayProfileID.Set {
			e.FieldStart("display_profile_id")
			s.DisplayProfileID.Encode(e)
		}
	}
	{
		if s.Delete.Set {
			e.FieldStart("delete")
			s.Delete.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifiedCallsDisplayProfileCallReasonsItem = [7]string{
	0: "record_type",
	1: "id",
	2: "reason",
	3: "google_verification_status",
	4: "google_approval_info",
	5: "display_profile_id",
	6: "delete",
}

// Decode decodes VerifiedCallsDisplayProfileCallReasonsItem from json.
func (s *VerifiedCallsDisplayProfileCallReasonsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedCallsDisplayProfileCallReasonsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "google_verification_status":
			if err := func() error {
				s.GoogleVerificationStatus.Reset()
				if err := s.GoogleVerificationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_verification_status\"")
			}
		case "google_approval_info":
			if err := func() error {
				s.GoogleApprovalInfo.Reset()
				if err := s.GoogleApprovalInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_approval_info\"")
			}
		case "display_profile_id":
			if err := func() error {
				s.DisplayProfileID.Reset()
				if err := s.DisplayProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_profile_id\"")
			}
		case "delete":
			if err := func() error {
				s.Delete.Reset()
				if err := s.Delete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifiedCallsDisplayProfileCallReasonsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifiedCallsDisplayProfileCallReasonsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedCallsDisplayProfileCallReasonsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus as json.
func (s VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus from json.
func (s *VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus(v) {
	case VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusSTATEUNSPECIFIED:
		*s = VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusSTATEUNSPECIFIED
	case VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusPENDINGAPPROVAL:
		*s = VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusPENDINGAPPROVAL
	case VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusAPPROVED:
		*s = VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusAPPROVED
	case VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusDENIED:
		*s = VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusDENIED
	case VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusPENDINGREMOVAL:
		*s = VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatusPENDINGREMOVAL
	default:
		*s = VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedCallsDisplayProfileCallReasonsItemGoogleVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifiedCallsDisplayProfilePhoneNumbersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifiedCallsDisplayProfilePhoneNumbersItem) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.GoogleVerificationStatus.Set {
			e.FieldStart("google_verification_status")
			s.GoogleVerificationStatus.Encode(e)
		}
	}
	{
		if s.GoogleApprovalInfo.Set {
			e.FieldStart("google_approval_info")
			s.GoogleApprovalInfo.Encode(e)
		}
	}
	{
		if s.DisplayProfileID.Set {
			e.FieldStart("display_profile_id")
			s.DisplayProfileID.Encode(e)
		}
	}
	{
		if s.Delete.Set {
			e.FieldStart("delete")
			s.Delete.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifiedCallsDisplayProfilePhoneNumbersItem = [7]string{
	0: "record_type",
	1: "id",
	2: "phone_number",
	3: "google_verification_status",
	4: "google_approval_info",
	5: "display_profile_id",
	6: "delete",
}

// Decode decodes VerifiedCallsDisplayProfilePhoneNumbersItem from json.
func (s *VerifiedCallsDisplayProfilePhoneNumbersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedCallsDisplayProfilePhoneNumbersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "google_verification_status":
			if err := func() error {
				s.GoogleVerificationStatus.Reset()
				if err := s.GoogleVerificationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_verification_status\"")
			}
		case "google_approval_info":
			if err := func() error {
				s.GoogleApprovalInfo.Reset()
				if err := s.GoogleApprovalInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"google_approval_info\"")
			}
		case "display_profile_id":
			if err := func() error {
				s.DisplayProfileID.Reset()
				if err := s.DisplayProfileID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_profile_id\"")
			}
		case "delete":
			if err := func() error {
				s.Delete.Reset()
				if err := s.Delete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifiedCallsDisplayProfilePhoneNumbersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifiedCallsDisplayProfilePhoneNumbersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedCallsDisplayProfilePhoneNumbersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus as json.
func (s VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus from json.
func (s *VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus(v) {
	case VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusSTATEUNSPECIFIED:
		*s = VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusSTATEUNSPECIFIED
	case VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusPENDINGAPPROVAL:
		*s = VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusPENDINGAPPROVAL
	case VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusAPPROVED:
		*s = VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusAPPROVED
	case VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusDENIED:
		*s = VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusDENIED
	case VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusPENDINGREMOVAL:
		*s = VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatusPENDINGREMOVAL
	default:
		*s = VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedCallsDisplayProfilePhoneNumbersItemGoogleVerificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedCallsDisplayProfileStatus as json.
func (s VerifiedCallsDisplayProfileStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerifiedCallsDisplayProfileStatus from json.
func (s *VerifiedCallsDisplayProfileStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedCallsDisplayProfileStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerifiedCallsDisplayProfileStatus(v) {
	case VerifiedCallsDisplayProfileStatusVERIFICATIONSTATEUNSPECIFIED:
		*s = VerifiedCallsDisplayProfileStatusVERIFICATIONSTATEUNSPECIFIED
	case VerifiedCallsDisplayProfileStatusVERIFICATIONSTATEUNVERIFIED:
		*s = VerifiedCallsDisplayProfileStatusVERIFICATIONSTATEUNVERIFIED
	case VerifiedCallsDisplayProfileStatusVERIFICATIONSTATEPENDING:
		*s = VerifiedCallsDisplayProfileStatusVERIFICATIONSTATEPENDING
	case VerifiedCallsDisplayProfileStatusVERIFICATIONSTATEVERIFIED:
		*s = VerifiedCallsDisplayProfileStatusVERIFICATIONSTATEVERIFIED
	case VerifiedCallsDisplayProfileStatusVERIFICATIONSTATESUSPENDEDINGMB:
		*s = VerifiedCallsDisplayProfileStatusVERIFICATIONSTATESUSPENDEDINGMB
	default:
		*s = VerifiedCallsDisplayProfileStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerifiedCallsDisplayProfileStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedCallsDisplayProfileStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifiedNumberRecordType as json.
func (s VerifiedNumberRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerifiedNumberRecordType from json.
func (s *VerifiedNumberRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedNumberRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerifiedNumberRecordType(v) {
	case VerifiedNumberRecordTypeVerifiedNumber:
		*s = VerifiedNumberRecordTypeVerifiedNumber
	default:
		*s = VerifiedNumberRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerifiedNumberRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedNumberRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifiedNumberResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifiedNumberResponse) encodeFields(e *jx.Encoder) {
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.VerifiedAt.Set {
			e.FieldStart("verified_at")
			s.VerifiedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifiedNumberResponse = [3]string{
	0: "phone_number",
	1: "record_type",
	2: "verified_at",
}

// Decode decodes VerifiedNumberResponse from json.
func (s *VerifiedNumberResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedNumberResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "verified_at":
			if err := func() error {
				s.VerifiedAt.Reset()
				if err := s.VerifiedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifiedNumberResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifiedNumberResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedNumberResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifiedNumberResponseDataWrapper) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifiedNumberResponseDataWrapper) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifiedNumberResponseDataWrapper = [1]string{
	0: "data",
}

// Decode decodes VerifiedNumberResponseDataWrapper from json.
func (s *VerifiedNumberResponseDataWrapper) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedNumberResponseDataWrapper to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifiedNumberResponseDataWrapper")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifiedNumberResponseDataWrapper) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedNumberResponseDataWrapper) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyProfileCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyProfileCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.MessagingTemplateID.Set {
			e.FieldStart("messaging_template_id")
			s.MessagingTemplateID.Encode(e)
		}
	}
	{
		if s.AppName.Set {
			e.FieldStart("app_name")
			s.AppName.Encode(e)
		}
	}
	{
		if s.WhitelistedDestinations != nil {
			e.FieldStart("whitelisted_destinations")
			e.ArrStart()
			for _, elem := range s.WhitelistedDestinations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifyProfileCallResponse = [4]string{
	0: "messaging_template_id",
	1: "app_name",
	2: "whitelisted_destinations",
	3: "default_verification_timeout_secs",
}

// Decode decodes VerifyProfileCallResponse from json.
func (s *VerifyProfileCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyProfileCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messaging_template_id":
			if err := func() error {
				s.MessagingTemplateID.Reset()
				if err := s.MessagingTemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_template_id\"")
			}
		case "app_name":
			if err := func() error {
				s.AppName.Reset()
				if err := s.AppName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_name\"")
			}
		case "whitelisted_destinations":
			if err := func() error {
				s.WhitelistedDestinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedDestinations = append(s.WhitelistedDestinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_destinations\"")
			}
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyProfileCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyProfileCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyProfileCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyProfileFlashcallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyProfileFlashcallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifyProfileFlashcallResponse = [1]string{
	0: "default_verification_timeout_secs",
}

// Decode decodes VerifyProfileFlashcallResponse from json.
func (s *VerifyProfileFlashcallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyProfileFlashcallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyProfileFlashcallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyProfileFlashcallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyProfileFlashcallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyProfileMessageTemplateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyProfileMessageTemplateResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifyProfileMessageTemplateResponse = [2]string{
	0: "id",
	1: "text",
}

// Decode decodes VerifyProfileMessageTemplateResponse from json.
func (s *VerifyProfileMessageTemplateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyProfileMessageTemplateResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyProfileMessageTemplateResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyProfileMessageTemplateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyProfileMessageTemplateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyProfileResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyProfileResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookFailoverURL.Set {
			e.FieldStart("webhook_failover_url")
			s.WebhookFailoverURL.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.SMS.Set {
			e.FieldStart("sms")
			s.SMS.Encode(e)
		}
	}
	{
		if s.Call.Set {
			e.FieldStart("call")
			s.Call.Encode(e)
		}
	}
	{
		if s.Flashcall.Set {
			e.FieldStart("flashcall")
			s.Flashcall.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifyProfileResponse = [11]string{
	0:  "id",
	1:  "name",
	2:  "webhook_url",
	3:  "webhook_failover_url",
	4:  "record_type",
	5:  "created_at",
	6:  "updated_at",
	7:  "sms",
	8:  "call",
	9:  "flashcall",
	10: "language",
}

// Decode decodes VerifyProfileResponse from json.
func (s *VerifyProfileResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyProfileResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_failover_url":
			if err := func() error {
				s.WebhookFailoverURL.Reset()
				if err := s.WebhookFailoverURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_failover_url\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "sms":
			if err := func() error {
				s.SMS.Reset()
				if err := s.SMS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms\"")
			}
		case "call":
			if err := func() error {
				s.Call.Reset()
				if err := s.Call.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call\"")
			}
		case "flashcall":
			if err := func() error {
				s.Flashcall.Reset()
				if err := s.Flashcall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flashcall\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyProfileResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyProfileResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyProfileResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyProfileResponseDataWrapper) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyProfileResponseDataWrapper) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifyProfileResponseDataWrapper = [1]string{
	0: "data",
}

// Decode decodes VerifyProfileResponseDataWrapper from json.
func (s *VerifyProfileResponseDataWrapper) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyProfileResponseDataWrapper to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyProfileResponseDataWrapper")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyProfileResponseDataWrapper) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyProfileResponseDataWrapper) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyProfileSMSResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyProfileSMSResponse) encodeFields(e *jx.Encoder) {
	{
		if s.MessagingTemplateID.Set {
			e.FieldStart("messaging_template_id")
			s.MessagingTemplateID.Encode(e)
		}
	}
	{
		if s.AppName.Set {
			e.FieldStart("app_name")
			s.AppName.Encode(e)
		}
	}
	{
		if s.AlphaSender.Set {
			e.FieldStart("alpha_sender")
			s.AlphaSender.Encode(e)
		}
	}
	{
		if s.WhitelistedDestinations != nil {
			e.FieldStart("whitelisted_destinations")
			e.ArrStart()
			for _, elem := range s.WhitelistedDestinations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultVerificationTimeoutSecs.Set {
			e.FieldStart("default_verification_timeout_secs")
			s.DefaultVerificationTimeoutSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifyProfileSMSResponse = [5]string{
	0: "messaging_template_id",
	1: "app_name",
	2: "alpha_sender",
	3: "whitelisted_destinations",
	4: "default_verification_timeout_secs",
}

// Decode decodes VerifyProfileSMSResponse from json.
func (s *VerifyProfileSMSResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyProfileSMSResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messaging_template_id":
			if err := func() error {
				s.MessagingTemplateID.Reset()
				if err := s.MessagingTemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messaging_template_id\"")
			}
		case "app_name":
			if err := func() error {
				s.AppName.Reset()
				if err := s.AppName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_name\"")
			}
		case "alpha_sender":
			if err := func() error {
				s.AlphaSender.Reset()
				if err := s.AlphaSender.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpha_sender\"")
			}
		case "whitelisted_destinations":
			if err := func() error {
				s.WhitelistedDestinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedDestinations = append(s.WhitelistedDestinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_destinations\"")
			}
		case "default_verification_timeout_secs":
			if err := func() error {
				s.DefaultVerificationTimeoutSecs.Reset()
				if err := s.DefaultVerificationTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_verification_timeout_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyProfileSMSResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyProfileSMSResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyProfileSMSResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifyVerificationCodeNotFound as json.
func (s *VerifyVerificationCodeNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Errors)(s)

	unwrapped.Encode(e)
}

// Decode decodes VerifyVerificationCodeNotFound from json.
func (s *VerifyVerificationCodeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyVerificationCodeNotFound to nil")
	}
	var unwrapped Errors
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VerifyVerificationCodeNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyVerificationCodeNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyVerificationCodeNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyVerificationCodeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyVerificationCodeReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("verification_code")
		e.Str(s.VerificationCode)
	}
}

var jsonFieldsNameOfVerifyVerificationCodeReq = [1]string{
	0: "verification_code",
}

// Decode decodes VerifyVerificationCodeReq from json.
func (s *VerifyVerificationCodeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyVerificationCodeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verification_code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VerificationCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyVerificationCodeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyVerificationCodeReq) {
					name = jsonFieldsNameOfVerifyVerificationCodeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyVerificationCodeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyVerificationCodeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyVerificationCodeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyVerificationCodeRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("verify_profile_id")
		json.EncodeUUID(e, s.VerifyProfileID)
	}
}

var jsonFieldsNameOfVerifyVerificationCodeRequest = [2]string{
	0: "code",
	1: "verify_profile_id",
}

// Decode decodes VerifyVerificationCodeRequest from json.
func (s *VerifyVerificationCodeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyVerificationCodeRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "verify_profile_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VerifyProfileID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_profile_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyVerificationCodeRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyVerificationCodeRequest) {
					name = jsonFieldsNameOfVerifyVerificationCodeRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyVerificationCodeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyVerificationCodeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyVerificationCodeResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyVerificationCodeResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfVerifyVerificationCodeResponse = [1]string{
	0: "data",
}

// Decode decodes VerifyVerificationCodeResponse from json.
func (s *VerifyVerificationCodeResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyVerificationCodeResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyVerificationCodeResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyVerificationCodeResponse) {
					name = jsonFieldsNameOfVerifyVerificationCodeResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyVerificationCodeResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyVerificationCodeResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyVerificationCodeResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyVerificationCodeResponseData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("response_code")
		s.ResponseCode.Encode(e)
	}
}

var jsonFieldsNameOfVerifyVerificationCodeResponseData = [2]string{
	0: "phone_number",
	1: "response_code",
}

// Decode decodes VerifyVerificationCodeResponseData from json.
func (s *VerifyVerificationCodeResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyVerificationCodeResponseData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "response_code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ResponseCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyVerificationCodeResponseData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyVerificationCodeResponseData) {
					name = jsonFieldsNameOfVerifyVerificationCodeResponseData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyVerificationCodeResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyVerificationCodeResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifyVerificationCodeResponseDataResponseCode as json.
func (s VerifyVerificationCodeResponseDataResponseCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VerifyVerificationCodeResponseDataResponseCode from json.
func (s *VerifyVerificationCodeResponseDataResponseCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyVerificationCodeResponseDataResponseCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VerifyVerificationCodeResponseDataResponseCode(v) {
	case VerifyVerificationCodeResponseDataResponseCodeAccepted:
		*s = VerifyVerificationCodeResponseDataResponseCodeAccepted
	case VerifyVerificationCodeResponseDataResponseCodeRejected:
		*s = VerifyVerificationCodeResponseDataResponseCodeRejected
	default:
		*s = VerifyVerificationCodeResponseDataResponseCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VerifyVerificationCodeResponseDataResponseCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyVerificationCodeResponseDataResponseCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VerifyVerificationCodeUnauthorized as json.
func (s *VerifyVerificationCodeUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Errors)(s)

	unwrapped.Encode(e)
}

// Decode decodes VerifyVerificationCodeUnauthorized from json.
func (s *VerifyVerificationCodeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyVerificationCodeUnauthorized to nil")
	}
	var unwrapped Errors
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VerifyVerificationCodeUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyVerificationCodeUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyVerificationCodeUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookDelivery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookDelivery) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Webhook.Set {
			e.FieldStart("webhook")
			s.Webhook.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Attempts != nil {
			e.FieldStart("attempts")
			e.ArrStart()
			for _, elem := range s.Attempts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWebhookDelivery = [8]string{
	0: "id",
	1: "user_id",
	2: "record_type",
	3: "status",
	4: "webhook",
	5: "started_at",
	6: "finished_at",
	7: "attempts",
}

// Decode decodes WebhookDelivery from json.
func (s *WebhookDelivery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookDelivery to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "webhook":
			if err := func() error {
				s.Webhook.Reset()
				if err := s.Webhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		case "attempts":
			if err := func() error {
				s.Attempts = make([]Attempt, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Attempt
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Attempts = append(s.Attempts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attempts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookDelivery")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookDelivery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookDelivery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDeliveryStatus as json.
func (s WebhookDeliveryStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookDeliveryStatus from json.
func (s *WebhookDeliveryStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookDeliveryStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookDeliveryStatus(v) {
	case WebhookDeliveryStatusDelivered:
		*s = WebhookDeliveryStatusDelivered
	case WebhookDeliveryStatusFailed:
		*s = WebhookDeliveryStatusFailed
	default:
		*s = WebhookDeliveryStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookDeliveryStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookDeliveryStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookDeliveryWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookDeliveryWebhook) encodeFields(e *jx.Encoder) {
	{
		if s.RecordType.Set {
			e.FieldStart("record_type")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.EventType.Set {
			e.FieldStart("event_type")
			s.EventType.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.OccurredAt.Set {
			e.FieldStart("occurred_at")
			s.OccurredAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Payload.Set {
			e.FieldStart("payload")
			s.Payload.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookDeliveryWebhook = [5]string{
	0: "record_type",
	1: "event_type",
	2: "id",
	3: "occurred_at",
	4: "payload",
}

// Decode decodes WebhookDeliveryWebhook from json.
func (s *WebhookDeliveryWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookDeliveryWebhook to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "event_type":
			if err := func() error {
				s.EventType.Reset()
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "occurred_at":
			if err := func() error {
				s.OccurredAt.Reset()
				if err := s.OccurredAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"occurred_at\"")
			}
		case "payload":
			if err := func() error {
				s.Payload.Reset()
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookDeliveryWebhook")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookDeliveryWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookDeliveryWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s WebhookDeliveryWebhookPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s WebhookDeliveryWebhookPayload) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes WebhookDeliveryWebhookPayload from json.
func (s *WebhookDeliveryWebhookPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookDeliveryWebhookPayload to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookDeliveryWebhookPayload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookDeliveryWebhookPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookDeliveryWebhookPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDeliveryWebhookRecordType as json.
func (s WebhookDeliveryWebhookRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookDeliveryWebhookRecordType from json.
func (s *WebhookDeliveryWebhookRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookDeliveryWebhookRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookDeliveryWebhookRecordType(v) {
	case WebhookDeliveryWebhookRecordTypeEvent:
		*s = WebhookDeliveryWebhookRecordTypeEvent
	default:
		*s = WebhookDeliveryWebhookRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookDeliveryWebhookRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookDeliveryWebhookRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
