// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"net/url"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes AccountSid as json.
func (s AccountSid) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AccountSid from json.
func (s *AccountSid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountSid to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AccountSid(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerRequest) encodeFields(e *jx.Encoder) {
	{
		if s.BillingGroupID.Set {
			e.FieldStart("billing_group_id")
			s.BillingGroupID.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.CustomHeaders != nil {
			e.FieldStart("custom_headers")
			e.ArrStart()
			for _, elem := range s.CustomHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PreferredCodecs.Set {
			e.FieldStart("preferred_codecs")
			s.PreferredCodecs.Encode(e)
		}
	}
	{
		if s.SipHeaders != nil {
			e.FieldStart("sip_headers")
			e.ArrStart()
			for _, elem := range s.SipHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SoundModifications.Set {
			e.FieldStart("sound_modifications")
			s.SoundModifications.Encode(e)
		}
	}
	{
		if s.StreamURL.Set {
			e.FieldStart("stream_url")
			s.StreamURL.Encode(e)
		}
	}
	{
		if s.StreamTrack.Set {
			e.FieldStart("stream_track")
			s.StreamTrack.Encode(e)
		}
	}
	{
		if s.SendSilenceWhenIdle.Set {
			e.FieldStart("send_silence_when_idle")
			s.SendSilenceWhenIdle.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookURLMethod.Set {
			e.FieldStart("webhook_url_method")
			s.WebhookURLMethod.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerRequest = [12]string{
	0:  "billing_group_id",
	1:  "client_state",
	2:  "command_id",
	3:  "custom_headers",
	4:  "preferred_codecs",
	5:  "sip_headers",
	6:  "sound_modifications",
	7:  "stream_url",
	8:  "stream_track",
	9:  "send_silence_when_idle",
	10: "webhook_url",
	11: "webhook_url_method",
}

// Decode decodes AnswerRequest from json.
func (s *AnswerRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_group_id":
			if err := func() error {
				s.BillingGroupID.Reset()
				if err := s.BillingGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_group_id\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "custom_headers":
			if err := func() error {
				s.CustomHeaders = make([]CustomSipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomSipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomHeaders = append(s.CustomHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_headers\"")
			}
		case "preferred_codecs":
			if err := func() error {
				s.PreferredCodecs.Reset()
				if err := s.PreferredCodecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_codecs\"")
			}
		case "sip_headers":
			if err := func() error {
				s.SipHeaders = make([]SipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SipHeaders = append(s.SipHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_headers\"")
			}
		case "sound_modifications":
			if err := func() error {
				s.SoundModifications.Reset()
				if err := s.SoundModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sound_modifications\"")
			}
		case "stream_url":
			if err := func() error {
				s.StreamURL.Reset()
				if err := s.StreamURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_url\"")
			}
		case "stream_track":
			if err := func() error {
				s.StreamTrack.Reset()
				if err := s.StreamTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_track\"")
			}
		case "send_silence_when_idle":
			if err := func() error {
				s.SendSilenceWhenIdle.Reset()
				if err := s.SendSilenceWhenIdle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_silence_when_idle\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_url_method":
			if err := func() error {
				s.WebhookURLMethod.Reset()
				if err := s.WebhookURLMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url_method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestPreferredCodecs as json.
func (s AnswerRequestPreferredCodecs) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnswerRequestPreferredCodecs from json.
func (s *AnswerRequestPreferredCodecs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerRequestPreferredCodecs to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnswerRequestPreferredCodecs(v) {
	case AnswerRequestPreferredCodecsG722PCMUPCMAG729OPUSVP8H264:
		*s = AnswerRequestPreferredCodecsG722PCMUPCMAG729OPUSVP8H264
	default:
		*s = AnswerRequestPreferredCodecs(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnswerRequestPreferredCodecs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerRequestPreferredCodecs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestStreamTrack as json.
func (s AnswerRequestStreamTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnswerRequestStreamTrack from json.
func (s *AnswerRequestStreamTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerRequestStreamTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnswerRequestStreamTrack(v) {
	case AnswerRequestStreamTrackInboundTrack:
		*s = AnswerRequestStreamTrackInboundTrack
	case AnswerRequestStreamTrackOutboundTrack:
		*s = AnswerRequestStreamTrackOutboundTrack
	case AnswerRequestStreamTrackBothTracks:
		*s = AnswerRequestStreamTrackBothTracks
	default:
		*s = AnswerRequestStreamTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnswerRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestWebhookURLMethod as json.
func (s AnswerRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnswerRequestWebhookURLMethod from json.
func (s *AnswerRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerRequestWebhookURLMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnswerRequestWebhookURLMethod(v) {
	case AnswerRequestWebhookURLMethodPOST:
		*s = AnswerRequestWebhookURLMethodPOST
	case AnswerRequestWebhookURLMethodGET:
		*s = AnswerRequestWebhookURLMethodGET
	default:
		*s = AnswerRequestWebhookURLMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnswerRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BridgeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BridgeRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("call_control_id")
		e.Str(s.CallControlID)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.Queue.Set {
			e.FieldStart("queue")
			s.Queue.Encode(e)
		}
	}
	{
		if s.VideoRoomID.Set {
			e.FieldStart("video_room_id")
			s.VideoRoomID.Encode(e)
		}
	}
	{
		if s.VideoRoomContext.Set {
			e.FieldStart("video_room_context")
			s.VideoRoomContext.Encode(e)
		}
	}
	{
		if s.ParkAfterUnbridge.Set {
			e.FieldStart("park_after_unbridge")
			s.ParkAfterUnbridge.Encode(e)
		}
	}
	{
		if s.PlayRingtone.Set {
			e.FieldStart("play_ringtone")
			s.PlayRingtone.Encode(e)
		}
	}
}

var jsonFieldsNameOfBridgeRequest = [8]string{
	0: "call_control_id",
	1: "client_state",
	2: "command_id",
	3: "queue",
	4: "video_room_id",
	5: "video_room_context",
	6: "park_after_unbridge",
	7: "play_ringtone",
}

// Decode decodes BridgeRequest from json.
func (s *BridgeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BridgeRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "call_control_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CallControlID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_control_id\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "queue":
			if err := func() error {
				s.Queue.Reset()
				if err := s.Queue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue\"")
			}
		case "video_room_id":
			if err := func() error {
				s.VideoRoomID.Reset()
				if err := s.VideoRoomID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_room_id\"")
			}
		case "video_room_context":
			if err := func() error {
				s.VideoRoomContext.Reset()
				if err := s.VideoRoomContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"video_room_context\"")
			}
		case "park_after_unbridge":
			if err := func() error {
				s.ParkAfterUnbridge.Reset()
				if err := s.ParkAfterUnbridge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"park_after_unbridge\"")
			}
		case "play_ringtone":
			if err := func() error {
				s.PlayRingtone.Reset()
				if err := s.PlayRingtone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"play_ringtone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BridgeRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBridgeRequest) {
					name = jsonFieldsNameOfBridgeRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BridgeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BridgeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Call) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Call) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("record_type")
		s.RecordType.Encode(e)
	}
	{
		e.FieldStart("call_session_id")
		e.Str(s.CallSessionID)
	}
	{
		e.FieldStart("call_leg_id")
		e.Str(s.CallLegID)
	}
	{
		e.FieldStart("call_control_id")
		e.Str(s.CallControlID)
	}
	{
		e.FieldStart("is_alive")
		e.Bool(s.IsAlive)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CallDuration.Set {
			e.FieldStart("call_duration")
			s.CallDuration.Encode(e)
		}
	}
}

var jsonFieldsNameOfCall = [7]string{
	0: "record_type",
	1: "call_session_id",
	2: "call_leg_id",
	3: "call_control_id",
	4: "is_alive",
	5: "client_state",
	6: "call_duration",
}

// Decode decodes Call from json.
func (s *Call) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Call to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "call_session_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CallSessionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_session_id\"")
			}
		case "call_leg_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CallLegID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_leg_id\"")
			}
		case "call_control_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CallControlID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_control_id\"")
			}
		case "is_alive":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsAlive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_alive\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "call_duration":
			if err := func() error {
				s.CallDuration.Reset()
				if err := s.CallDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Call")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCall) {
					name = jsonFieldsNameOfCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Call) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Call) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallControlCommandResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallControlCommandResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallControlCommandResponse = [1]string{
	0: "data",
}

// Decode decodes CallControlCommandResponse from json.
func (s *CallControlCommandResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlCommandResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallControlCommandResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallControlCommandResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlCommandResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallControlCommandResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallControlCommandResult) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallControlCommandResult = [1]string{
	0: "result",
}

// Decode decodes CallControlCommandResult from json.
func (s *CallControlCommandResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlCommandResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallControlCommandResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallControlCommandResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlCommandResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlId as json.
func (s CallControlId) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CallControlId from json.
func (s *CallControlId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallControlId to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CallControlId(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallControlId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallControlId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRecordType as json.
func (s CallRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRecordType from json.
func (s *CallRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRecordType(v) {
	case CallRecordTypeCall:
		*s = CallRecordTypeCall
	default:
		*s = CallRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("to")
		s.To.Encode(e)
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		if s.FromDisplayName.Set {
			e.FieldStart("from_display_name")
			s.FromDisplayName.Encode(e)
		}
	}
	{
		e.FieldStart("connection_id")
		e.Str(s.ConnectionID)
	}
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		if s.MediaName.Set {
			e.FieldStart("media_name")
			s.MediaName.Encode(e)
		}
	}
	{
		if s.PreferredCodecs.Set {
			e.FieldStart("preferred_codecs")
			s.PreferredCodecs.Encode(e)
		}
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
	{
		if s.TimeLimitSecs.Set {
			e.FieldStart("time_limit_secs")
			s.TimeLimitSecs.Encode(e)
		}
	}
	{
		if s.AnsweringMachineDetection.Set {
			e.FieldStart("answering_machine_detection")
			s.AnsweringMachineDetection.Encode(e)
		}
	}
	{
		if s.AnsweringMachineDetectionConfig.Set {
			e.FieldStart("answering_machine_detection_config")
			s.AnsweringMachineDetectionConfig.Encode(e)
		}
	}
	{
		if s.ConferenceConfig.Set {
			e.FieldStart("conference_config")
			s.ConferenceConfig.Encode(e)
		}
	}
	{
		if s.CustomHeaders != nil {
			e.FieldStart("custom_headers")
			e.ArrStart()
			for _, elem := range s.CustomHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BillingGroupID.Set {
			e.FieldStart("billing_group_id")
			s.BillingGroupID.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.LinkTo.Set {
			e.FieldStart("link_to")
			s.LinkTo.Encode(e)
		}
	}
	{
		if s.MediaEncryption.Set {
			e.FieldStart("media_encryption")
			s.MediaEncryption.Encode(e)
		}
	}
	{
		if s.SipAuthUsername.Set {
			e.FieldStart("sip_auth_username")
			s.SipAuthUsername.Encode(e)
		}
	}
	{
		if s.SipAuthPassword.Set {
			e.FieldStart("sip_auth_password")
			s.SipAuthPassword.Encode(e)
		}
	}
	{
		if s.SipHeaders != nil {
			e.FieldStart("sip_headers")
			e.ArrStart()
			for _, elem := range s.SipHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SipTransportProtocol.Set {
			e.FieldStart("sip_transport_protocol")
			s.SipTransportProtocol.Encode(e)
		}
	}
	{
		if s.SoundModifications.Set {
			e.FieldStart("sound_modifications")
			s.SoundModifications.Encode(e)
		}
	}
	{
		if s.StreamURL.Set {
			e.FieldStart("stream_url")
			s.StreamURL.Encode(e)
		}
	}
	{
		if s.StreamTrack.Set {
			e.FieldStart("stream_track")
			s.StreamTrack.Encode(e)
		}
	}
	{
		if s.SendSilenceWhenIdle.Set {
			e.FieldStart("send_silence_when_idle")
			s.SendSilenceWhenIdle.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookURLMethod.Set {
			e.FieldStart("webhook_url_method")
			s.WebhookURLMethod.Encode(e)
		}
	}
	{
		if s.Record.Set {
			e.FieldStart("record")
			s.Record.Encode(e)
		}
	}
	{
		if s.RecordChannels.Set {
			e.FieldStart("record_channels")
			s.RecordChannels.Encode(e)
		}
	}
	{
		if s.RecordFormat.Set {
			e.FieldStart("record_format")
			s.RecordFormat.Encode(e)
		}
	}
	{
		if s.RecordMaxLength.Set {
			e.FieldStart("record_max_length")
			s.RecordMaxLength.Encode(e)
		}
	}
	{
		if s.RecordTimeoutSecs.Set {
			e.FieldStart("record_timeout_secs")
			s.RecordTimeoutSecs.Encode(e)
		}
	}
	{
		if s.RecordTrim.Set {
			e.FieldStart("record_trim")
			s.RecordTrim.Encode(e)
		}
	}
	{
		if s.RecordCustomFileName.Set {
			e.FieldStart("record_custom_file_name")
			s.RecordCustomFileName.Encode(e)
		}
	}
	{
		if s.EnableDialogflow.Set {
			e.FieldStart("enable_dialogflow")
			s.EnableDialogflow.Encode(e)
		}
	}
	{
		if s.DialogflowConfig.Set {
			e.FieldStart("dialogflow_config")
			s.DialogflowConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallRequest = [37]string{
	0:  "to",
	1:  "from",
	2:  "from_display_name",
	3:  "connection_id",
	4:  "audio_url",
	5:  "media_name",
	6:  "preferred_codecs",
	7:  "timeout_secs",
	8:  "time_limit_secs",
	9:  "answering_machine_detection",
	10: "answering_machine_detection_config",
	11: "conference_config",
	12: "custom_headers",
	13: "billing_group_id",
	14: "client_state",
	15: "command_id",
	16: "link_to",
	17: "media_encryption",
	18: "sip_auth_username",
	19: "sip_auth_password",
	20: "sip_headers",
	21: "sip_transport_protocol",
	22: "sound_modifications",
	23: "stream_url",
	24: "stream_track",
	25: "send_silence_when_idle",
	26: "webhook_url",
	27: "webhook_url_method",
	28: "record",
	29: "record_channels",
	30: "record_format",
	31: "record_max_length",
	32: "record_timeout_secs",
	33: "record_trim",
	34: "record_custom_file_name",
	35: "enable_dialogflow",
	36: "dialogflow_config",
}

// Decode decodes CallRequest from json.
func (s *CallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequest to nil")
	}
	var requiredBitSet [5]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "to":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "from_display_name":
			if err := func() error {
				s.FromDisplayName.Reset()
				if err := s.FromDisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_display_name\"")
			}
		case "connection_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_id\"")
			}
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "media_name":
			if err := func() error {
				s.MediaName.Reset()
				if err := s.MediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_name\"")
			}
		case "preferred_codecs":
			if err := func() error {
				s.PreferredCodecs.Reset()
				if err := s.PreferredCodecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferred_codecs\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		case "time_limit_secs":
			if err := func() error {
				s.TimeLimitSecs.Reset()
				if err := s.TimeLimitSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit_secs\"")
			}
		case "answering_machine_detection":
			if err := func() error {
				s.AnsweringMachineDetection.Reset()
				if err := s.AnsweringMachineDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answering_machine_detection\"")
			}
		case "answering_machine_detection_config":
			if err := func() error {
				s.AnsweringMachineDetectionConfig.Reset()
				if err := s.AnsweringMachineDetectionConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answering_machine_detection_config\"")
			}
		case "conference_config":
			if err := func() error {
				s.ConferenceConfig.Reset()
				if err := s.ConferenceConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_config\"")
			}
		case "custom_headers":
			if err := func() error {
				s.CustomHeaders = make([]CustomSipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomSipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomHeaders = append(s.CustomHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_headers\"")
			}
		case "billing_group_id":
			if err := func() error {
				s.BillingGroupID.Reset()
				if err := s.BillingGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_group_id\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "link_to":
			if err := func() error {
				s.LinkTo.Reset()
				if err := s.LinkTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_to\"")
			}
		case "media_encryption":
			if err := func() error {
				s.MediaEncryption.Reset()
				if err := s.MediaEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_encryption\"")
			}
		case "sip_auth_username":
			if err := func() error {
				s.SipAuthUsername.Reset()
				if err := s.SipAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_username\"")
			}
		case "sip_auth_password":
			if err := func() error {
				s.SipAuthPassword.Reset()
				if err := s.SipAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_password\"")
			}
		case "sip_headers":
			if err := func() error {
				s.SipHeaders = make([]SipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SipHeaders = append(s.SipHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_headers\"")
			}
		case "sip_transport_protocol":
			if err := func() error {
				s.SipTransportProtocol.Reset()
				if err := s.SipTransportProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_transport_protocol\"")
			}
		case "sound_modifications":
			if err := func() error {
				s.SoundModifications.Reset()
				if err := s.SoundModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sound_modifications\"")
			}
		case "stream_url":
			if err := func() error {
				s.StreamURL.Reset()
				if err := s.StreamURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_url\"")
			}
		case "stream_track":
			if err := func() error {
				s.StreamTrack.Reset()
				if err := s.StreamTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_track\"")
			}
		case "send_silence_when_idle":
			if err := func() error {
				s.SendSilenceWhenIdle.Reset()
				if err := s.SendSilenceWhenIdle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_silence_when_idle\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_url_method":
			if err := func() error {
				s.WebhookURLMethod.Reset()
				if err := s.WebhookURLMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url_method\"")
			}
		case "record":
			if err := func() error {
				s.Record.Reset()
				if err := s.Record.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record\"")
			}
		case "record_channels":
			if err := func() error {
				s.RecordChannels.Reset()
				if err := s.RecordChannels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_channels\"")
			}
		case "record_format":
			if err := func() error {
				s.RecordFormat.Reset()
				if err := s.RecordFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_format\"")
			}
		case "record_max_length":
			if err := func() error {
				s.RecordMaxLength.Reset()
				if err := s.RecordMaxLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_max_length\"")
			}
		case "record_timeout_secs":
			if err := func() error {
				s.RecordTimeoutSecs.Reset()
				if err := s.RecordTimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_timeout_secs\"")
			}
		case "record_trim":
			if err := func() error {
				s.RecordTrim.Reset()
				if err := s.RecordTrim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_trim\"")
			}
		case "record_custom_file_name":
			if err := func() error {
				s.RecordCustomFileName.Reset()
				if err := s.RecordCustomFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_custom_file_name\"")
			}
		case "enable_dialogflow":
			if err := func() error {
				s.EnableDialogflow.Reset()
				if err := s.EnableDialogflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_dialogflow\"")
			}
		case "dialogflow_config":
			if err := func() error {
				s.DialogflowConfig.Reset()
				if err := s.DialogflowConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogflow_config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00001011,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCallRequest) {
					name = jsonFieldsNameOfCallRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestAnsweringMachineDetection as json.
func (s CallRequestAnsweringMachineDetection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestAnsweringMachineDetection from json.
func (s *CallRequestAnsweringMachineDetection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestAnsweringMachineDetection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestAnsweringMachineDetection(v) {
	case CallRequestAnsweringMachineDetectionPremium:
		*s = CallRequestAnsweringMachineDetectionPremium
	case CallRequestAnsweringMachineDetectionDetect:
		*s = CallRequestAnsweringMachineDetectionDetect
	case CallRequestAnsweringMachineDetectionDetectBeep:
		*s = CallRequestAnsweringMachineDetectionDetectBeep
	case CallRequestAnsweringMachineDetectionDetectWords:
		*s = CallRequestAnsweringMachineDetectionDetectWords
	case CallRequestAnsweringMachineDetectionGreetingEnd:
		*s = CallRequestAnsweringMachineDetectionGreetingEnd
	case CallRequestAnsweringMachineDetectionDisabled:
		*s = CallRequestAnsweringMachineDetectionDisabled
	default:
		*s = CallRequestAnsweringMachineDetection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestAnsweringMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestAnsweringMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallRequestAnsweringMachineDetectionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallRequestAnsweringMachineDetectionConfig) encodeFields(e *jx.Encoder) {
	{
		if s.TotalAnalysisTimeMillis.Set {
			e.FieldStart("total_analysis_time_millis")
			s.TotalAnalysisTimeMillis.Encode(e)
		}
	}
	{
		if s.AfterGreetingSilenceMillis.Set {
			e.FieldStart("after_greeting_silence_millis")
			s.AfterGreetingSilenceMillis.Encode(e)
		}
	}
	{
		if s.BetweenWordsSilenceMillis.Set {
			e.FieldStart("between_words_silence_millis")
			s.BetweenWordsSilenceMillis.Encode(e)
		}
	}
	{
		if s.GreetingDurationMillis.Set {
			e.FieldStart("greeting_duration_millis")
			s.GreetingDurationMillis.Encode(e)
		}
	}
	{
		if s.InitialSilenceMillis.Set {
			e.FieldStart("initial_silence_millis")
			s.InitialSilenceMillis.Encode(e)
		}
	}
	{
		if s.MaximumNumberOfWords.Set {
			e.FieldStart("maximum_number_of_words")
			s.MaximumNumberOfWords.Encode(e)
		}
	}
	{
		if s.MaximumWordLengthMillis.Set {
			e.FieldStart("maximum_word_length_millis")
			s.MaximumWordLengthMillis.Encode(e)
		}
	}
	{
		if s.SilenceThreshold.Set {
			e.FieldStart("silence_threshold")
			s.SilenceThreshold.Encode(e)
		}
	}
	{
		if s.GreetingTotalAnalysisTimeMillis.Set {
			e.FieldStart("greeting_total_analysis_time_millis")
			s.GreetingTotalAnalysisTimeMillis.Encode(e)
		}
	}
	{
		if s.GreetingSilenceDurationMillis.Set {
			e.FieldStart("greeting_silence_duration_millis")
			s.GreetingSilenceDurationMillis.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallRequestAnsweringMachineDetectionConfig = [10]string{
	0: "total_analysis_time_millis",
	1: "after_greeting_silence_millis",
	2: "between_words_silence_millis",
	3: "greeting_duration_millis",
	4: "initial_silence_millis",
	5: "maximum_number_of_words",
	6: "maximum_word_length_millis",
	7: "silence_threshold",
	8: "greeting_total_analysis_time_millis",
	9: "greeting_silence_duration_millis",
}

// Decode decodes CallRequestAnsweringMachineDetectionConfig from json.
func (s *CallRequestAnsweringMachineDetectionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestAnsweringMachineDetectionConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_analysis_time_millis":
			if err := func() error {
				s.TotalAnalysisTimeMillis.Reset()
				if err := s.TotalAnalysisTimeMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_analysis_time_millis\"")
			}
		case "after_greeting_silence_millis":
			if err := func() error {
				s.AfterGreetingSilenceMillis.Reset()
				if err := s.AfterGreetingSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"after_greeting_silence_millis\"")
			}
		case "between_words_silence_millis":
			if err := func() error {
				s.BetweenWordsSilenceMillis.Reset()
				if err := s.BetweenWordsSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"between_words_silence_millis\"")
			}
		case "greeting_duration_millis":
			if err := func() error {
				s.GreetingDurationMillis.Reset()
				if err := s.GreetingDurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_duration_millis\"")
			}
		case "initial_silence_millis":
			if err := func() error {
				s.InitialSilenceMillis.Reset()
				if err := s.InitialSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_silence_millis\"")
			}
		case "maximum_number_of_words":
			if err := func() error {
				s.MaximumNumberOfWords.Reset()
				if err := s.MaximumNumberOfWords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_number_of_words\"")
			}
		case "maximum_word_length_millis":
			if err := func() error {
				s.MaximumWordLengthMillis.Reset()
				if err := s.MaximumWordLengthMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_word_length_millis\"")
			}
		case "silence_threshold":
			if err := func() error {
				s.SilenceThreshold.Reset()
				if err := s.SilenceThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"silence_threshold\"")
			}
		case "greeting_total_analysis_time_millis":
			if err := func() error {
				s.GreetingTotalAnalysisTimeMillis.Reset()
				if err := s.GreetingTotalAnalysisTimeMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_total_analysis_time_millis\"")
			}
		case "greeting_silence_duration_millis":
			if err := func() error {
				s.GreetingSilenceDurationMillis.Reset()
				if err := s.GreetingSilenceDurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_silence_duration_millis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallRequestAnsweringMachineDetectionConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallRequestAnsweringMachineDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestAnsweringMachineDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallRequestConferenceConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallRequestConferenceConfig) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ConferenceName.Set {
			e.FieldStart("conference_name")
			s.ConferenceName.Encode(e)
		}
	}
	{
		if s.EndConferenceOnExit.Set {
			e.FieldStart("end_conference_on_exit")
			s.EndConferenceOnExit.Encode(e)
		}
	}
	{
		if s.SoftEndConferenceOnExit.Set {
			e.FieldStart("soft_end_conference_on_exit")
			s.SoftEndConferenceOnExit.Encode(e)
		}
	}
	{
		if s.Hold.Set {
			e.FieldStart("hold")
			s.Hold.Encode(e)
		}
	}
	{
		if s.HoldAudioURL.Set {
			e.FieldStart("hold_audio_url")
			s.HoldAudioURL.Encode(e)
		}
	}
	{
		if s.HoldMediaName.Set {
			e.FieldStart("hold_media_name")
			s.HoldMediaName.Encode(e)
		}
	}
	{
		if s.Mute.Set {
			e.FieldStart("mute")
			s.Mute.Encode(e)
		}
	}
	{
		if s.StartConferenceOnEnter.Set {
			e.FieldStart("start_conference_on_enter")
			s.StartConferenceOnEnter.Encode(e)
		}
	}
	{
		if s.StartConferenceOnCreate.Set {
			e.FieldStart("start_conference_on_create")
			s.StartConferenceOnCreate.Encode(e)
		}
	}
	{
		if s.SupervisorRole.Set {
			e.FieldStart("supervisor_role")
			s.SupervisorRole.Encode(e)
		}
	}
	{
		if s.WhisperCallControlIds != nil {
			e.FieldStart("whisper_call_control_ids")
			e.ArrStart()
			for _, elem := range s.WhisperCallControlIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BeepEnabled.Set {
			e.FieldStart("beep_enabled")
			s.BeepEnabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallRequestConferenceConfig = [13]string{
	0:  "id",
	1:  "conference_name",
	2:  "end_conference_on_exit",
	3:  "soft_end_conference_on_exit",
	4:  "hold",
	5:  "hold_audio_url",
	6:  "hold_media_name",
	7:  "mute",
	8:  "start_conference_on_enter",
	9:  "start_conference_on_create",
	10: "supervisor_role",
	11: "whisper_call_control_ids",
	12: "beep_enabled",
}

// Decode decodes CallRequestConferenceConfig from json.
func (s *CallRequestConferenceConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestConferenceConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "conference_name":
			if err := func() error {
				s.ConferenceName.Reset()
				if err := s.ConferenceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_name\"")
			}
		case "end_conference_on_exit":
			if err := func() error {
				s.EndConferenceOnExit.Reset()
				if err := s.EndConferenceOnExit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_conference_on_exit\"")
			}
		case "soft_end_conference_on_exit":
			if err := func() error {
				s.SoftEndConferenceOnExit.Reset()
				if err := s.SoftEndConferenceOnExit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"soft_end_conference_on_exit\"")
			}
		case "hold":
			if err := func() error {
				s.Hold.Reset()
				if err := s.Hold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold\"")
			}
		case "hold_audio_url":
			if err := func() error {
				s.HoldAudioURL.Reset()
				if err := s.HoldAudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold_audio_url\"")
			}
		case "hold_media_name":
			if err := func() error {
				s.HoldMediaName.Reset()
				if err := s.HoldMediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold_media_name\"")
			}
		case "mute":
			if err := func() error {
				s.Mute.Reset()
				if err := s.Mute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mute\"")
			}
		case "start_conference_on_enter":
			if err := func() error {
				s.StartConferenceOnEnter.Reset()
				if err := s.StartConferenceOnEnter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_conference_on_enter\"")
			}
		case "start_conference_on_create":
			if err := func() error {
				s.StartConferenceOnCreate.Reset()
				if err := s.StartConferenceOnCreate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_conference_on_create\"")
			}
		case "supervisor_role":
			if err := func() error {
				s.SupervisorRole.Reset()
				if err := s.SupervisorRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supervisor_role\"")
			}
		case "whisper_call_control_ids":
			if err := func() error {
				s.WhisperCallControlIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhisperCallControlIds = append(s.WhisperCallControlIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whisper_call_control_ids\"")
			}
		case "beep_enabled":
			if err := func() error {
				s.BeepEnabled.Reset()
				if err := s.BeepEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beep_enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallRequestConferenceConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallRequestConferenceConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestConferenceConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfigBeepEnabled as json.
func (s CallRequestConferenceConfigBeepEnabled) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestConferenceConfigBeepEnabled from json.
func (s *CallRequestConferenceConfigBeepEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestConferenceConfigBeepEnabled to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestConferenceConfigBeepEnabled(v) {
	case CallRequestConferenceConfigBeepEnabledAlways:
		*s = CallRequestConferenceConfigBeepEnabledAlways
	case CallRequestConferenceConfigBeepEnabledNever:
		*s = CallRequestConferenceConfigBeepEnabledNever
	case CallRequestConferenceConfigBeepEnabledOnEnter:
		*s = CallRequestConferenceConfigBeepEnabledOnEnter
	case CallRequestConferenceConfigBeepEnabledOnExit:
		*s = CallRequestConferenceConfigBeepEnabledOnExit
	default:
		*s = CallRequestConferenceConfigBeepEnabled(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestConferenceConfigBeepEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestConferenceConfigBeepEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfigSupervisorRole as json.
func (s CallRequestConferenceConfigSupervisorRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestConferenceConfigSupervisorRole from json.
func (s *CallRequestConferenceConfigSupervisorRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestConferenceConfigSupervisorRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestConferenceConfigSupervisorRole(v) {
	case CallRequestConferenceConfigSupervisorRoleBarge:
		*s = CallRequestConferenceConfigSupervisorRoleBarge
	case CallRequestConferenceConfigSupervisorRoleMonitor:
		*s = CallRequestConferenceConfigSupervisorRoleMonitor
	case CallRequestConferenceConfigSupervisorRoleNone:
		*s = CallRequestConferenceConfigSupervisorRoleNone
	case CallRequestConferenceConfigSupervisorRoleWhisper:
		*s = CallRequestConferenceConfigSupervisorRoleWhisper
	default:
		*s = CallRequestConferenceConfigSupervisorRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestConferenceConfigSupervisorRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestConferenceConfigSupervisorRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestMediaEncryption as json.
func (s CallRequestMediaEncryption) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestMediaEncryption from json.
func (s *CallRequestMediaEncryption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestMediaEncryption to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestMediaEncryption(v) {
	case CallRequestMediaEncryptionDisabled:
		*s = CallRequestMediaEncryptionDisabled
	case CallRequestMediaEncryptionSRTP:
		*s = CallRequestMediaEncryptionSRTP
	default:
		*s = CallRequestMediaEncryption(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestMediaEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestMediaEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecord as json.
func (s CallRequestRecord) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestRecord from json.
func (s *CallRequestRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestRecord to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestRecord(v) {
	case CallRequestRecordRecordFromAnswer:
		*s = CallRequestRecordRecordFromAnswer
	default:
		*s = CallRequestRecord(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordChannels as json.
func (s CallRequestRecordChannels) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestRecordChannels from json.
func (s *CallRequestRecordChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestRecordChannels to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestRecordChannels(v) {
	case CallRequestRecordChannelsSingle:
		*s = CallRequestRecordChannelsSingle
	case CallRequestRecordChannelsDual:
		*s = CallRequestRecordChannelsDual
	default:
		*s = CallRequestRecordChannels(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestRecordChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestRecordChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordFormat as json.
func (s CallRequestRecordFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestRecordFormat from json.
func (s *CallRequestRecordFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestRecordFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestRecordFormat(v) {
	case CallRequestRecordFormatWav:
		*s = CallRequestRecordFormatWav
	case CallRequestRecordFormatMp3:
		*s = CallRequestRecordFormatMp3
	default:
		*s = CallRequestRecordFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestRecordFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestRecordFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordTrim as json.
func (s CallRequestRecordTrim) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestRecordTrim from json.
func (s *CallRequestRecordTrim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestRecordTrim to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestRecordTrim(v) {
	case CallRequestRecordTrimTrimSilence:
		*s = CallRequestRecordTrimTrimSilence
	default:
		*s = CallRequestRecordTrim(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestRecordTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestRecordTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestSipTransportProtocol as json.
func (s CallRequestSipTransportProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestSipTransportProtocol from json.
func (s *CallRequestSipTransportProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestSipTransportProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestSipTransportProtocol(v) {
	case CallRequestSipTransportProtocolUDP:
		*s = CallRequestSipTransportProtocolUDP
	case CallRequestSipTransportProtocolTCP:
		*s = CallRequestSipTransportProtocolTCP
	case CallRequestSipTransportProtocolTLS:
		*s = CallRequestSipTransportProtocolTLS
	default:
		*s = CallRequestSipTransportProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestSipTransportProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestSipTransportProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestStreamTrack as json.
func (s CallRequestStreamTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestStreamTrack from json.
func (s *CallRequestStreamTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestStreamTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestStreamTrack(v) {
	case CallRequestStreamTrackInboundTrack:
		*s = CallRequestStreamTrackInboundTrack
	case CallRequestStreamTrackOutboundTrack:
		*s = CallRequestStreamTrackOutboundTrack
	case CallRequestStreamTrackBothTracks:
		*s = CallRequestStreamTrackBothTracks
	default:
		*s = CallRequestStreamTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestTo as json.
func (s CallRequestTo) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringCallRequestTo:
		e.Str(s.String)
	case StringArrayCallRequestTo:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes CallRequestTo from json.
func (s *CallRequestTo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestTo to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayCallRequestTo
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringCallRequestTo
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestTo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestTo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestWebhookURLMethod as json.
func (s CallRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallRequestWebhookURLMethod from json.
func (s *CallRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallRequestWebhookURLMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallRequestWebhookURLMethod(v) {
	case CallRequestWebhookURLMethodPOST:
		*s = CallRequestWebhookURLMethodPOST
	case CallRequestWebhookURLMethodGET:
		*s = CallRequestWebhookURLMethodGET
	default:
		*s = CallRequestWebhookURLMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.AnsweredBy.Set {
			e.FieldStart("answered_by")
			s.AnsweredBy.Encode(e)
		}
	}
	{
		if s.CallerName.Set {
			e.FieldStart("caller_name")
			s.CallerName.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.FromFormatted.Set {
			e.FieldStart("from_formatted")
			s.FromFormatted.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.PriceUnit.Set {
			e.FieldStart("price_unit")
			s.PriceUnit.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
	{
		if s.ToFormatted.Set {
			e.FieldStart("to_formatted")
			s.ToFormatted.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallResource = [18]string{
	0:  "account_sid",
	1:  "answered_by",
	2:  "caller_name",
	3:  "date_created",
	4:  "date_updated",
	5:  "direction",
	6:  "duration",
	7:  "end_time",
	8:  "from",
	9:  "from_formatted",
	10: "price",
	11: "price_unit",
	12: "sid",
	13: "start_time",
	14: "status",
	15: "to",
	16: "to_formatted",
	17: "uri",
}

// Decode decodes CallResource from json.
func (s *CallResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "answered_by":
			if err := func() error {
				s.AnsweredBy.Reset()
				if err := s.AnsweredBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answered_by\"")
			}
		case "caller_name":
			if err := func() error {
				s.CallerName.Reset()
				if err := s.CallerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caller_name\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "from_formatted":
			if err := func() error {
				s.FromFormatted.Reset()
				if err := s.FromFormatted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_formatted\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "price_unit":
			if err := func() error {
				s.PriceUnit.Reset()
				if err := s.PriceUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price_unit\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "to_formatted":
			if err := func() error {
				s.ToFormatted.Reset()
				if err := s.ToFormatted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_formatted\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceAnsweredBy as json.
func (s CallResourceAnsweredBy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallResourceAnsweredBy from json.
func (s *CallResourceAnsweredBy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResourceAnsweredBy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallResourceAnsweredBy(v) {
	case CallResourceAnsweredByHuman:
		*s = CallResourceAnsweredByHuman
	case CallResourceAnsweredByMachine:
		*s = CallResourceAnsweredByMachine
	case CallResourceAnsweredByNotSure:
		*s = CallResourceAnsweredByNotSure
	default:
		*s = CallResourceAnsweredBy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallResourceAnsweredBy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResourceAnsweredBy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceDirection as json.
func (s CallResourceDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallResourceDirection from json.
func (s *CallResourceDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResourceDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallResourceDirection(v) {
	case CallResourceDirectionInbound:
		*s = CallResourceDirectionInbound
	case CallResourceDirectionOutbound:
		*s = CallResourceDirectionOutbound
	default:
		*s = CallResourceDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallResourceDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResourceDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CallResourceIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CallResourceIndex) encodeFields(e *jx.Encoder) {
	{
		if s.Calls != nil {
			e.FieldStart("calls")
			e.ArrStart()
			for _, elem := range s.Calls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfCallResourceIndex = [8]string{
	0: "calls",
	1: "end",
	2: "first_page_uri",
	3: "next_page_uri",
	4: "page",
	5: "page_size",
	6: "start",
	7: "uri",
}

// Decode decodes CallResourceIndex from json.
func (s *CallResourceIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResourceIndex to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "calls":
			if err := func() error {
				s.Calls = make([]CallResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CallResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Calls = append(s.Calls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"calls\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CallResourceIndex")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CallResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceStatus as json.
func (s CallResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CallResourceStatus from json.
func (s *CallResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CallResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CallResourceStatus(v) {
	case CallResourceStatusRinging:
		*s = CallResourceStatusRinging
	case CallResourceStatusInProgress:
		*s = CallResourceStatusInProgress
	case CallResourceStatusCanceled:
		*s = CallResourceStatusCanceled
	case CallResourceStatusCompleted:
		*s = CallResourceStatusCompleted
	case CallResourceStatusFailed:
		*s = CallResourceStatusFailed
	case CallResourceStatusBusy:
		*s = CallResourceStatusBusy
	case CallResourceStatusNoAnswer:
		*s = CallResourceStatusNoAnswer
	default:
		*s = CallResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CallResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CallResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientStateUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientStateUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("client_state")
		e.Str(s.ClientState)
	}
}

var jsonFieldsNameOfClientStateUpdateRequest = [1]string{
	0: "client_state",
}

// Decode decodes ClientStateUpdateRequest from json.
func (s *ClientStateUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientStateUpdateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientState = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientStateUpdateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClientStateUpdateRequest) {
					name = jsonFieldsNameOfClientStateUpdateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientStateUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientStateUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConferenceRecordingResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConferenceRecordingResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.Channels.Set {
			e.FieldStart("channels")
			s.Channels.Encode(e)
		}
	}
	{
		if s.ConferenceSid.Set {
			e.FieldStart("conference_sid")
			s.ConferenceSid.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.MediaURL.Set {
			e.FieldStart("media_url")
			s.MediaURL.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.SubresourceUris.Set {
			e.FieldStart("subresource_uris")
			s.SubresourceUris.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfConferenceRecordingResource = [15]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "channels",
	3:  "conference_sid",
	4:  "date_created",
	5:  "date_updated",
	6:  "duration",
	7:  "error_code",
	8:  "media_url",
	9:  "sid",
	10: "source",
	11: "start_time",
	12: "status",
	13: "subresource_uris",
	14: "uri",
}

// Decode decodes ConferenceRecordingResource from json.
func (s *ConferenceRecordingResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "channels":
			if err := func() error {
				s.Channels.Reset()
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "conference_sid":
			if err := func() error {
				s.ConferenceSid.Reset()
				if err := s.ConferenceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_sid\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "media_url":
			if err := func() error {
				s.MediaURL.Reset()
				if err := s.MediaURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_url\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subresource_uris":
			if err := func() error {
				s.SubresourceUris.Reset()
				if err := s.SubresourceUris.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresource_uris\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceRecordingResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConferenceRecordingResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConferenceRecordingResourceIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConferenceRecordingResourceIndex) encodeFields(e *jx.Encoder) {
	{
		if s.Recordings != nil {
			e.FieldStart("recordings")
			e.ArrStart()
			for _, elem := range s.Recordings {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfConferenceRecordingResourceIndex = [8]string{
	0: "recordings",
	1: "end",
	2: "first_page_uri",
	3: "next_page_uri",
	4: "page",
	5: "page_size",
	6: "start",
	7: "uri",
}

// Decode decodes ConferenceRecordingResourceIndex from json.
func (s *ConferenceRecordingResourceIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResourceIndex to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recordings":
			if err := func() error {
				s.Recordings = make([]ConferenceRecordingResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConferenceRecordingResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Recordings = append(s.Recordings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordings\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceRecordingResourceIndex")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConferenceRecordingResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceSource as json.
func (s ConferenceRecordingResourceSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConferenceRecordingResourceSource from json.
func (s *ConferenceRecordingResourceSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResourceSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConferenceRecordingResourceSource(v) {
	case ConferenceRecordingResourceSourceDialVerb:
		*s = ConferenceRecordingResourceSourceDialVerb
	case ConferenceRecordingResourceSourceConference:
		*s = ConferenceRecordingResourceSourceConference
	case ConferenceRecordingResourceSourceOutboundAPI:
		*s = ConferenceRecordingResourceSourceOutboundAPI
	case ConferenceRecordingResourceSourceTrunking:
		*s = ConferenceRecordingResourceSourceTrunking
	case ConferenceRecordingResourceSourceRecordVerb:
		*s = ConferenceRecordingResourceSourceRecordVerb
	case ConferenceRecordingResourceSourceStartCallRecordingAPI:
		*s = ConferenceRecordingResourceSourceStartCallRecordingAPI
	case ConferenceRecordingResourceSourceStartConferenceRecordingAPI:
		*s = ConferenceRecordingResourceSourceStartConferenceRecordingAPI
	default:
		*s = ConferenceRecordingResourceSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceRecordingResourceSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResourceSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceStatus as json.
func (s ConferenceRecordingResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConferenceRecordingResourceStatus from json.
func (s *ConferenceRecordingResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConferenceRecordingResourceStatus(v) {
	case ConferenceRecordingResourceStatusProcessing:
		*s = ConferenceRecordingResourceStatusProcessing
	case ConferenceRecordingResourceStatusAbsent:
		*s = ConferenceRecordingResourceStatusAbsent
	case ConferenceRecordingResourceStatusCompleted:
		*s = ConferenceRecordingResourceStatusCompleted
	case ConferenceRecordingResourceStatusDeleted:
		*s = ConferenceRecordingResourceStatusDeleted
	default:
		*s = ConferenceRecordingResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceRecordingResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConferenceRecordingResourceSubresourceUris) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConferenceRecordingResourceSubresourceUris) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConferenceRecordingResourceSubresourceUris from json.
func (s *ConferenceRecordingResourceSubresourceUris) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceRecordingResourceSubresourceUris to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceRecordingResourceSubresourceUris")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceRecordingResourceSubresourceUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceRecordingResourceSubresourceUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConferenceResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConferenceResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.CallSidEndingConference.Set {
			e.FieldStart("call_sid_ending_conference")
			s.CallSidEndingConference.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.FriendlyName.Set {
			e.FieldStart("friendly_name")
			s.FriendlyName.Encode(e)
		}
	}
	{
		if s.ReasonConferenceEnded.Set {
			e.FieldStart("reason_conference_ended")
			s.ReasonConferenceEnded.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.SubresourceUris.Set {
			e.FieldStart("subresource_uris")
			s.SubresourceUris.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfConferenceResource = [12]string{
	0:  "account_sid",
	1:  "api_version",
	2:  "call_sid_ending_conference",
	3:  "date_created",
	4:  "date_updated",
	5:  "friendly_name",
	6:  "reason_conference_ended",
	7:  "region",
	8:  "sid",
	9:  "status",
	10: "subresource_uris",
	11: "uri",
}

// Decode decodes ConferenceResource from json.
func (s *ConferenceResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "call_sid_ending_conference":
			if err := func() error {
				s.CallSidEndingConference.Reset()
				if err := s.CallSidEndingConference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid_ending_conference\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "friendly_name":
			if err := func() error {
				s.FriendlyName.Reset()
				if err := s.FriendlyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"friendly_name\"")
			}
		case "reason_conference_ended":
			if err := func() error {
				s.ReasonConferenceEnded.Reset()
				if err := s.ReasonConferenceEnded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason_conference_ended\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subresource_uris":
			if err := func() error {
				s.SubresourceUris.Reset()
				if err := s.SubresourceUris.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresource_uris\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConferenceResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConferenceResourceIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConferenceResourceIndex) encodeFields(e *jx.Encoder) {
	{
		if s.Conferences != nil {
			e.FieldStart("conferences")
			e.ArrStart()
			for _, elem := range s.Conferences {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfConferenceResourceIndex = [8]string{
	0: "conferences",
	1: "end",
	2: "first_page_uri",
	3: "next_page_uri",
	4: "page",
	5: "page_size",
	6: "start",
	7: "uri",
}

// Decode decodes ConferenceResourceIndex from json.
func (s *ConferenceResourceIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResourceIndex to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conferences":
			if err := func() error {
				s.Conferences = make([]ConferenceResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConferenceResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conferences = append(s.Conferences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conferences\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceResourceIndex")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConferenceResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceReasonConferenceEnded as json.
func (s ConferenceResourceReasonConferenceEnded) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConferenceResourceReasonConferenceEnded from json.
func (s *ConferenceResourceReasonConferenceEnded) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResourceReasonConferenceEnded to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConferenceResourceReasonConferenceEnded(v) {
	case ConferenceResourceReasonConferenceEndedParticipantWithEndConferenceOnExitLeft:
		*s = ConferenceResourceReasonConferenceEndedParticipantWithEndConferenceOnExitLeft
	case ConferenceResourceReasonConferenceEndedLastParticipantLeft:
		*s = ConferenceResourceReasonConferenceEndedLastParticipantLeft
	case ConferenceResourceReasonConferenceEndedConferenceEndedViaAPI:
		*s = ConferenceResourceReasonConferenceEndedConferenceEndedViaAPI
	case ConferenceResourceReasonConferenceEndedTimeExceeded:
		*s = ConferenceResourceReasonConferenceEndedTimeExceeded
	default:
		*s = ConferenceResourceReasonConferenceEnded(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceResourceReasonConferenceEnded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResourceReasonConferenceEnded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceStatus as json.
func (s ConferenceResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConferenceResourceStatus from json.
func (s *ConferenceResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConferenceResourceStatus(v) {
	case ConferenceResourceStatusInit:
		*s = ConferenceResourceStatusInit
	case ConferenceResourceStatusInProgress:
		*s = ConferenceResourceStatusInProgress
	case ConferenceResourceStatusCompleted:
		*s = ConferenceResourceStatusCompleted
	default:
		*s = ConferenceResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConferenceResourceSubresourceUris) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConferenceResourceSubresourceUris) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConferenceResourceSubresourceUris from json.
func (s *ConferenceResourceSubresourceUris) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceResourceSubresourceUris to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConferenceResourceSubresourceUris")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceResourceSubresourceUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceResourceSubresourceUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceSid as json.
func (s ConferenceSid) Encode(e *jx.Encoder) {
	unwrapped := uuid.UUID(s)

	json.EncodeUUID(e, unwrapped)
}

// Decode decodes ConferenceSid from json.
func (s *ConferenceSid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConferenceSid to nil")
	}
	var unwrapped uuid.UUID
	if err := func() error {
		v, err := json.DecodeUUID(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConferenceSid(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConferenceSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConferenceSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeXMLSecretRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeXMLSecretRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfCreateTeXMLSecretRequest = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes CreateTeXMLSecretRequest from json.
func (s *CreateTeXMLSecretRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeXMLSecretRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeXMLSecretRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTeXMLSecretRequest) {
					name = jsonFieldsNameOfCreateTeXMLSecretRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeXMLSecretRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeXMLSecretRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeXMLSecretResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeXMLSecretResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTeXMLSecretResponse = [1]string{
	0: "data",
}

// Decode decodes CreateTeXMLSecretResponse from json.
func (s *CreateTeXMLSecretResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeXMLSecretResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeXMLSecretResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeXMLSecretResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeXMLSecretResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeXMLSecretResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeXMLSecretResult) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTeXMLSecretResult = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes CreateTeXMLSecretResult from json.
func (s *CreateTeXMLSecretResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeXMLSecretResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeXMLSecretResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeXMLSecretResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeXMLSecretResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTeXMLSecretResultValue as json.
func (s CreateTeXMLSecretResultValue) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateTeXMLSecretResultValue from json.
func (s *CreateTeXMLSecretResultValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeXMLSecretResultValue to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateTeXMLSecretResultValue(v) {
	case CreateTeXMLSecretResultValue_:
		*s = CreateTeXMLSecretResultValue_
	default:
		*s = CreateTeXMLSecretResultValue(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateTeXMLSecretResultValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeXMLSecretResultValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomSipHeader) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomSipHeader) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfCustomSipHeader = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes CustomSipHeader from json.
func (s *CustomSipHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomSipHeader to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomSipHeader")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCustomSipHeader) {
					name = jsonFieldsNameOfCustomSipHeader[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomSipHeader) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomSipHeader) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DateTimeRFC2822 as json.
func (s DateTimeRFC2822) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DateTimeRFC2822 from json.
func (s *DateTimeRFC2822) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DateTimeRFC2822 to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DateTimeRFC2822(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DateTimeRFC2822) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DateTimeRFC2822) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialParticipantResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialParticipantResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfDialParticipantResponse = [1]string{
	0: "data",
}

// Decode decodes DialParticipantResponse from json.
func (s *DialParticipantResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialParticipantResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialParticipantResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialParticipantResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialParticipantResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogflowConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogflowConfig) encodeFields(e *jx.Encoder) {
	{
		if s.AnalyzeSentiment.Set {
			e.FieldStart("analyze_sentiment")
			s.AnalyzeSentiment.Encode(e)
		}
	}
	{
		if s.PartialAutomatedAgentReply.Set {
			e.FieldStart("partial_automated_agent_reply")
			s.PartialAutomatedAgentReply.Encode(e)
		}
	}
}

var jsonFieldsNameOfDialogflowConfig = [2]string{
	0: "analyze_sentiment",
	1: "partial_automated_agent_reply",
}

// Decode decodes DialogflowConfig from json.
func (s *DialogflowConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogflowConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "analyze_sentiment":
			if err := func() error {
				s.AnalyzeSentiment.Reset()
				if err := s.AnalyzeSentiment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analyze_sentiment\"")
			}
		case "partial_automated_agent_reply":
			if err := func() error {
				s.PartialAutomatedAgentReply.Reset()
				if err := s.PartialAutomatedAgentReply.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partial_automated_agent_reply\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialogflowConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogflowConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogflowConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnqueueRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnqueueRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("queue_name")
		e.Str(s.QueueName)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.MaxWaitTimeSecs.Set {
			e.FieldStart("max_wait_time_secs")
			s.MaxWaitTimeSecs.Encode(e)
		}
	}
	{
		if s.MaxSize.Set {
			e.FieldStart("max_size")
			s.MaxSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnqueueRequest = [5]string{
	0: "queue_name",
	1: "client_state",
	2: "command_id",
	3: "max_wait_time_secs",
	4: "max_size",
}

// Decode decodes EnqueueRequest from json.
func (s *EnqueueRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnqueueRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queue_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.QueueName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_name\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "max_wait_time_secs":
			if err := func() error {
				s.MaxWaitTimeSecs.Reset()
				if err := s.MaxWaitTimeSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_wait_time_secs\"")
			}
		case "max_size":
			if err := func() error {
				s.MaxSize.Reset()
				if err := s.MaxSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnqueueRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnqueueRequest) {
					name = jsonFieldsNameOfEnqueueRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnqueueRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnqueueRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		json.EncodeStringInt(e, s.Code)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [5]string{
	0: "code",
	1: "title",
	2: "detail",
	3: "source",
	4: "meta",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeStringInt(d)
				s.Code = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ErrorMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ErrorMeta) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ErrorMeta from json.
func (s *ErrorMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorMeta to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorRecord) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorRecord = [5]string{
	0: "code",
	1: "title",
	2: "detail",
	3: "source",
	4: "meta",
}

// Decode decodes ErrorRecord from json.
func (s *ErrorRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfErrorResponse = [1]string{
	0: "errors",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errors":
			if err := func() error {
				s.Errors = make([]ErrorRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ErrorRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorSource) encodeFields(e *jx.Encoder) {
	{
		if s.Pointer.Set {
			e.FieldStart("pointer")
			s.Pointer.Encode(e)
		}
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorSource = [2]string{
	0: "pointer",
	1: "parameter",
}

// Decode decodes ErrorSource from json.
func (s *ErrorSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pointer":
			if err := func() error {
				s.Pointer.Reset()
				if err := s.Pointer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pointer\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Errors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Errors) encodeFields(e *jx.Encoder) {
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfErrors = [1]string{
	0: "errors",
}

// Decode decodes Errors from json.
func (s *Errors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Errors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errors":
			if err := func() error {
				s.Errors = make([]Error, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Error
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Errors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Errors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Errors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GatherRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GatherRequest) encodeFields(e *jx.Encoder) {
	{
		if s.MinimumDigits.Set {
			e.FieldStart("minimum_digits")
			s.MinimumDigits.Encode(e)
		}
	}
	{
		if s.MaximumDigits.Set {
			e.FieldStart("maximum_digits")
			s.MaximumDigits.Encode(e)
		}
	}
	{
		if s.TimeoutMillis.Set {
			e.FieldStart("timeout_millis")
			s.TimeoutMillis.Encode(e)
		}
	}
	{
		if s.InterDigitTimeoutMillis.Set {
			e.FieldStart("inter_digit_timeout_millis")
			s.InterDigitTimeoutMillis.Encode(e)
		}
	}
	{
		if s.InitialTimeoutMillis.Set {
			e.FieldStart("initial_timeout_millis")
			s.InitialTimeoutMillis.Encode(e)
		}
	}
	{
		if s.TerminatingDigit.Set {
			e.FieldStart("terminating_digit")
			s.TerminatingDigit.Encode(e)
		}
	}
	{
		if s.ValidDigits.Set {
			e.FieldStart("valid_digits")
			s.ValidDigits.Encode(e)
		}
	}
	{
		if s.GatherID.Set {
			e.FieldStart("gather_id")
			s.GatherID.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGatherRequest = [10]string{
	0: "minimum_digits",
	1: "maximum_digits",
	2: "timeout_millis",
	3: "inter_digit_timeout_millis",
	4: "initial_timeout_millis",
	5: "terminating_digit",
	6: "valid_digits",
	7: "gather_id",
	8: "client_state",
	9: "command_id",
}

// Decode decodes GatherRequest from json.
func (s *GatherRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minimum_digits":
			if err := func() error {
				s.MinimumDigits.Reset()
				if err := s.MinimumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_digits\"")
			}
		case "maximum_digits":
			if err := func() error {
				s.MaximumDigits.Reset()
				if err := s.MaximumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_digits\"")
			}
		case "timeout_millis":
			if err := func() error {
				s.TimeoutMillis.Reset()
				if err := s.TimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_millis\"")
			}
		case "inter_digit_timeout_millis":
			if err := func() error {
				s.InterDigitTimeoutMillis.Reset()
				if err := s.InterDigitTimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inter_digit_timeout_millis\"")
			}
		case "initial_timeout_millis":
			if err := func() error {
				s.InitialTimeoutMillis.Reset()
				if err := s.InitialTimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_timeout_millis\"")
			}
		case "terminating_digit":
			if err := func() error {
				s.TerminatingDigit.Reset()
				if err := s.TerminatingDigit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating_digit\"")
			}
		case "valid_digits":
			if err := func() error {
				s.ValidDigits.Reset()
				if err := s.ValidDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid_digits\"")
			}
		case "gather_id":
			if err := func() error {
				s.GatherID.Reset()
				if err := s.GatherID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gather_id\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatherRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GatherRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GatherUsingAudioRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GatherUsingAudioRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		if s.MediaName.Set {
			e.FieldStart("media_name")
			s.MediaName.Encode(e)
		}
	}
	{
		if s.InvalidAudioURL.Set {
			e.FieldStart("invalid_audio_url")
			s.InvalidAudioURL.Encode(e)
		}
	}
	{
		if s.InvalidMediaName.Set {
			e.FieldStart("invalid_media_name")
			s.InvalidMediaName.Encode(e)
		}
	}
	{
		if s.MinimumDigits.Set {
			e.FieldStart("minimum_digits")
			s.MinimumDigits.Encode(e)
		}
	}
	{
		if s.MaximumDigits.Set {
			e.FieldStart("maximum_digits")
			s.MaximumDigits.Encode(e)
		}
	}
	{
		if s.MaximumTries.Set {
			e.FieldStart("maximum_tries")
			s.MaximumTries.Encode(e)
		}
	}
	{
		if s.TimeoutMillis.Set {
			e.FieldStart("timeout_millis")
			s.TimeoutMillis.Encode(e)
		}
	}
	{
		if s.TerminatingDigit.Set {
			e.FieldStart("terminating_digit")
			s.TerminatingDigit.Encode(e)
		}
	}
	{
		if s.ValidDigits.Set {
			e.FieldStart("valid_digits")
			s.ValidDigits.Encode(e)
		}
	}
	{
		if s.InterDigitTimeoutMillis.Set {
			e.FieldStart("inter_digit_timeout_millis")
			s.InterDigitTimeoutMillis.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGatherUsingAudioRequest = [13]string{
	0:  "audio_url",
	1:  "media_name",
	2:  "invalid_audio_url",
	3:  "invalid_media_name",
	4:  "minimum_digits",
	5:  "maximum_digits",
	6:  "maximum_tries",
	7:  "timeout_millis",
	8:  "terminating_digit",
	9:  "valid_digits",
	10: "inter_digit_timeout_millis",
	11: "client_state",
	12: "command_id",
}

// Decode decodes GatherUsingAudioRequest from json.
func (s *GatherUsingAudioRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingAudioRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "media_name":
			if err := func() error {
				s.MediaName.Reset()
				if err := s.MediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_name\"")
			}
		case "invalid_audio_url":
			if err := func() error {
				s.InvalidAudioURL.Reset()
				if err := s.InvalidAudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invalid_audio_url\"")
			}
		case "invalid_media_name":
			if err := func() error {
				s.InvalidMediaName.Reset()
				if err := s.InvalidMediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invalid_media_name\"")
			}
		case "minimum_digits":
			if err := func() error {
				s.MinimumDigits.Reset()
				if err := s.MinimumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_digits\"")
			}
		case "maximum_digits":
			if err := func() error {
				s.MaximumDigits.Reset()
				if err := s.MaximumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_digits\"")
			}
		case "maximum_tries":
			if err := func() error {
				s.MaximumTries.Reset()
				if err := s.MaximumTries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_tries\"")
			}
		case "timeout_millis":
			if err := func() error {
				s.TimeoutMillis.Reset()
				if err := s.TimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_millis\"")
			}
		case "terminating_digit":
			if err := func() error {
				s.TerminatingDigit.Reset()
				if err := s.TerminatingDigit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating_digit\"")
			}
		case "valid_digits":
			if err := func() error {
				s.ValidDigits.Reset()
				if err := s.ValidDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid_digits\"")
			}
		case "inter_digit_timeout_millis":
			if err := func() error {
				s.InterDigitTimeoutMillis.Reset()
				if err := s.InterDigitTimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inter_digit_timeout_millis\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatherUsingAudioRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GatherUsingAudioRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingAudioRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GatherUsingSpeakRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GatherUsingSpeakRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		if s.InvalidPayload.Set {
			e.FieldStart("invalid_payload")
			s.InvalidPayload.Encode(e)
		}
	}
	{
		if s.PayloadType.Set {
			e.FieldStart("payload_type")
			s.PayloadType.Encode(e)
		}
	}
	{
		if s.ServiceLevel.Set {
			e.FieldStart("service_level")
			s.ServiceLevel.Encode(e)
		}
	}
	{
		e.FieldStart("voice")
		s.Voice.Encode(e)
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.MinimumDigits.Set {
			e.FieldStart("minimum_digits")
			s.MinimumDigits.Encode(e)
		}
	}
	{
		if s.MaximumDigits.Set {
			e.FieldStart("maximum_digits")
			s.MaximumDigits.Encode(e)
		}
	}
	{
		if s.MaximumTries.Set {
			e.FieldStart("maximum_tries")
			s.MaximumTries.Encode(e)
		}
	}
	{
		if s.TimeoutMillis.Set {
			e.FieldStart("timeout_millis")
			s.TimeoutMillis.Encode(e)
		}
	}
	{
		if s.TerminatingDigit.Set {
			e.FieldStart("terminating_digit")
			s.TerminatingDigit.Encode(e)
		}
	}
	{
		if s.ValidDigits.Set {
			e.FieldStart("valid_digits")
			s.ValidDigits.Encode(e)
		}
	}
	{
		if s.InterDigitTimeoutMillis.Set {
			e.FieldStart("inter_digit_timeout_millis")
			s.InterDigitTimeoutMillis.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGatherUsingSpeakRequest = [15]string{
	0:  "payload",
	1:  "invalid_payload",
	2:  "payload_type",
	3:  "service_level",
	4:  "voice",
	5:  "language",
	6:  "minimum_digits",
	7:  "maximum_digits",
	8:  "maximum_tries",
	9:  "timeout_millis",
	10: "terminating_digit",
	11: "valid_digits",
	12: "inter_digit_timeout_millis",
	13: "client_state",
	14: "command_id",
}

// Decode decodes GatherUsingSpeakRequest from json.
func (s *GatherUsingSpeakRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "payload":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "invalid_payload":
			if err := func() error {
				s.InvalidPayload.Reset()
				if err := s.InvalidPayload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invalid_payload\"")
			}
		case "payload_type":
			if err := func() error {
				s.PayloadType.Reset()
				if err := s.PayloadType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload_type\"")
			}
		case "service_level":
			if err := func() error {
				s.ServiceLevel.Reset()
				if err := s.ServiceLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_level\"")
			}
		case "voice":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Voice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "minimum_digits":
			if err := func() error {
				s.MinimumDigits.Reset()
				if err := s.MinimumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_digits\"")
			}
		case "maximum_digits":
			if err := func() error {
				s.MaximumDigits.Reset()
				if err := s.MaximumDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_digits\"")
			}
		case "maximum_tries":
			if err := func() error {
				s.MaximumTries.Reset()
				if err := s.MaximumTries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_tries\"")
			}
		case "timeout_millis":
			if err := func() error {
				s.TimeoutMillis.Reset()
				if err := s.TimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_millis\"")
			}
		case "terminating_digit":
			if err := func() error {
				s.TerminatingDigit.Reset()
				if err := s.TerminatingDigit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terminating_digit\"")
			}
		case "valid_digits":
			if err := func() error {
				s.ValidDigits.Reset()
				if err := s.ValidDigits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid_digits\"")
			}
		case "inter_digit_timeout_millis":
			if err := func() error {
				s.InterDigitTimeoutMillis.Reset()
				if err := s.InterDigitTimeoutMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inter_digit_timeout_millis\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatherUsingSpeakRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGatherUsingSpeakRequest) {
					name = jsonFieldsNameOfGatherUsingSpeakRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GatherUsingSpeakRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestLanguage as json.
func (s GatherUsingSpeakRequestLanguage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatherUsingSpeakRequestLanguage from json.
func (s *GatherUsingSpeakRequestLanguage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequestLanguage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatherUsingSpeakRequestLanguage(v) {
	case GatherUsingSpeakRequestLanguageArb:
		*s = GatherUsingSpeakRequestLanguageArb
	case GatherUsingSpeakRequestLanguageCmnCN:
		*s = GatherUsingSpeakRequestLanguageCmnCN
	case GatherUsingSpeakRequestLanguageCyGB:
		*s = GatherUsingSpeakRequestLanguageCyGB
	case GatherUsingSpeakRequestLanguageDaDK:
		*s = GatherUsingSpeakRequestLanguageDaDK
	case GatherUsingSpeakRequestLanguageDeDE:
		*s = GatherUsingSpeakRequestLanguageDeDE
	case GatherUsingSpeakRequestLanguageEnAU:
		*s = GatherUsingSpeakRequestLanguageEnAU
	case GatherUsingSpeakRequestLanguageEnGB:
		*s = GatherUsingSpeakRequestLanguageEnGB
	case GatherUsingSpeakRequestLanguageEnGBWLS:
		*s = GatherUsingSpeakRequestLanguageEnGBWLS
	case GatherUsingSpeakRequestLanguageEnIN:
		*s = GatherUsingSpeakRequestLanguageEnIN
	case GatherUsingSpeakRequestLanguageEnUS:
		*s = GatherUsingSpeakRequestLanguageEnUS
	case GatherUsingSpeakRequestLanguageEsES:
		*s = GatherUsingSpeakRequestLanguageEsES
	case GatherUsingSpeakRequestLanguageEsMX:
		*s = GatherUsingSpeakRequestLanguageEsMX
	case GatherUsingSpeakRequestLanguageEsUS:
		*s = GatherUsingSpeakRequestLanguageEsUS
	case GatherUsingSpeakRequestLanguageFrCA:
		*s = GatherUsingSpeakRequestLanguageFrCA
	case GatherUsingSpeakRequestLanguageFrFR:
		*s = GatherUsingSpeakRequestLanguageFrFR
	case GatherUsingSpeakRequestLanguageHiIN:
		*s = GatherUsingSpeakRequestLanguageHiIN
	case GatherUsingSpeakRequestLanguageIsIS:
		*s = GatherUsingSpeakRequestLanguageIsIS
	case GatherUsingSpeakRequestLanguageItIT:
		*s = GatherUsingSpeakRequestLanguageItIT
	case GatherUsingSpeakRequestLanguageJaJP:
		*s = GatherUsingSpeakRequestLanguageJaJP
	case GatherUsingSpeakRequestLanguageKoKR:
		*s = GatherUsingSpeakRequestLanguageKoKR
	case GatherUsingSpeakRequestLanguageNbNO:
		*s = GatherUsingSpeakRequestLanguageNbNO
	case GatherUsingSpeakRequestLanguageNlNL:
		*s = GatherUsingSpeakRequestLanguageNlNL
	case GatherUsingSpeakRequestLanguagePlPL:
		*s = GatherUsingSpeakRequestLanguagePlPL
	case GatherUsingSpeakRequestLanguagePtBR:
		*s = GatherUsingSpeakRequestLanguagePtBR
	case GatherUsingSpeakRequestLanguagePtPT:
		*s = GatherUsingSpeakRequestLanguagePtPT
	case GatherUsingSpeakRequestLanguageRoRO:
		*s = GatherUsingSpeakRequestLanguageRoRO
	case GatherUsingSpeakRequestLanguageRuRU:
		*s = GatherUsingSpeakRequestLanguageRuRU
	case GatherUsingSpeakRequestLanguageSvSE:
		*s = GatherUsingSpeakRequestLanguageSvSE
	case GatherUsingSpeakRequestLanguageTrTR:
		*s = GatherUsingSpeakRequestLanguageTrTR
	default:
		*s = GatherUsingSpeakRequestLanguage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatherUsingSpeakRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestPayloadType as json.
func (s GatherUsingSpeakRequestPayloadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatherUsingSpeakRequestPayloadType from json.
func (s *GatherUsingSpeakRequestPayloadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequestPayloadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatherUsingSpeakRequestPayloadType(v) {
	case GatherUsingSpeakRequestPayloadTypeText:
		*s = GatherUsingSpeakRequestPayloadTypeText
	case GatherUsingSpeakRequestPayloadTypeSsml:
		*s = GatherUsingSpeakRequestPayloadTypeSsml
	default:
		*s = GatherUsingSpeakRequestPayloadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatherUsingSpeakRequestPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequestPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestServiceLevel as json.
func (s GatherUsingSpeakRequestServiceLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatherUsingSpeakRequestServiceLevel from json.
func (s *GatherUsingSpeakRequestServiceLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequestServiceLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatherUsingSpeakRequestServiceLevel(v) {
	case GatherUsingSpeakRequestServiceLevelBasic:
		*s = GatherUsingSpeakRequestServiceLevelBasic
	case GatherUsingSpeakRequestServiceLevelPremium:
		*s = GatherUsingSpeakRequestServiceLevelPremium
	default:
		*s = GatherUsingSpeakRequestServiceLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatherUsingSpeakRequestServiceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequestServiceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestVoice as json.
func (s GatherUsingSpeakRequestVoice) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatherUsingSpeakRequestVoice from json.
func (s *GatherUsingSpeakRequestVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatherUsingSpeakRequestVoice to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatherUsingSpeakRequestVoice(v) {
	case GatherUsingSpeakRequestVoiceMale:
		*s = GatherUsingSpeakRequestVoiceMale
	case GatherUsingSpeakRequestVoiceFemale:
		*s = GatherUsingSpeakRequestVoiceFemale
	default:
		*s = GatherUsingSpeakRequestVoice(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatherUsingSpeakRequestVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatherUsingSpeakRequestVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCallResponse = [1]string{
	0: "data",
}

// Decode decodes GetCallResponse from json.
func (s *GetCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCallsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCallsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCallsResponse = [1]string{
	0: "data",
}

// Decode decodes GetCallsResponse from json.
func (s *GetCallsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCallsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCallsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCallsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCallsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConferenceRecordingsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConferenceRecordingsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConferenceRecordingsResponse = [1]string{
	0: "data",
}

// Decode decodes GetConferenceRecordingsResponse from json.
func (s *GetConferenceRecordingsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConferenceRecordingsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConferenceRecordingsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConferenceRecordingsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConferenceRecordingsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConferenceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConferenceResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConferenceResponse = [1]string{
	0: "data",
}

// Decode decodes GetConferenceResponse from json.
func (s *GetConferenceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConferenceResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConferenceResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConferenceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConferenceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConferencesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConferencesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConferencesResponse = [1]string{
	0: "data",
}

// Decode decodes GetConferencesResponse from json.
func (s *GetConferencesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConferencesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConferencesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConferencesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConferencesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetParticipantResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetParticipantResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetParticipantResponse = [1]string{
	0: "data",
}

// Decode decodes GetParticipantResponse from json.
func (s *GetParticipantResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetParticipantResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetParticipantsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetParticipantsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetParticipantsResponse = [1]string{
	0: "data",
}

// Decode decodes GetParticipantsResponse from json.
func (s *GetParticipantsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetParticipantsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HangupRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HangupRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfHangupRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes HangupRequest from json.
func (s *HangupRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HangupRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HangupRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HangupRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HangupRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateCallRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ApplicationSid")
		e.Str(s.ApplicationSid)
	}
	{
		e.FieldStart("To")
		e.Str(s.To)
	}
	{
		e.FieldStart("From")
		e.Str(s.From)
	}
	{
		if s.URL.Set {
			e.FieldStart("Url")
			s.URL.Encode(e)
		}
	}
	{
		if s.UrlMethod.Set {
			e.FieldStart("UrlMethod")
			s.UrlMethod.Encode(e)
		}
	}
	{
		if s.FallbackUrl.Set {
			e.FieldStart("FallbackUrl")
			s.FallbackUrl.Encode(e)
		}
	}
	{
		if s.StatusCallback.Set {
			e.FieldStart("StatusCallback")
			s.StatusCallback.Encode(e)
		}
	}
	{
		if s.StatusCallbackMethod.Set {
			e.FieldStart("StatusCallbackMethod")
			s.StatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.StatusCallbackEvent.Set {
			e.FieldStart("StatusCallbackEvent")
			s.StatusCallbackEvent.Encode(e)
		}
	}
	{
		if s.MachineDetection.Set {
			e.FieldStart("MachineDetection")
			s.MachineDetection.Encode(e)
		}
	}
	{
		if s.DetectionMode.Set {
			e.FieldStart("DetectionMode")
			s.DetectionMode.Encode(e)
		}
	}
	{
		if s.AsyncAmd.Set {
			e.FieldStart("AsyncAmd")
			s.AsyncAmd.Encode(e)
		}
	}
	{
		if s.AsyncAmdStatusCallback.Set {
			e.FieldStart("AsyncAmdStatusCallback")
			s.AsyncAmdStatusCallback.Encode(e)
		}
	}
	{
		if s.AsyncAmdStatusCallbackMethod.Set {
			e.FieldStart("AsyncAmdStatusCallbackMethod")
			s.AsyncAmdStatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.MachineDetectionTimeout.Set {
			e.FieldStart("MachineDetectionTimeout")
			s.MachineDetectionTimeout.Encode(e)
		}
	}
	{
		if s.MachineDetectionSpeechThreshold.Set {
			e.FieldStart("MachineDetectionSpeechThreshold")
			s.MachineDetectionSpeechThreshold.Encode(e)
		}
	}
	{
		if s.MachineDetectionSpeechEndThreshold.Set {
			e.FieldStart("MachineDetectionSpeechEndThreshold")
			s.MachineDetectionSpeechEndThreshold.Encode(e)
		}
	}
	{
		if s.MachineDetectionSilenceTimeout.Set {
			e.FieldStart("MachineDetectionSilenceTimeout")
			s.MachineDetectionSilenceTimeout.Encode(e)
		}
	}
	{
		if s.CancelPlaybackOnMachineDetection.Set {
			e.FieldStart("CancelPlaybackOnMachineDetection")
			s.CancelPlaybackOnMachineDetection.Encode(e)
		}
	}
	{
		if s.CancelPlaybackOnDetectMessageEnd.Set {
			e.FieldStart("CancelPlaybackOnDetectMessageEnd")
			s.CancelPlaybackOnDetectMessageEnd.Encode(e)
		}
	}
	{
		if s.PreferredCodecs.Set {
			e.FieldStart("PreferredCodecs")
			s.PreferredCodecs.Encode(e)
		}
	}
	{
		if s.Record.Set {
			e.FieldStart("Record")
			s.Record.Encode(e)
		}
	}
	{
		if s.RecordingChannels.Set {
			e.FieldStart("RecordingChannels")
			s.RecordingChannels.Encode(e)
		}
	}
	{
		if s.RecordingStatusCallback.Set {
			e.FieldStart("RecordingStatusCallback")
			s.RecordingStatusCallback.Encode(e)
		}
	}
	{
		if s.RecordingStatusCallbackMethod.Set {
			e.FieldStart("RecordingStatusCallbackMethod")
			s.RecordingStatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.RecordingStatusCallbackEvent.Set {
			e.FieldStart("RecordingStatusCallbackEvent")
			s.RecordingStatusCallbackEvent.Encode(e)
		}
	}
	{
		if s.RecordingTimeout.Set {
			e.FieldStart("RecordingTimeout")
			s.RecordingTimeout.Encode(e)
		}
	}
	{
		if s.RecordingTrack.Set {
			e.FieldStart("RecordingTrack")
			s.RecordingTrack.Encode(e)
		}
	}
	{
		if s.SipAuthPassword.Set {
			e.FieldStart("SipAuthPassword")
			s.SipAuthPassword.Encode(e)
		}
	}
	{
		if s.SipAuthUsername.Set {
			e.FieldStart("SipAuthUsername")
			s.SipAuthUsername.Encode(e)
		}
	}
	{
		if s.Trim.Set {
			e.FieldStart("Trim")
			s.Trim.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateCallRequest = [31]string{
	0:  "ApplicationSid",
	1:  "To",
	2:  "From",
	3:  "Url",
	4:  "UrlMethod",
	5:  "FallbackUrl",
	6:  "StatusCallback",
	7:  "StatusCallbackMethod",
	8:  "StatusCallbackEvent",
	9:  "MachineDetection",
	10: "DetectionMode",
	11: "AsyncAmd",
	12: "AsyncAmdStatusCallback",
	13: "AsyncAmdStatusCallbackMethod",
	14: "MachineDetectionTimeout",
	15: "MachineDetectionSpeechThreshold",
	16: "MachineDetectionSpeechEndThreshold",
	17: "MachineDetectionSilenceTimeout",
	18: "CancelPlaybackOnMachineDetection",
	19: "CancelPlaybackOnDetectMessageEnd",
	20: "PreferredCodecs",
	21: "Record",
	22: "RecordingChannels",
	23: "RecordingStatusCallback",
	24: "RecordingStatusCallbackMethod",
	25: "RecordingStatusCallbackEvent",
	26: "RecordingTimeout",
	27: "RecordingTrack",
	28: "SipAuthPassword",
	29: "SipAuthUsername",
	30: "Trim",
}

// Decode decodes InitiateCallRequest from json.
func (s *InitiateCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequest to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ApplicationSid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApplicationSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ApplicationSid\"")
			}
		case "To":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"To\"")
			}
		case "From":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"From\"")
			}
		case "Url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Url\"")
			}
		case "UrlMethod":
			if err := func() error {
				s.UrlMethod.Reset()
				if err := s.UrlMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UrlMethod\"")
			}
		case "FallbackUrl":
			if err := func() error {
				s.FallbackUrl.Reset()
				if err := s.FallbackUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FallbackUrl\"")
			}
		case "StatusCallback":
			if err := func() error {
				s.StatusCallback.Reset()
				if err := s.StatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallback\"")
			}
		case "StatusCallbackMethod":
			if err := func() error {
				s.StatusCallbackMethod.Reset()
				if err := s.StatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallbackMethod\"")
			}
		case "StatusCallbackEvent":
			if err := func() error {
				s.StatusCallbackEvent.Reset()
				if err := s.StatusCallbackEvent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallbackEvent\"")
			}
		case "MachineDetection":
			if err := func() error {
				s.MachineDetection.Reset()
				if err := s.MachineDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetection\"")
			}
		case "DetectionMode":
			if err := func() error {
				s.DetectionMode.Reset()
				if err := s.DetectionMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DetectionMode\"")
			}
		case "AsyncAmd":
			if err := func() error {
				s.AsyncAmd.Reset()
				if err := s.AsyncAmd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AsyncAmd\"")
			}
		case "AsyncAmdStatusCallback":
			if err := func() error {
				s.AsyncAmdStatusCallback.Reset()
				if err := s.AsyncAmdStatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AsyncAmdStatusCallback\"")
			}
		case "AsyncAmdStatusCallbackMethod":
			if err := func() error {
				s.AsyncAmdStatusCallbackMethod.Reset()
				if err := s.AsyncAmdStatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AsyncAmdStatusCallbackMethod\"")
			}
		case "MachineDetectionTimeout":
			if err := func() error {
				s.MachineDetectionTimeout.Reset()
				if err := s.MachineDetectionTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetectionTimeout\"")
			}
		case "MachineDetectionSpeechThreshold":
			if err := func() error {
				s.MachineDetectionSpeechThreshold.Reset()
				if err := s.MachineDetectionSpeechThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetectionSpeechThreshold\"")
			}
		case "MachineDetectionSpeechEndThreshold":
			if err := func() error {
				s.MachineDetectionSpeechEndThreshold.Reset()
				if err := s.MachineDetectionSpeechEndThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetectionSpeechEndThreshold\"")
			}
		case "MachineDetectionSilenceTimeout":
			if err := func() error {
				s.MachineDetectionSilenceTimeout.Reset()
				if err := s.MachineDetectionSilenceTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MachineDetectionSilenceTimeout\"")
			}
		case "CancelPlaybackOnMachineDetection":
			if err := func() error {
				s.CancelPlaybackOnMachineDetection.Reset()
				if err := s.CancelPlaybackOnMachineDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CancelPlaybackOnMachineDetection\"")
			}
		case "CancelPlaybackOnDetectMessageEnd":
			if err := func() error {
				s.CancelPlaybackOnDetectMessageEnd.Reset()
				if err := s.CancelPlaybackOnDetectMessageEnd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CancelPlaybackOnDetectMessageEnd\"")
			}
		case "PreferredCodecs":
			if err := func() error {
				s.PreferredCodecs.Reset()
				if err := s.PreferredCodecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PreferredCodecs\"")
			}
		case "Record":
			if err := func() error {
				s.Record.Reset()
				if err := s.Record.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Record\"")
			}
		case "RecordingChannels":
			if err := func() error {
				s.RecordingChannels.Reset()
				if err := s.RecordingChannels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingChannels\"")
			}
		case "RecordingStatusCallback":
			if err := func() error {
				s.RecordingStatusCallback.Reset()
				if err := s.RecordingStatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingStatusCallback\"")
			}
		case "RecordingStatusCallbackMethod":
			if err := func() error {
				s.RecordingStatusCallbackMethod.Reset()
				if err := s.RecordingStatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingStatusCallbackMethod\"")
			}
		case "RecordingStatusCallbackEvent":
			if err := func() error {
				s.RecordingStatusCallbackEvent.Reset()
				if err := s.RecordingStatusCallbackEvent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingStatusCallbackEvent\"")
			}
		case "RecordingTimeout":
			if err := func() error {
				s.RecordingTimeout.Reset()
				if err := s.RecordingTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingTimeout\"")
			}
		case "RecordingTrack":
			if err := func() error {
				s.RecordingTrack.Reset()
				if err := s.RecordingTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordingTrack\"")
			}
		case "SipAuthPassword":
			if err := func() error {
				s.SipAuthPassword.Reset()
				if err := s.SipAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SipAuthPassword\"")
			}
		case "SipAuthUsername":
			if err := func() error {
				s.SipAuthUsername.Reset()
				if err := s.SipAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SipAuthUsername\"")
			}
		case "Trim":
			if err := func() error {
				s.Trim.Reset()
				if err := s.Trim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Trim\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateCallRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000111,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInitiateCallRequest) {
					name = jsonFieldsNameOfInitiateCallRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestAsyncAmdStatusCallbackMethod as json.
func (s InitiateCallRequestAsyncAmdStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestAsyncAmdStatusCallbackMethod from json.
func (s *InitiateCallRequestAsyncAmdStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestAsyncAmdStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestAsyncAmdStatusCallbackMethod(v) {
	case InitiateCallRequestAsyncAmdStatusCallbackMethodGET:
		*s = InitiateCallRequestAsyncAmdStatusCallbackMethodGET
	case InitiateCallRequestAsyncAmdStatusCallbackMethodPOST:
		*s = InitiateCallRequestAsyncAmdStatusCallbackMethodPOST
	default:
		*s = InitiateCallRequestAsyncAmdStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestAsyncAmdStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestAsyncAmdStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestDetectionMode as json.
func (s InitiateCallRequestDetectionMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestDetectionMode from json.
func (s *InitiateCallRequestDetectionMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestDetectionMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestDetectionMode(v) {
	case InitiateCallRequestDetectionModePremium:
		*s = InitiateCallRequestDetectionModePremium
	case InitiateCallRequestDetectionModeRegular:
		*s = InitiateCallRequestDetectionModeRegular
	default:
		*s = InitiateCallRequestDetectionMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestDetectionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestDetectionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestMachineDetection as json.
func (s InitiateCallRequestMachineDetection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestMachineDetection from json.
func (s *InitiateCallRequestMachineDetection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestMachineDetection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestMachineDetection(v) {
	case InitiateCallRequestMachineDetectionEnable:
		*s = InitiateCallRequestMachineDetectionEnable
	case InitiateCallRequestMachineDetectionDisable:
		*s = InitiateCallRequestMachineDetectionDisable
	case InitiateCallRequestMachineDetectionDetectMessageEnd:
		*s = InitiateCallRequestMachineDetectionDetectMessageEnd
	default:
		*s = InitiateCallRequestMachineDetection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingChannels as json.
func (s InitiateCallRequestRecordingChannels) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestRecordingChannels from json.
func (s *InitiateCallRequestRecordingChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestRecordingChannels to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestRecordingChannels(v) {
	case InitiateCallRequestRecordingChannelsMono:
		*s = InitiateCallRequestRecordingChannelsMono
	case InitiateCallRequestRecordingChannelsDual:
		*s = InitiateCallRequestRecordingChannelsDual
	default:
		*s = InitiateCallRequestRecordingChannels(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestRecordingChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestRecordingChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingStatusCallbackMethod as json.
func (s InitiateCallRequestRecordingStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestRecordingStatusCallbackMethod from json.
func (s *InitiateCallRequestRecordingStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestRecordingStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestRecordingStatusCallbackMethod(v) {
	case InitiateCallRequestRecordingStatusCallbackMethodGET:
		*s = InitiateCallRequestRecordingStatusCallbackMethodGET
	case InitiateCallRequestRecordingStatusCallbackMethodPOST:
		*s = InitiateCallRequestRecordingStatusCallbackMethodPOST
	default:
		*s = InitiateCallRequestRecordingStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestRecordingStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestRecordingStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingTrack as json.
func (s InitiateCallRequestRecordingTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestRecordingTrack from json.
func (s *InitiateCallRequestRecordingTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestRecordingTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestRecordingTrack(v) {
	case InitiateCallRequestRecordingTrackInbound:
		*s = InitiateCallRequestRecordingTrackInbound
	case InitiateCallRequestRecordingTrackOutbound:
		*s = InitiateCallRequestRecordingTrackOutbound
	case InitiateCallRequestRecordingTrackBoth:
		*s = InitiateCallRequestRecordingTrackBoth
	default:
		*s = InitiateCallRequestRecordingTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestStatusCallbackEvent as json.
func (s InitiateCallRequestStatusCallbackEvent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestStatusCallbackEvent from json.
func (s *InitiateCallRequestStatusCallbackEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestStatusCallbackEvent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestStatusCallbackEvent(v) {
	case InitiateCallRequestStatusCallbackEventInitiated:
		*s = InitiateCallRequestStatusCallbackEventInitiated
	case InitiateCallRequestStatusCallbackEventRinging:
		*s = InitiateCallRequestStatusCallbackEventRinging
	case InitiateCallRequestStatusCallbackEventAnswered:
		*s = InitiateCallRequestStatusCallbackEventAnswered
	case InitiateCallRequestStatusCallbackEventCompleted:
		*s = InitiateCallRequestStatusCallbackEventCompleted
	default:
		*s = InitiateCallRequestStatusCallbackEvent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestStatusCallbackEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestStatusCallbackEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestStatusCallbackMethod as json.
func (s InitiateCallRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestStatusCallbackMethod from json.
func (s *InitiateCallRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestStatusCallbackMethod(v) {
	case InitiateCallRequestStatusCallbackMethodGET:
		*s = InitiateCallRequestStatusCallbackMethodGET
	case InitiateCallRequestStatusCallbackMethodPOST:
		*s = InitiateCallRequestStatusCallbackMethodPOST
	default:
		*s = InitiateCallRequestStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestTrim as json.
func (s InitiateCallRequestTrim) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestTrim from json.
func (s *InitiateCallRequestTrim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestTrim to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestTrim(v) {
	case InitiateCallRequestTrimTrimSilence:
		*s = InitiateCallRequestTrimTrimSilence
	case InitiateCallRequestTrimDoNotTrim:
		*s = InitiateCallRequestTrimDoNotTrim
	default:
		*s = InitiateCallRequestTrim(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestUrlMethod as json.
func (s InitiateCallRequestUrlMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InitiateCallRequestUrlMethod from json.
func (s *InitiateCallRequestUrlMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallRequestUrlMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InitiateCallRequestUrlMethod(v) {
	case InitiateCallRequestUrlMethodGET:
		*s = InitiateCallRequestUrlMethodGET
	case InitiateCallRequestUrlMethodPOST:
		*s = InitiateCallRequestUrlMethodPOST
	default:
		*s = InitiateCallRequestUrlMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InitiateCallRequestUrlMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallRequestUrlMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateCallResponse = [1]string{
	0: "data",
}

// Decode decodes InitiateCallResponse from json.
func (s *InitiateCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitiateCallResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitiateCallResult) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfInitiateCallResult = [3]string{
	0: "from",
	1: "to",
	2: "status",
}

// Decode decodes InitiateCallResult from json.
func (s *InitiateCallResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitiateCallResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InitiateCallResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitiateCallResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitiateCallResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeaveQueueRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeaveQueueRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeaveQueueRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes LeaveQueueRequest from json.
func (s *LeaveQueueRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeaveQueueRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeaveQueueRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeaveQueueRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeaveQueueRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListQueueCallsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListQueueCallsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfListQueueCallsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ListQueueCallsResponse from json.
func (s *ListQueueCallsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListQueueCallsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]QueueCall, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QueueCall
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListQueueCallsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListQueueCallsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListQueueCallsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Loopcount as json.
func (s Loopcount) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringLoopcount:
		e.Str(s.String)
	case IntLoopcount:
		e.Int(s.Int)
	}
}

// Decode decodes Loopcount from json.
func (s *Loopcount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Loopcount to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntLoopcount
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringLoopcount
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Loopcount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Loopcount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MetaResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MetaResponse) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfMetaResponse = [1]string{
	0: "url",
}

// Decode decodes MetaResponse from json.
func (s *MetaResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetaResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetaResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MetaResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MetaResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewParticipantResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewParticipantResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.Coaching.Set {
			e.FieldStart("coaching")
			s.Coaching.Encode(e)
		}
	}
	{
		if s.CoachingCallSid.Set {
			e.FieldStart("coaching_call_sid")
			s.CoachingCallSid.Encode(e)
		}
	}
	{
		if s.EndConferenceOnExit.Set {
			e.FieldStart("end_conference_on_exit")
			s.EndConferenceOnExit.Encode(e)
		}
	}
	{
		if s.Hold.Set {
			e.FieldStart("hold")
			s.Hold.Encode(e)
		}
	}
	{
		if s.Muted.Set {
			e.FieldStart("muted")
			s.Muted.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfNewParticipantResource = [9]string{
	0: "account_sid",
	1: "call_sid",
	2: "coaching",
	3: "coaching_call_sid",
	4: "end_conference_on_exit",
	5: "hold",
	6: "muted",
	7: "status",
	8: "uri",
}

// Decode decodes NewParticipantResource from json.
func (s *NewParticipantResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewParticipantResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "coaching":
			if err := func() error {
				s.Coaching.Reset()
				if err := s.Coaching.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching\"")
			}
		case "coaching_call_sid":
			if err := func() error {
				s.CoachingCallSid.Reset()
				if err := s.CoachingCallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching_call_sid\"")
			}
		case "end_conference_on_exit":
			if err := func() error {
				s.EndConferenceOnExit.Reset()
				if err := s.EndConferenceOnExit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_conference_on_exit\"")
			}
		case "hold":
			if err := func() error {
				s.Hold.Reset()
				if err := s.Hold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold\"")
			}
		case "muted":
			if err := func() error {
				s.Muted.Reset()
				if err := s.Muted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muted\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewParticipantResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewParticipantResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewParticipantResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewParticipantResourceStatus as json.
func (s NewParticipantResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NewParticipantResourceStatus from json.
func (s *NewParticipantResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewParticipantResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NewParticipantResourceStatus(v) {
	case NewParticipantResourceStatusConnecting:
		*s = NewParticipantResourceStatusConnecting
	case NewParticipantResourceStatusConnected:
		*s = NewParticipantResourceStatusConnected
	case NewParticipantResourceStatusCompleted:
		*s = NewParticipantResourceStatusCompleted
	default:
		*s = NewParticipantResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NewParticipantResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewParticipantResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NoiseSuppressionDirection as json.
func (s NoiseSuppressionDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NoiseSuppressionDirection from json.
func (s *NoiseSuppressionDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NoiseSuppressionDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NoiseSuppressionDirection(v) {
	case NoiseSuppressionDirectionInbound:
		*s = NoiseSuppressionDirectionInbound
	case NoiseSuppressionDirectionOutbound:
		*s = NoiseSuppressionDirectionOutbound
	case NoiseSuppressionDirectionBoth:
		*s = NoiseSuppressionDirectionBoth
	default:
		*s = NoiseSuppressionDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NoiseSuppressionDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NoiseSuppressionDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NoiseSuppressionStart) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NoiseSuppressionStart) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
}

var jsonFieldsNameOfNoiseSuppressionStart = [3]string{
	0: "client_state",
	1: "command_id",
	2: "direction",
}

// Decode decodes NoiseSuppressionStart from json.
func (s *NoiseSuppressionStart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NoiseSuppressionStart to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NoiseSuppressionStart")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NoiseSuppressionStart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NoiseSuppressionStart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NoiseSuppressionStop) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NoiseSuppressionStop) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfNoiseSuppressionStop = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes NoiseSuppressionStop from json.
func (s *NoiseSuppressionStop) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NoiseSuppressionStop to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NoiseSuppressionStop")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NoiseSuppressionStop) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NoiseSuppressionStop) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountSid as json.
func (o OptAccountSid) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccountSid from json.
func (o *OptAccountSid) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccountSid to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccountSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccountSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestPreferredCodecs as json.
func (o OptAnswerRequestPreferredCodecs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AnswerRequestPreferredCodecs from json.
func (o *OptAnswerRequestPreferredCodecs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnswerRequestPreferredCodecs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnswerRequestPreferredCodecs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnswerRequestPreferredCodecs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestStreamTrack as json.
func (o OptAnswerRequestStreamTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AnswerRequestStreamTrack from json.
func (o *OptAnswerRequestStreamTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnswerRequestStreamTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnswerRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnswerRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnswerRequestWebhookURLMethod as json.
func (o OptAnswerRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AnswerRequestWebhookURLMethod from json.
func (o *OptAnswerRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnswerRequestWebhookURLMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnswerRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnswerRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Call as json.
func (o OptCall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Call from json.
func (o *OptCall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCall to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlCommandResult as json.
func (o OptCallControlCommandResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallControlCommandResult from json.
func (o *OptCallControlCommandResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlCommandResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlCommandResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlCommandResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallControlId as json.
func (o OptCallControlId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallControlId from json.
func (o *OptCallControlId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallControlId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallControlId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallControlId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestAnsweringMachineDetection as json.
func (o OptCallRequestAnsweringMachineDetection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestAnsweringMachineDetection from json.
func (o *OptCallRequestAnsweringMachineDetection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestAnsweringMachineDetection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestAnsweringMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestAnsweringMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestAnsweringMachineDetectionConfig as json.
func (o OptCallRequestAnsweringMachineDetectionConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallRequestAnsweringMachineDetectionConfig from json.
func (o *OptCallRequestAnsweringMachineDetectionConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestAnsweringMachineDetectionConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestAnsweringMachineDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestAnsweringMachineDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfig as json.
func (o OptCallRequestConferenceConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallRequestConferenceConfig from json.
func (o *OptCallRequestConferenceConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestConferenceConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestConferenceConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestConferenceConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfigBeepEnabled as json.
func (o OptCallRequestConferenceConfigBeepEnabled) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestConferenceConfigBeepEnabled from json.
func (o *OptCallRequestConferenceConfigBeepEnabled) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestConferenceConfigBeepEnabled to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestConferenceConfigBeepEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestConferenceConfigBeepEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestConferenceConfigSupervisorRole as json.
func (o OptCallRequestConferenceConfigSupervisorRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestConferenceConfigSupervisorRole from json.
func (o *OptCallRequestConferenceConfigSupervisorRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestConferenceConfigSupervisorRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestConferenceConfigSupervisorRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestConferenceConfigSupervisorRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestMediaEncryption as json.
func (o OptCallRequestMediaEncryption) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestMediaEncryption from json.
func (o *OptCallRequestMediaEncryption) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestMediaEncryption to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestMediaEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestMediaEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecord as json.
func (o OptCallRequestRecord) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestRecord from json.
func (o *OptCallRequestRecord) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestRecord to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordChannels as json.
func (o OptCallRequestRecordChannels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestRecordChannels from json.
func (o *OptCallRequestRecordChannels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestRecordChannels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestRecordChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestRecordChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordFormat as json.
func (o OptCallRequestRecordFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestRecordFormat from json.
func (o *OptCallRequestRecordFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestRecordFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestRecordFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestRecordFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestRecordTrim as json.
func (o OptCallRequestRecordTrim) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestRecordTrim from json.
func (o *OptCallRequestRecordTrim) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestRecordTrim to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestRecordTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestRecordTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestSipTransportProtocol as json.
func (o OptCallRequestSipTransportProtocol) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestSipTransportProtocol from json.
func (o *OptCallRequestSipTransportProtocol) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestSipTransportProtocol to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestSipTransportProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestSipTransportProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestStreamTrack as json.
func (o OptCallRequestStreamTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestStreamTrack from json.
func (o *OptCallRequestStreamTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestStreamTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallRequestWebhookURLMethod as json.
func (o OptCallRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallRequestWebhookURLMethod from json.
func (o *OptCallRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallRequestWebhookURLMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResource as json.
func (o OptCallResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallResource from json.
func (o *OptCallResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceAnsweredBy as json.
func (o OptCallResourceAnsweredBy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallResourceAnsweredBy from json.
func (o *OptCallResourceAnsweredBy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResourceAnsweredBy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResourceAnsweredBy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResourceAnsweredBy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceDirection as json.
func (o OptCallResourceDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallResourceDirection from json.
func (o *OptCallResourceDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResourceDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResourceDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResourceDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceIndex as json.
func (o OptCallResourceIndex) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CallResourceIndex from json.
func (o *OptCallResourceIndex) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResourceIndex to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CallResourceStatus as json.
func (o OptCallResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CallResourceStatus from json.
func (o *OptCallResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCallResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCallResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCallResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceIndex as json.
func (o OptConferenceRecordingResourceIndex) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceRecordingResourceIndex from json.
func (o *OptConferenceRecordingResourceIndex) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceRecordingResourceIndex to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceRecordingResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceRecordingResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceSource as json.
func (o OptConferenceRecordingResourceSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConferenceRecordingResourceSource from json.
func (o *OptConferenceRecordingResourceSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceRecordingResourceSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceRecordingResourceSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceRecordingResourceSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceStatus as json.
func (o OptConferenceRecordingResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConferenceRecordingResourceStatus from json.
func (o *OptConferenceRecordingResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceRecordingResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceRecordingResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceRecordingResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceRecordingResourceSubresourceUris as json.
func (o OptConferenceRecordingResourceSubresourceUris) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceRecordingResourceSubresourceUris from json.
func (o *OptConferenceRecordingResourceSubresourceUris) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceRecordingResourceSubresourceUris to nil")
	}
	o.Set = true
	o.Value = make(ConferenceRecordingResourceSubresourceUris)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceRecordingResourceSubresourceUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceRecordingResourceSubresourceUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResource as json.
func (o OptConferenceResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceResource from json.
func (o *OptConferenceResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceIndex as json.
func (o OptConferenceResourceIndex) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceResourceIndex from json.
func (o *OptConferenceResourceIndex) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResourceIndex to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceReasonConferenceEnded as json.
func (o OptConferenceResourceReasonConferenceEnded) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConferenceResourceReasonConferenceEnded from json.
func (o *OptConferenceResourceReasonConferenceEnded) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResourceReasonConferenceEnded to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResourceReasonConferenceEnded) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResourceReasonConferenceEnded) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceStatus as json.
func (o OptConferenceResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConferenceResourceStatus from json.
func (o *OptConferenceResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceResourceSubresourceUris as json.
func (o OptConferenceResourceSubresourceUris) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceResourceSubresourceUris from json.
func (o *OptConferenceResourceSubresourceUris) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConferenceResourceSubresourceUris to nil")
	}
	o.Set = true
	o.Value = make(ConferenceResourceSubresourceUris)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConferenceResourceSubresourceUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConferenceResourceSubresourceUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTeXMLSecretResult as json.
func (o OptCreateTeXMLSecretResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateTeXMLSecretResult from json.
func (o *OptCreateTeXMLSecretResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTeXMLSecretResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTeXMLSecretResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTeXMLSecretResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTeXMLSecretResultValue as json.
func (o OptCreateTeXMLSecretResultValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateTeXMLSecretResultValue from json.
func (o *OptCreateTeXMLSecretResultValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateTeXMLSecretResultValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateTeXMLSecretResultValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateTeXMLSecretResultValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DateTimeRFC2822 as json.
func (o OptDateTimeRFC2822) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DateTimeRFC2822 from json.
func (o *OptDateTimeRFC2822) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTimeRFC2822 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTimeRFC2822) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTimeRFC2822) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DialogflowConfig as json.
func (o OptDialogflowConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DialogflowConfig from json.
func (o *OptDialogflowConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDialogflowConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDialogflowConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDialogflowConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorMeta as json.
func (o OptErrorMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorMeta from json.
func (o *OptErrorMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorMeta to nil")
	}
	o.Set = true
	o.Value = make(ErrorMeta)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorSource as json.
func (o OptErrorSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorSource from json.
func (o *OptErrorSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestLanguage as json.
func (o OptGatherUsingSpeakRequestLanguage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GatherUsingSpeakRequestLanguage from json.
func (o *OptGatherUsingSpeakRequestLanguage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatherUsingSpeakRequestLanguage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatherUsingSpeakRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatherUsingSpeakRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestPayloadType as json.
func (o OptGatherUsingSpeakRequestPayloadType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GatherUsingSpeakRequestPayloadType from json.
func (o *OptGatherUsingSpeakRequestPayloadType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatherUsingSpeakRequestPayloadType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatherUsingSpeakRequestPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatherUsingSpeakRequestPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatherUsingSpeakRequestServiceLevel as json.
func (o OptGatherUsingSpeakRequestServiceLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GatherUsingSpeakRequestServiceLevel from json.
func (o *OptGatherUsingSpeakRequestServiceLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatherUsingSpeakRequestServiceLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatherUsingSpeakRequestServiceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatherUsingSpeakRequestServiceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestAsyncAmdStatusCallbackMethod as json.
func (o OptInitiateCallRequestAsyncAmdStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestAsyncAmdStatusCallbackMethod from json.
func (o *OptInitiateCallRequestAsyncAmdStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestAsyncAmdStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestAsyncAmdStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestAsyncAmdStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestDetectionMode as json.
func (o OptInitiateCallRequestDetectionMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestDetectionMode from json.
func (o *OptInitiateCallRequestDetectionMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestDetectionMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestDetectionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestDetectionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestMachineDetection as json.
func (o OptInitiateCallRequestMachineDetection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestMachineDetection from json.
func (o *OptInitiateCallRequestMachineDetection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestMachineDetection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingChannels as json.
func (o OptInitiateCallRequestRecordingChannels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestRecordingChannels from json.
func (o *OptInitiateCallRequestRecordingChannels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestRecordingChannels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestRecordingChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestRecordingChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingStatusCallbackMethod as json.
func (o OptInitiateCallRequestRecordingStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestRecordingStatusCallbackMethod from json.
func (o *OptInitiateCallRequestRecordingStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestRecordingStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestRecordingStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestRecordingStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestRecordingTrack as json.
func (o OptInitiateCallRequestRecordingTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestRecordingTrack from json.
func (o *OptInitiateCallRequestRecordingTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestRecordingTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestStatusCallbackEvent as json.
func (o OptInitiateCallRequestStatusCallbackEvent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestStatusCallbackEvent from json.
func (o *OptInitiateCallRequestStatusCallbackEvent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestStatusCallbackEvent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestStatusCallbackEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestStatusCallbackEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestStatusCallbackMethod as json.
func (o OptInitiateCallRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestStatusCallbackMethod from json.
func (o *OptInitiateCallRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestTrim as json.
func (o OptInitiateCallRequestTrim) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestTrim from json.
func (o *OptInitiateCallRequestTrim) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestTrim to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallRequestUrlMethod as json.
func (o OptInitiateCallRequestUrlMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InitiateCallRequestUrlMethod from json.
func (o *OptInitiateCallRequestUrlMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallRequestUrlMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallRequestUrlMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallRequestUrlMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InitiateCallResult as json.
func (o OptInitiateCallResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InitiateCallResult from json.
func (o *OptInitiateCallResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInitiateCallResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInitiateCallResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInitiateCallResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Loopcount as json.
func (o OptLoopcount) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Loopcount from json.
func (o *OptLoopcount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoopcount to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoopcount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoopcount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MetaResponse as json.
func (o OptMetaResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MetaResponse from json.
func (o *OptMetaResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMetaResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMetaResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMetaResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewParticipantResource as json.
func (o OptNewParticipantResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NewParticipantResource from json.
func (o *OptNewParticipantResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNewParticipantResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNewParticipantResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNewParticipantResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewParticipantResourceStatus as json.
func (o OptNewParticipantResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NewParticipantResourceStatus from json.
func (o *OptNewParticipantResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNewParticipantResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNewParticipantResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNewParticipantResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConferenceSid as json.
func (o OptNilConferenceSid) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConferenceSid from json.
func (o *OptNilConferenceSid) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConferenceSid to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConferenceSid
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConferenceSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConferenceSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlErrorCode as json.
func (o OptNilTexmlErrorCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlErrorCode from json.
func (o *OptNilTexmlErrorCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTexmlErrorCode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TexmlErrorCode
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTexmlErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTexmlErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlPriceUnit as json.
func (o OptNilTexmlPriceUnit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlPriceUnit from json.
func (o *OptNilTexmlPriceUnit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTexmlPriceUnit to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TexmlPriceUnit
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTexmlPriceUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTexmlPriceUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingDuration as json.
func (o OptNilTexmlRecordingDuration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlRecordingDuration from json.
func (o *OptNilTexmlRecordingDuration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTexmlRecordingDuration to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TexmlRecordingDuration
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTexmlRecordingDuration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTexmlRecordingDuration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingPrice as json.
func (o OptNilTexmlRecordingPrice) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlRecordingPrice from json.
func (o *OptNilTexmlRecordingPrice) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTexmlRecordingPrice to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v TexmlRecordingPrice
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTexmlRecordingPrice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTexmlRecordingPrice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptNilURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NoiseSuppressionDirection as json.
func (o OptNoiseSuppressionDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NoiseSuppressionDirection from json.
func (o *OptNoiseSuppressionDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNoiseSuppressionDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNoiseSuppressionDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNoiseSuppressionDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PaginationMeta as json.
func (o OptPaginationMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PaginationMeta from json.
func (o *OptPaginationMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPaginationMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPaginationMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPaginationMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantResource as json.
func (o OptParticipantResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ParticipantResource from json.
func (o *OptParticipantResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParticipantResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParticipantResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParticipantResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantResourceIndex as json.
func (o OptParticipantResourceIndex) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ParticipantResourceIndex from json.
func (o *OptParticipantResourceIndex) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParticipantResourceIndex to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParticipantResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParticipantResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantResourceStatus as json.
func (o OptParticipantResourceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ParticipantResourceStatus from json.
func (o *OptParticipantResourceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptParticipantResourceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptParticipantResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptParticipantResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayAudioUrlRequestAudioType as json.
func (o OptPlayAudioUrlRequestAudioType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayAudioUrlRequestAudioType from json.
func (o *OptPlayAudioUrlRequestAudioType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayAudioUrlRequestAudioType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayAudioUrlRequestAudioType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayAudioUrlRequestAudioType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueueCall as json.
func (o OptQueueCall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QueueCall from json.
func (o *OptQueueCall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQueueCall to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQueueCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQueueCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingSource as json.
func (o OptRecordingSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecordingSource from json.
func (o *OptRecordingSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingTrack as json.
func (o OptRecordingTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecordingTrack from json.
func (o *OptRecordingTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterCallResponseData as json.
func (o OptRegisterCallResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RegisterCallResponseData from json.
func (o *OptRegisterCallResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegisterCallResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegisterCallResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegisterCallResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SoundModifications as json.
func (o OptSoundModifications) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SoundModifications from json.
func (o *OptSoundModifications) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSoundModifications to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSoundModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSoundModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SourceResponse as json.
func (o OptSourceResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SourceResponse from json.
func (o *OptSourceResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSourceResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSourceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSourceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestLanguage as json.
func (o OptSpeakRequestLanguage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeakRequestLanguage from json.
func (o *OptSpeakRequestLanguage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeakRequestLanguage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeakRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeakRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestPayloadType as json.
func (o OptSpeakRequestPayloadType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeakRequestPayloadType from json.
func (o *OptSpeakRequestPayloadType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeakRequestPayloadType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeakRequestPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeakRequestPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestServiceLevel as json.
func (o OptSpeakRequestServiceLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeakRequestServiceLevel from json.
func (o *OptSpeakRequestServiceLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeakRequestServiceLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeakRequestServiceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeakRequestServiceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartForkingRequestStreamType as json.
func (o OptStartForkingRequestStreamType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartForkingRequestStreamType from json.
func (o *OptStartForkingRequestStreamType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartForkingRequestStreamType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartForkingRequestStreamType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartForkingRequestStreamType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestRecordingTrack as json.
func (o OptStartRecordingRequestRecordingTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartRecordingRequestRecordingTrack from json.
func (o *OptStartRecordingRequestRecordingTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartRecordingRequestRecordingTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartRecordingRequestRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartRecordingRequestRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestTrim as json.
func (o OptStartRecordingRequestTrim) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartRecordingRequestTrim from json.
func (o *OptStartRecordingRequestTrim) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartRecordingRequestTrim to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartRecordingRequestTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartRecordingRequestTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartStreamingRequestStreamTrack as json.
func (o OptStartStreamingRequestStreamTrack) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartStreamingRequestStreamTrack from json.
func (o *OptStartStreamingRequestStreamTrack) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartStreamingRequestStreamTrack to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartStreamingRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartStreamingRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StopForkingRequestStreamType as json.
func (o OptStopForkingRequestStreamType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StopForkingRequestStreamType from json.
func (o *OptStopForkingRequestStreamType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStopForkingRequestStreamType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStopForkingRequestStreamType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStopForkingRequestStreamType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingMediaUrl as json.
func (o OptTexmlRecordingMediaUrl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlRecordingMediaUrl from json.
func (o *OptTexmlRecordingMediaUrl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlRecordingMediaUrl to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlRecordingMediaUrl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlRecordingMediaUrl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingStatus as json.
func (o OptTexmlRecordingStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TexmlRecordingStatus from json.
func (o *OptTexmlRecordingStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlRecordingStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlRecordingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlRecordingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingSubresourcesUris as json.
func (o OptTexmlRecordingSubresourcesUris) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlRecordingSubresourcesUris from json.
func (o *OptTexmlRecordingSubresourcesUris) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlRecordingSubresourcesUris to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlRecordingSubresourcesUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlRecordingSubresourcesUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingTranscriptionStatus as json.
func (o OptTexmlRecordingTranscriptionStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TexmlRecordingTranscriptionStatus from json.
func (o *OptTexmlRecordingTranscriptionStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlRecordingTranscriptionStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlRecordingTranscriptionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlRecordingTranscriptionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlSid as json.
func (o OptTexmlSid) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TexmlSid from json.
func (o *OptTexmlSid) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTexmlSid to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTexmlSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTexmlSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscriptionStartRequestLanguage as json.
func (o OptTranscriptionStartRequestLanguage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TranscriptionStartRequestLanguage from json.
func (o *OptTranscriptionStartRequestLanguage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTranscriptionStartRequestLanguage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTranscriptionStartRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTranscriptionStartRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscriptionStartRequestTranscriptionEngine as json.
func (o OptTranscriptionStartRequestTranscriptionEngine) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TranscriptionStartRequestTranscriptionEngine from json.
func (o *OptTranscriptionStartRequestTranscriptionEngine) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTranscriptionStartRequestTranscriptionEngine to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTranscriptionStartRequestTranscriptionEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTranscriptionStartRequestTranscriptionEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestAnsweringMachineDetection as json.
func (o OptTransferCallRequestAnsweringMachineDetection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferCallRequestAnsweringMachineDetection from json.
func (o *OptTransferCallRequestAnsweringMachineDetection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestAnsweringMachineDetection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestAnsweringMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestAnsweringMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestAnsweringMachineDetectionConfig as json.
func (o OptTransferCallRequestAnsweringMachineDetectionConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TransferCallRequestAnsweringMachineDetectionConfig from json.
func (o *OptTransferCallRequestAnsweringMachineDetectionConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestAnsweringMachineDetectionConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestAnsweringMachineDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestAnsweringMachineDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestMediaEncryption as json.
func (o OptTransferCallRequestMediaEncryption) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferCallRequestMediaEncryption from json.
func (o *OptTransferCallRequestMediaEncryption) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestMediaEncryption to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestMediaEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestMediaEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestSipTransportProtocol as json.
func (o OptTransferCallRequestSipTransportProtocol) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferCallRequestSipTransportProtocol from json.
func (o *OptTransferCallRequestSipTransportProtocol) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestSipTransportProtocol to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestSipTransportProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestSipTransportProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestWebhookURLMethod as json.
func (o OptTransferCallRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferCallRequestWebhookURLMethod from json.
func (o *OptTransferCallRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferCallRequestWebhookURLMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferCallRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferCallRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TwimlRecordingChannels as json.
func (o OptTwimlRecordingChannels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes TwimlRecordingChannels from json.
func (o *OptTwimlRecordingChannels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTwimlRecordingChannels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTwimlRecordingChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTwimlRecordingChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestFallbackMethod as json.
func (o OptUpdateCallRequestFallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallRequestFallbackMethod from json.
func (o *OptUpdateCallRequestFallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallRequestFallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallRequestFallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallRequestFallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestMethod as json.
func (o OptUpdateCallRequestMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallRequestMethod from json.
func (o *OptUpdateCallRequestMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallRequestMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallRequestMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallRequestMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestStatusCallbackMethod as json.
func (o OptUpdateCallRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateCallRequestStatusCallbackMethod from json.
func (o *OptUpdateCallRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCallRequestStatusCallbackMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCallRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCallRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCommandResult as json.
func (o OptUpdateCommandResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateCommandResult from json.
func (o *OptUpdateCommandResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateCommandResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateCommandResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateCommandResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginationMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginationMeta) encodeFields(e *jx.Encoder) {
	{
		if s.TotalPages.Set {
			e.FieldStart("total_pages")
			s.TotalPages.Encode(e)
		}
	}
	{
		if s.TotalResults.Set {
			e.FieldStart("total_results")
			s.TotalResults.Encode(e)
		}
	}
	{
		if s.PageNumber.Set {
			e.FieldStart("page_number")
			s.PageNumber.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfPaginationMeta = [4]string{
	0: "total_pages",
	1: "total_results",
	2: "page_number",
	3: "page_size",
}

// Decode decodes PaginationMeta from json.
func (s *PaginationMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginationMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_pages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_pages\"")
			}
		case "total_results":
			if err := func() error {
				s.TotalResults.Reset()
				if err := s.TotalResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_results\"")
			}
		case "page_number":
			if err := func() error {
				s.PageNumber.Reset()
				if err := s.PageNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_number\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginationMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginationMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginationMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantResource) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.CallSidLegacy.Set {
			e.FieldStart("call_sid_legacy")
			s.CallSidLegacy.Encode(e)
		}
	}
	{
		if s.Coaching.Set {
			e.FieldStart("coaching")
			s.Coaching.Encode(e)
		}
	}
	{
		if s.CoachingCallSid.Set {
			e.FieldStart("coaching_call_sid")
			s.CoachingCallSid.Encode(e)
		}
	}
	{
		if s.CoachingCallSidLegacy.Set {
			e.FieldStart("coaching_call_sid_legacy")
			s.CoachingCallSidLegacy.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.EndConferenceOnExit.Set {
			e.FieldStart("end_conference_on_exit")
			s.EndConferenceOnExit.Encode(e)
		}
	}
	{
		if s.Hold.Set {
			e.FieldStart("hold")
			s.Hold.Encode(e)
		}
	}
	{
		if s.Muted.Set {
			e.FieldStart("muted")
			s.Muted.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipantResource = [14]string{
	0:  "account_sid",
	1:  "api_version",
	2:  "call_sid",
	3:  "call_sid_legacy",
	4:  "coaching",
	5:  "coaching_call_sid",
	6:  "coaching_call_sid_legacy",
	7:  "date_created",
	8:  "date_updated",
	9:  "end_conference_on_exit",
	10: "hold",
	11: "muted",
	12: "status",
	13: "uri",
}

// Decode decodes ParticipantResource from json.
func (s *ParticipantResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "call_sid_legacy":
			if err := func() error {
				s.CallSidLegacy.Reset()
				if err := s.CallSidLegacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid_legacy\"")
			}
		case "coaching":
			if err := func() error {
				s.Coaching.Reset()
				if err := s.Coaching.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching\"")
			}
		case "coaching_call_sid":
			if err := func() error {
				s.CoachingCallSid.Reset()
				if err := s.CoachingCallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching_call_sid\"")
			}
		case "coaching_call_sid_legacy":
			if err := func() error {
				s.CoachingCallSidLegacy.Reset()
				if err := s.CoachingCallSidLegacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaching_call_sid_legacy\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "end_conference_on_exit":
			if err := func() error {
				s.EndConferenceOnExit.Reset()
				if err := s.EndConferenceOnExit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_conference_on_exit\"")
			}
		case "hold":
			if err := func() error {
				s.Hold.Reset()
				if err := s.Hold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hold\"")
			}
		case "muted":
			if err := func() error {
				s.Muted.Reset()
				if err := s.Muted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muted\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantResourceIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantResourceIndex) encodeFields(e *jx.Encoder) {
	{
		if s.Participants != nil {
			e.FieldStart("participants")
			e.ArrStart()
			for _, elem := range s.Participants {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipantResourceIndex = [8]string{
	0: "participants",
	1: "end",
	2: "first_page_uri",
	3: "next_page_uri",
	4: "page",
	5: "page_size",
	6: "start",
	7: "uri",
}

// Decode decodes ParticipantResourceIndex from json.
func (s *ParticipantResourceIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantResourceIndex to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participants":
			if err := func() error {
				s.Participants = make([]ParticipantResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParticipantResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantResourceIndex")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantResourceIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantResourceIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantResourceStatus as json.
func (s ParticipantResourceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParticipantResourceStatus from json.
func (s *ParticipantResourceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantResourceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParticipantResourceStatus(v) {
	case ParticipantResourceStatusConnecting:
		*s = ParticipantResourceStatusConnecting
	case ParticipantResourceStatusConnected:
		*s = ParticipantResourceStatusConnected
	case ParticipantResourceStatusCompleted:
		*s = ParticipantResourceStatusCompleted
	default:
		*s = ParticipantResourceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParticipantResourceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantResourceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PauseRecordingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PauseRecordingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPauseRecordingRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes PauseRecordingRequest from json.
func (s *PauseRecordingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PauseRecordingRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PauseRecordingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PauseRecordingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PauseRecordingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayAudioUrlRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayAudioUrlRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		if s.MediaName.Set {
			e.FieldStart("media_name")
			s.MediaName.Encode(e)
		}
	}
	{
		if s.Loop.Set {
			e.FieldStart("loop")
			s.Loop.Encode(e)
		}
	}
	{
		if s.Overlay.Set {
			e.FieldStart("overlay")
			s.Overlay.Encode(e)
		}
	}
	{
		if s.Stop.Set {
			e.FieldStart("stop")
			s.Stop.Encode(e)
		}
	}
	{
		if s.TargetLegs.Set {
			e.FieldStart("target_legs")
			s.TargetLegs.Encode(e)
		}
	}
	{
		if s.CacheAudio.Set {
			e.FieldStart("cache_audio")
			s.CacheAudio.Encode(e)
		}
	}
	{
		if s.AudioType.Set {
			e.FieldStart("audio_type")
			s.AudioType.Encode(e)
		}
	}
	{
		if s.PlaybackContent.Set {
			e.FieldStart("playback_content")
			s.PlaybackContent.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayAudioUrlRequest = [11]string{
	0:  "audio_url",
	1:  "media_name",
	2:  "loop",
	3:  "overlay",
	4:  "stop",
	5:  "target_legs",
	6:  "cache_audio",
	7:  "audio_type",
	8:  "playback_content",
	9:  "client_state",
	10: "command_id",
}

// Decode decodes PlayAudioUrlRequest from json.
func (s *PlayAudioUrlRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayAudioUrlRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "media_name":
			if err := func() error {
				s.MediaName.Reset()
				if err := s.MediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_name\"")
			}
		case "loop":
			if err := func() error {
				s.Loop.Reset()
				if err := s.Loop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loop\"")
			}
		case "overlay":
			if err := func() error {
				s.Overlay.Reset()
				if err := s.Overlay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overlay\"")
			}
		case "stop":
			if err := func() error {
				s.Stop.Reset()
				if err := s.Stop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop\"")
			}
		case "target_legs":
			if err := func() error {
				s.TargetLegs.Reset()
				if err := s.TargetLegs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_legs\"")
			}
		case "cache_audio":
			if err := func() error {
				s.CacheAudio.Reset()
				if err := s.CacheAudio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_audio\"")
			}
		case "audio_type":
			if err := func() error {
				s.AudioType.Reset()
				if err := s.AudioType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_type\"")
			}
		case "playback_content":
			if err := func() error {
				s.PlaybackContent.Reset()
				if err := s.PlaybackContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playback_content\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayAudioUrlRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayAudioUrlRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayAudioUrlRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayAudioUrlRequestAudioType as json.
func (s PlayAudioUrlRequestAudioType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayAudioUrlRequestAudioType from json.
func (s *PlayAudioUrlRequestAudioType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayAudioUrlRequestAudioType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayAudioUrlRequestAudioType(v) {
	case PlayAudioUrlRequestAudioTypeMp3:
		*s = PlayAudioUrlRequestAudioTypeMp3
	case PlayAudioUrlRequestAudioTypeWav:
		*s = PlayAudioUrlRequestAudioTypeWav
	default:
		*s = PlayAudioUrlRequestAudioType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayAudioUrlRequestAudioType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayAudioUrlRequestAudioType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlaybackStopRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlaybackStopRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Overlay.Set {
			e.FieldStart("overlay")
			s.Overlay.Encode(e)
		}
	}
	{
		if s.Stop.Set {
			e.FieldStart("stop")
			s.Stop.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlaybackStopRequest = [4]string{
	0: "overlay",
	1: "stop",
	2: "client_state",
	3: "command_id",
}

// Decode decodes PlaybackStopRequest from json.
func (s *PlaybackStopRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlaybackStopRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "overlay":
			if err := func() error {
				s.Overlay.Reset()
				if err := s.Overlay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overlay\"")
			}
		case "stop":
			if err := func() error {
				s.Stop.Reset()
				if err := s.Stop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlaybackStopRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlaybackStopRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlaybackStopRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueueCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueueCall) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("record_type")
		s.RecordType.Encode(e)
	}
	{
		e.FieldStart("call_session_id")
		e.Str(s.CallSessionID)
	}
	{
		e.FieldStart("call_leg_id")
		e.Str(s.CallLegID)
	}
	{
		e.FieldStart("call_control_id")
		e.Str(s.CallControlID)
	}
	{
		e.FieldStart("connection_id")
		e.Str(s.ConnectionID)
	}
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		e.FieldStart("enqueued_at")
		e.Str(s.EnqueuedAt)
	}
	{
		e.FieldStart("wait_time_secs")
		e.Int(s.WaitTimeSecs)
	}
	{
		e.FieldStart("queue_position")
		e.Int(s.QueuePosition)
	}
	{
		e.FieldStart("queue_id")
		e.Str(s.QueueID)
	}
}

var jsonFieldsNameOfQueueCall = [11]string{
	0:  "record_type",
	1:  "call_session_id",
	2:  "call_leg_id",
	3:  "call_control_id",
	4:  "connection_id",
	5:  "from",
	6:  "to",
	7:  "enqueued_at",
	8:  "wait_time_secs",
	9:  "queue_position",
	10: "queue_id",
}

// Decode decodes QueueCall from json.
func (s *QueueCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueueCall to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record_type\"")
			}
		case "call_session_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CallSessionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_session_id\"")
			}
		case "call_leg_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CallLegID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_leg_id\"")
			}
		case "call_control_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CallControlID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_control_id\"")
			}
		case "connection_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_id\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "enqueued_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.EnqueuedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enqueued_at\"")
			}
		case "wait_time_secs":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.WaitTimeSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wait_time_secs\"")
			}
		case "queue_position":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.QueuePosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_position\"")
			}
		case "queue_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.QueueID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueueCall")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueueCall) {
					name = jsonFieldsNameOfQueueCall[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueueCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueueCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueueCallRecordType as json.
func (s QueueCallRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes QueueCallRecordType from json.
func (s *QueueCallRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueueCallRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch QueueCallRecordType(v) {
	case QueueCallRecordTypeQueueCall:
		*s = QueueCallRecordTypeQueueCall
	default:
		*s = QueueCallRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QueueCallRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueueCallRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueueCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueueCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfQueueCallResponse = [1]string{
	0: "data",
}

// Decode decodes QueueCallResponse from json.
func (s *QueueCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueueCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueueCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueueCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueueCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingSource as json.
func (s RecordingSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordingSource from json.
func (s *RecordingSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordingSource(v) {
	case RecordingSourceStartCallRecordingAPI:
		*s = RecordingSourceStartCallRecordingAPI
	case RecordingSourceStartConferenceRecordingAPI:
		*s = RecordingSourceStartConferenceRecordingAPI
	case RecordingSourceOutboundAPI:
		*s = RecordingSourceOutboundAPI
	case RecordingSourceDialVerb:
		*s = RecordingSourceDialVerb
	case RecordingSourceConference:
		*s = RecordingSourceConference
	case RecordingSourceRecordVerb:
		*s = RecordingSourceRecordVerb
	case RecordingSourceTrunking:
		*s = RecordingSourceTrunking
	default:
		*s = RecordingSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingTrack as json.
func (s RecordingTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecordingTrack from json.
func (s *RecordingTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecordingTrack(v) {
	case RecordingTrackInbound:
		*s = RecordingTrackInbound
	case RecordingTrackOutbound:
		*s = RecordingTrackOutbound
	case RecordingTrackBoth:
		*s = RecordingTrackBoth
	default:
		*s = RecordingTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReferRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReferRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sip_address")
		e.Str(s.SipAddress)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.CustomHeaders != nil {
			e.FieldStart("custom_headers")
			e.ArrStart()
			for _, elem := range s.CustomHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SipAuthUsername.Set {
			e.FieldStart("sip_auth_username")
			s.SipAuthUsername.Encode(e)
		}
	}
	{
		if s.SipAuthPassword.Set {
			e.FieldStart("sip_auth_password")
			s.SipAuthPassword.Encode(e)
		}
	}
	{
		if s.SipHeaders != nil {
			e.FieldStart("sip_headers")
			e.ArrStart()
			for _, elem := range s.SipHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReferRequest = [7]string{
	0: "sip_address",
	1: "client_state",
	2: "command_id",
	3: "custom_headers",
	4: "sip_auth_username",
	5: "sip_auth_password",
	6: "sip_headers",
}

// Decode decodes ReferRequest from json.
func (s *ReferRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReferRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sip_address":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SipAddress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_address\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "custom_headers":
			if err := func() error {
				s.CustomHeaders = make([]CustomSipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomSipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomHeaders = append(s.CustomHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_headers\"")
			}
		case "sip_auth_username":
			if err := func() error {
				s.SipAuthUsername.Reset()
				if err := s.SipAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_username\"")
			}
		case "sip_auth_password":
			if err := func() error {
				s.SipAuthPassword.Reset()
				if err := s.SipAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_password\"")
			}
		case "sip_headers":
			if err := func() error {
				s.SipHeaders = make([]SipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SipHeaders = append(s.SipHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_headers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReferRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReferRequest) {
					name = jsonFieldsNameOfReferRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReferRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReferRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterCallRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("from")
		e.Str(s.From)
	}
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
}

var jsonFieldsNameOfRegisterCallRequest = [3]string{
	0: "from",
	1: "to",
	2: "reason",
}

// Decode decodes RegisterCallRequest from json.
func (s *RegisterCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterCallRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterCallRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterCallRequest) {
					name = jsonFieldsNameOfRegisterCallRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegisterCallResponse = [1]string{
	0: "data",
}

// Decode decodes RegisterCallResponse from json.
func (s *RegisterCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterCallResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterCallResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegisterCallResponseData = [1]string{
	0: "result",
}

// Decode decodes RegisterCallResponseData from json.
func (s *RegisterCallResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterCallResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterCallResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterCallResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterCallResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RejectRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RejectRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		e.FieldStart("cause")
		s.Cause.Encode(e)
	}
}

var jsonFieldsNameOfRejectRequest = [3]string{
	0: "client_state",
	1: "command_id",
	2: "cause",
}

// Decode decodes RejectRequest from json.
func (s *RejectRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RejectRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "cause":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Cause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cause\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RejectRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRejectRequest) {
					name = jsonFieldsNameOfRejectRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RejectRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RejectRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RejectRequestCause as json.
func (s RejectRequestCause) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RejectRequestCause from json.
func (s *RejectRequestCause) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RejectRequestCause to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RejectRequestCause(v) {
	case RejectRequestCauseCALLREJECTED:
		*s = RejectRequestCauseCALLREJECTED
	case RejectRequestCauseUSERBUSY:
		*s = RejectRequestCauseUSERBUSY
	default:
		*s = RejectRequestCause(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RejectRequestCause) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RejectRequestCause) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResumeRecordingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResumeRecordingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfResumeRecordingRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes ResumeRecordingRequest from json.
func (s *ResumeRecordingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResumeRecordingRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResumeRecordingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResumeRecordingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResumeRecordingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RetrieveCallStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RetrieveCallStatusResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfRetrieveCallStatusResponse = [1]string{
	0: "data",
}

// Decode decodes RetrieveCallStatusResponse from json.
func (s *RetrieveCallStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveCallStatusResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RetrieveCallStatusResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveCallStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveCallStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendDTMFRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendDTMFRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("digits")
		e.Str(s.Digits)
	}
	{
		if s.DurationMillis.Set {
			e.FieldStart("duration_millis")
			s.DurationMillis.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSendDTMFRequest = [4]string{
	0: "digits",
	1: "duration_millis",
	2: "client_state",
	3: "command_id",
}

// Decode decodes SendDTMFRequest from json.
func (s *SendDTMFRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendDTMFRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "digits":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Digits = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"digits\"")
			}
		case "duration_millis":
			if err := func() error {
				s.DurationMillis.Reset()
				if err := s.DurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_millis\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendDTMFRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendDTMFRequest) {
					name = jsonFieldsNameOfSendDTMFRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendDTMFRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendDTMFRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SipHeader) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SipHeader) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSipHeader = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes SipHeader from json.
func (s *SipHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SipHeader to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SipHeader")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSipHeader) {
					name = jsonFieldsNameOfSipHeader[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SipHeader) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SipHeader) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SipHeaderName as json.
func (s SipHeaderName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SipHeaderName from json.
func (s *SipHeaderName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SipHeaderName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SipHeaderName(v) {
	case SipHeaderNameUserToUser:
		*s = SipHeaderNameUserToUser
	default:
		*s = SipHeaderName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SipHeaderName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SipHeaderName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SoundModifications) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SoundModifications) encodeFields(e *jx.Encoder) {
	{
		if s.Pitch.Set {
			e.FieldStart("pitch")
			s.Pitch.Encode(e)
		}
	}
	{
		if s.Semitone.Set {
			e.FieldStart("semitone")
			s.Semitone.Encode(e)
		}
	}
	{
		if s.Octaves.Set {
			e.FieldStart("octaves")
			s.Octaves.Encode(e)
		}
	}
	{
		if s.Track.Set {
			e.FieldStart("track")
			s.Track.Encode(e)
		}
	}
}

var jsonFieldsNameOfSoundModifications = [4]string{
	0: "pitch",
	1: "semitone",
	2: "octaves",
	3: "track",
}

// Decode decodes SoundModifications from json.
func (s *SoundModifications) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SoundModifications to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pitch":
			if err := func() error {
				s.Pitch.Reset()
				if err := s.Pitch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pitch\"")
			}
		case "semitone":
			if err := func() error {
				s.Semitone.Reset()
				if err := s.Semitone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"semitone\"")
			}
		case "octaves":
			if err := func() error {
				s.Octaves.Reset()
				if err := s.Octaves.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"octaves\"")
			}
		case "track":
			if err := func() error {
				s.Track.Reset()
				if err := s.Track.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"track\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SoundModifications")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SoundModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SoundModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SourceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SourceResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Pointer.Set {
			e.FieldStart("pointer")
			s.Pointer.Encode(e)
		}
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfSourceResponse = [2]string{
	0: "pointer",
	1: "parameter",
}

// Decode decodes SourceResponse from json.
func (s *SourceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SourceResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pointer":
			if err := func() error {
				s.Pointer.Reset()
				if err := s.Pointer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pointer\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SourceResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SourceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SourceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("payload")
		e.Str(s.Payload)
	}
	{
		if s.PayloadType.Set {
			e.FieldStart("payload_type")
			s.PayloadType.Encode(e)
		}
	}
	{
		if s.ServiceLevel.Set {
			e.FieldStart("service_level")
			s.ServiceLevel.Encode(e)
		}
	}
	{
		if s.Stop.Set {
			e.FieldStart("stop")
			s.Stop.Encode(e)
		}
	}
	{
		e.FieldStart("voice")
		s.Voice.Encode(e)
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpeakRequest = [8]string{
	0: "payload",
	1: "payload_type",
	2: "service_level",
	3: "stop",
	4: "voice",
	5: "language",
	6: "client_state",
	7: "command_id",
}

// Decode decodes SpeakRequest from json.
func (s *SpeakRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequest to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "payload":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Payload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "payload_type":
			if err := func() error {
				s.PayloadType.Reset()
				if err := s.PayloadType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload_type\"")
			}
		case "service_level":
			if err := func() error {
				s.ServiceLevel.Reset()
				if err := s.ServiceLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_level\"")
			}
		case "stop":
			if err := func() error {
				s.Stop.Reset()
				if err := s.Stop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop\"")
			}
		case "voice":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Voice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakRequest) {
					name = jsonFieldsNameOfSpeakRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestLanguage as json.
func (s SpeakRequestLanguage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakRequestLanguage from json.
func (s *SpeakRequestLanguage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequestLanguage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakRequestLanguage(v) {
	case SpeakRequestLanguageArb:
		*s = SpeakRequestLanguageArb
	case SpeakRequestLanguageCmnCN:
		*s = SpeakRequestLanguageCmnCN
	case SpeakRequestLanguageCyGB:
		*s = SpeakRequestLanguageCyGB
	case SpeakRequestLanguageDaDK:
		*s = SpeakRequestLanguageDaDK
	case SpeakRequestLanguageDeDE:
		*s = SpeakRequestLanguageDeDE
	case SpeakRequestLanguageEnAU:
		*s = SpeakRequestLanguageEnAU
	case SpeakRequestLanguageEnGB:
		*s = SpeakRequestLanguageEnGB
	case SpeakRequestLanguageEnGBWLS:
		*s = SpeakRequestLanguageEnGBWLS
	case SpeakRequestLanguageEnIN:
		*s = SpeakRequestLanguageEnIN
	case SpeakRequestLanguageEnUS:
		*s = SpeakRequestLanguageEnUS
	case SpeakRequestLanguageEsES:
		*s = SpeakRequestLanguageEsES
	case SpeakRequestLanguageEsMX:
		*s = SpeakRequestLanguageEsMX
	case SpeakRequestLanguageEsUS:
		*s = SpeakRequestLanguageEsUS
	case SpeakRequestLanguageFrCA:
		*s = SpeakRequestLanguageFrCA
	case SpeakRequestLanguageFrFR:
		*s = SpeakRequestLanguageFrFR
	case SpeakRequestLanguageHiIN:
		*s = SpeakRequestLanguageHiIN
	case SpeakRequestLanguageIsIS:
		*s = SpeakRequestLanguageIsIS
	case SpeakRequestLanguageItIT:
		*s = SpeakRequestLanguageItIT
	case SpeakRequestLanguageJaJP:
		*s = SpeakRequestLanguageJaJP
	case SpeakRequestLanguageKoKR:
		*s = SpeakRequestLanguageKoKR
	case SpeakRequestLanguageNbNO:
		*s = SpeakRequestLanguageNbNO
	case SpeakRequestLanguageNlNL:
		*s = SpeakRequestLanguageNlNL
	case SpeakRequestLanguagePlPL:
		*s = SpeakRequestLanguagePlPL
	case SpeakRequestLanguagePtBR:
		*s = SpeakRequestLanguagePtBR
	case SpeakRequestLanguagePtPT:
		*s = SpeakRequestLanguagePtPT
	case SpeakRequestLanguageRoRO:
		*s = SpeakRequestLanguageRoRO
	case SpeakRequestLanguageRuRU:
		*s = SpeakRequestLanguageRuRU
	case SpeakRequestLanguageSvSE:
		*s = SpeakRequestLanguageSvSE
	case SpeakRequestLanguageTrTR:
		*s = SpeakRequestLanguageTrTR
	default:
		*s = SpeakRequestLanguage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestPayloadType as json.
func (s SpeakRequestPayloadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakRequestPayloadType from json.
func (s *SpeakRequestPayloadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequestPayloadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakRequestPayloadType(v) {
	case SpeakRequestPayloadTypeText:
		*s = SpeakRequestPayloadTypeText
	case SpeakRequestPayloadTypeSsml:
		*s = SpeakRequestPayloadTypeSsml
	default:
		*s = SpeakRequestPayloadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakRequestPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequestPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestServiceLevel as json.
func (s SpeakRequestServiceLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakRequestServiceLevel from json.
func (s *SpeakRequestServiceLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequestServiceLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakRequestServiceLevel(v) {
	case SpeakRequestServiceLevelBasic:
		*s = SpeakRequestServiceLevelBasic
	case SpeakRequestServiceLevelPremium:
		*s = SpeakRequestServiceLevelPremium
	default:
		*s = SpeakRequestServiceLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakRequestServiceLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequestServiceLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakRequestVoice as json.
func (s SpeakRequestVoice) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakRequestVoice from json.
func (s *SpeakRequestVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakRequestVoice to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakRequestVoice(v) {
	case SpeakRequestVoiceMale:
		*s = SpeakRequestVoiceMale
	case SpeakRequestVoiceFemale:
		*s = SpeakRequestVoiceFemale
	default:
		*s = SpeakRequestVoice(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakRequestVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakRequestVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartForkingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartForkingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Target.Set {
			e.FieldStart("target")
			s.Target.Encode(e)
		}
	}
	{
		if s.Rx.Set {
			e.FieldStart("rx")
			s.Rx.Encode(e)
		}
	}
	{
		if s.StreamType.Set {
			e.FieldStart("stream_type")
			s.StreamType.Encode(e)
		}
	}
	{
		if s.Tx.Set {
			e.FieldStart("tx")
			s.Tx.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartForkingRequest = [6]string{
	0: "target",
	1: "rx",
	2: "stream_type",
	3: "tx",
	4: "client_state",
	5: "command_id",
}

// Decode decodes StartForkingRequest from json.
func (s *StartForkingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartForkingRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target":
			if err := func() error {
				s.Target.Reset()
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "rx":
			if err := func() error {
				s.Rx.Reset()
				if err := s.Rx.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rx\"")
			}
		case "stream_type":
			if err := func() error {
				s.StreamType.Reset()
				if err := s.StreamType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_type\"")
			}
		case "tx":
			if err := func() error {
				s.Tx.Reset()
				if err := s.Tx.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tx\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartForkingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartForkingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartForkingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartForkingRequestStreamType as json.
func (s StartForkingRequestStreamType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartForkingRequestStreamType from json.
func (s *StartForkingRequestStreamType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartForkingRequestStreamType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartForkingRequestStreamType(v) {
	case StartForkingRequestStreamTypeRaw:
		*s = StartForkingRequestStreamTypeRaw
	case StartForkingRequestStreamTypeDecrypted:
		*s = StartForkingRequestStreamTypeDecrypted
	default:
		*s = StartForkingRequestStreamType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartForkingRequestStreamType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartForkingRequestStreamType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartRecordingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartRecordingRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		e.FieldStart("channels")
		s.Channels.Encode(e)
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.PlayBeep.Set {
			e.FieldStart("play_beep")
			s.PlayBeep.Encode(e)
		}
	}
	{
		if s.MaxLength.Set {
			e.FieldStart("max_length")
			s.MaxLength.Encode(e)
		}
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
	{
		if s.RecordingTrack.Set {
			e.FieldStart("recording_track")
			s.RecordingTrack.Encode(e)
		}
	}
	{
		if s.Trim.Set {
			e.FieldStart("trim")
			s.Trim.Encode(e)
		}
	}
	{
		if s.CustomFileName.Set {
			e.FieldStart("custom_file_name")
			s.CustomFileName.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartRecordingRequest = [10]string{
	0: "format",
	1: "channels",
	2: "client_state",
	3: "command_id",
	4: "play_beep",
	5: "max_length",
	6: "timeout_secs",
	7: "recording_track",
	8: "trim",
	9: "custom_file_name",
}

// Decode decodes StartRecordingRequest from json.
func (s *StartRecordingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequest to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "channels":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "play_beep":
			if err := func() error {
				s.PlayBeep.Reset()
				if err := s.PlayBeep.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"play_beep\"")
			}
		case "max_length":
			if err := func() error {
				s.MaxLength.Reset()
				if err := s.MaxLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_length\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		case "recording_track":
			if err := func() error {
				s.RecordingTrack.Reset()
				if err := s.RecordingTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_track\"")
			}
		case "trim":
			if err := func() error {
				s.Trim.Reset()
				if err := s.Trim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trim\"")
			}
		case "custom_file_name":
			if err := func() error {
				s.CustomFileName.Reset()
				if err := s.CustomFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_file_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartRecordingRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartRecordingRequest) {
					name = jsonFieldsNameOfStartRecordingRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartRecordingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestChannels as json.
func (s StartRecordingRequestChannels) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartRecordingRequestChannels from json.
func (s *StartRecordingRequestChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequestChannels to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartRecordingRequestChannels(v) {
	case StartRecordingRequestChannelsSingle:
		*s = StartRecordingRequestChannelsSingle
	case StartRecordingRequestChannelsDual:
		*s = StartRecordingRequestChannelsDual
	default:
		*s = StartRecordingRequestChannels(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartRecordingRequestChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequestChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestFormat as json.
func (s StartRecordingRequestFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartRecordingRequestFormat from json.
func (s *StartRecordingRequestFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequestFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartRecordingRequestFormat(v) {
	case StartRecordingRequestFormatWav:
		*s = StartRecordingRequestFormatWav
	case StartRecordingRequestFormatMp3:
		*s = StartRecordingRequestFormatMp3
	default:
		*s = StartRecordingRequestFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartRecordingRequestFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequestFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestRecordingTrack as json.
func (s StartRecordingRequestRecordingTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartRecordingRequestRecordingTrack from json.
func (s *StartRecordingRequestRecordingTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequestRecordingTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartRecordingRequestRecordingTrack(v) {
	case StartRecordingRequestRecordingTrackBoth:
		*s = StartRecordingRequestRecordingTrackBoth
	case StartRecordingRequestRecordingTrackInbound:
		*s = StartRecordingRequestRecordingTrackInbound
	case StartRecordingRequestRecordingTrackOutbound:
		*s = StartRecordingRequestRecordingTrackOutbound
	default:
		*s = StartRecordingRequestRecordingTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartRecordingRequestRecordingTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequestRecordingTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartRecordingRequestTrim as json.
func (s StartRecordingRequestTrim) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartRecordingRequestTrim from json.
func (s *StartRecordingRequestTrim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartRecordingRequestTrim to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartRecordingRequestTrim(v) {
	case StartRecordingRequestTrimTrimSilence:
		*s = StartRecordingRequestTrimTrimSilence
	default:
		*s = StartRecordingRequestTrim(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartRecordingRequestTrim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartRecordingRequestTrim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartStreamingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartStreamingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.StreamURL.Set {
			e.FieldStart("stream_url")
			s.StreamURL.Encode(e)
		}
	}
	{
		if s.StreamTrack.Set {
			e.FieldStart("stream_track")
			s.StreamTrack.Encode(e)
		}
	}
	{
		if s.EnableDialogflow.Set {
			e.FieldStart("enable_dialogflow")
			s.EnableDialogflow.Encode(e)
		}
	}
	{
		if s.DialogflowConfig.Set {
			e.FieldStart("dialogflow_config")
			s.DialogflowConfig.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartStreamingRequest = [6]string{
	0: "stream_url",
	1: "stream_track",
	2: "enable_dialogflow",
	3: "dialogflow_config",
	4: "client_state",
	5: "command_id",
}

// Decode decodes StartStreamingRequest from json.
func (s *StartStreamingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartStreamingRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stream_url":
			if err := func() error {
				s.StreamURL.Reset()
				if err := s.StreamURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_url\"")
			}
		case "stream_track":
			if err := func() error {
				s.StreamTrack.Reset()
				if err := s.StreamTrack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_track\"")
			}
		case "enable_dialogflow":
			if err := func() error {
				s.EnableDialogflow.Reset()
				if err := s.EnableDialogflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_dialogflow\"")
			}
		case "dialogflow_config":
			if err := func() error {
				s.DialogflowConfig.Reset()
				if err := s.DialogflowConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogflow_config\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartStreamingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartStreamingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartStreamingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartStreamingRequestStreamTrack as json.
func (s StartStreamingRequestStreamTrack) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartStreamingRequestStreamTrack from json.
func (s *StartStreamingRequestStreamTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartStreamingRequestStreamTrack to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartStreamingRequestStreamTrack(v) {
	case StartStreamingRequestStreamTrackInboundTrack:
		*s = StartStreamingRequestStreamTrackInboundTrack
	case StartStreamingRequestStreamTrackOutboundTrack:
		*s = StartStreamingRequestStreamTrackOutboundTrack
	case StartStreamingRequestStreamTrackBothTracks:
		*s = StartStreamingRequestStreamTrackBothTracks
	default:
		*s = StartStreamingRequestStreamTrack(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartStreamingRequestStreamTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartStreamingRequestStreamTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopForkingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopForkingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.StreamType.Set {
			e.FieldStart("stream_type")
			s.StreamType.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopForkingRequest = [3]string{
	0: "client_state",
	1: "command_id",
	2: "stream_type",
}

// Decode decodes StopForkingRequest from json.
func (s *StopForkingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopForkingRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "stream_type":
			if err := func() error {
				s.StreamType.Reset()
				if err := s.StreamType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopForkingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopForkingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopForkingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StopForkingRequestStreamType as json.
func (s StopForkingRequestStreamType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StopForkingRequestStreamType from json.
func (s *StopForkingRequestStreamType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopForkingRequestStreamType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StopForkingRequestStreamType(v) {
	case StopForkingRequestStreamTypeRaw:
		*s = StopForkingRequestStreamTypeRaw
	case StopForkingRequestStreamTypeDecrypted:
		*s = StopForkingRequestStreamTypeDecrypted
	default:
		*s = StopForkingRequestStreamType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StopForkingRequestStreamType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopForkingRequestStreamType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopGatherRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopGatherRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopGatherRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes StopGatherRequest from json.
func (s *StopGatherRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopGatherRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopGatherRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopGatherRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopGatherRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopRecordingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopRecordingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopRecordingRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes StopRecordingRequest from json.
func (s *StopRecordingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopRecordingRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopRecordingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopRecordingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopRecordingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StopStreamingRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StopStreamingRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfStopStreamingRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes StopStreamingRequest from json.
func (s *StopStreamingRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StopStreamingRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StopStreamingRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StopStreamingRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StopStreamingRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlCreateCallRecordingResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlCreateCallRecordingResponseBody) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.ConferenceSid.Set {
			e.FieldStart("conference_sid")
			s.ConferenceSid.Encode(e)
		}
	}
	{
		if s.Channels.Set {
			e.FieldStart("channels")
			s.Channels.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.PriceUnit.Set {
			e.FieldStart("price_unit")
			s.PriceUnit.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.Track.Set {
			e.FieldStart("track")
			s.Track.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlCreateCallRecordingResponseBody = [15]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "conference_sid",
	3:  "channels",
	4:  "date_created",
	5:  "date_updated",
	6:  "start_time",
	7:  "price",
	8:  "price_unit",
	9:  "duration",
	10: "sid",
	11: "source",
	12: "error_code",
	13: "track",
	14: "uri",
}

// Decode decodes TexmlCreateCallRecordingResponseBody from json.
func (s *TexmlCreateCallRecordingResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlCreateCallRecordingResponseBody to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "conference_sid":
			if err := func() error {
				s.ConferenceSid.Reset()
				if err := s.ConferenceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_sid\"")
			}
		case "channels":
			if err := func() error {
				s.Channels.Reset()
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "price_unit":
			if err := func() error {
				s.PriceUnit.Reset()
				if err := s.PriceUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price_unit\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "track":
			if err := func() error {
				s.Track.Reset()
				if err := s.Track.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"track\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlCreateCallRecordingResponseBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlCreateCallRecordingResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlCreateCallRecordingResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlErrorCode as json.
func (s TexmlErrorCode) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlErrorCode from json.
func (s *TexmlErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlErrorCode to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlErrorCode(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlGetCallRecordingResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlGetCallRecordingResponseBody) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.ConferenceSid.Set {
			e.FieldStart("conference_sid")
			s.ConferenceSid.Encode(e)
		}
	}
	{
		if s.Channels.Set {
			e.FieldStart("channels")
			s.Channels.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.SubresourcesUris.Set {
			e.FieldStart("subresources_uris")
			s.SubresourcesUris.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.MediaURL.Set {
			e.FieldStart("media_url")
			s.MediaURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlGetCallRecordingResponseBody = [15]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "conference_sid",
	3:  "channels",
	4:  "date_created",
	5:  "date_updated",
	6:  "start_time",
	7:  "duration",
	8:  "sid",
	9:  "source",
	10: "status",
	11: "error_code",
	12: "subresources_uris",
	13: "uri",
	14: "media_url",
}

// Decode decodes TexmlGetCallRecordingResponseBody from json.
func (s *TexmlGetCallRecordingResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlGetCallRecordingResponseBody to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "conference_sid":
			if err := func() error {
				s.ConferenceSid.Reset()
				if err := s.ConferenceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_sid\"")
			}
		case "channels":
			if err := func() error {
				s.Channels.Reset()
				if err := s.Channels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "subresources_uris":
			if err := func() error {
				s.SubresourcesUris.Reset()
				if err := s.SubresourcesUris.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subresources_uris\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "media_url":
			if err := func() error {
				s.MediaURL.Reset()
				if err := s.MediaURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlGetCallRecordingResponseBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlGetCallRecordingResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlGetCallRecordingResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlGetCallRecordingsResponseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlGetCallRecordingsResponseBody) encodeFields(e *jx.Encoder) {
	{
		if s.Recordings != nil {
			e.FieldStart("recordings")
			e.ArrStart()
			for _, elem := range s.Recordings {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.PreviousPageURI.Set {
			e.FieldStart("previous_page_uri")
			s.PreviousPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlGetCallRecordingsResponseBody = [9]string{
	0: "recordings",
	1: "end",
	2: "first_page_uri",
	3: "previous_page_uri",
	4: "next_page_uri",
	5: "page",
	6: "page_size",
	7: "start",
	8: "uri",
}

// Decode decodes TexmlGetCallRecordingsResponseBody from json.
func (s *TexmlGetCallRecordingsResponseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlGetCallRecordingsResponseBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recordings":
			if err := func() error {
				s.Recordings = make([]TexmlGetCallRecordingResponseBody, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TexmlGetCallRecordingResponseBody
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Recordings = append(s.Recordings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordings\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "previous_page_uri":
			if err := func() error {
				s.PreviousPageURI.Reset()
				if err := s.PreviousPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlGetCallRecordingsResponseBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlGetCallRecordingsResponseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlGetCallRecordingsResponseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlListRecordingTranscriptionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlListRecordingTranscriptionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Transcriptions != nil {
			e.FieldStart("transcriptions")
			e.ArrStart()
			for _, elem := range s.Transcriptions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.FirstPageURI.Set {
			e.FieldStart("first_page_uri")
			s.FirstPageURI.Encode(e)
		}
	}
	{
		if s.PreviousPageURI.Set {
			e.FieldStart("previous_page_uri")
			s.PreviousPageURI.Encode(e)
		}
	}
	{
		if s.NextPageURI.Set {
			e.FieldStart("next_page_uri")
			s.NextPageURI.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlListRecordingTranscriptionResponse = [9]string{
	0: "transcriptions",
	1: "end",
	2: "first_page_uri",
	3: "previous_page_uri",
	4: "next_page_uri",
	5: "page",
	6: "page_size",
	7: "start",
	8: "uri",
}

// Decode decodes TexmlListRecordingTranscriptionResponse from json.
func (s *TexmlListRecordingTranscriptionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlListRecordingTranscriptionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transcriptions":
			if err := func() error {
				s.Transcriptions = make([]TexmlRecordingTranscription, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TexmlRecordingTranscription
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transcriptions = append(s.Transcriptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcriptions\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "first_page_uri":
			if err := func() error {
				s.FirstPageURI.Reset()
				if err := s.FirstPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_page_uri\"")
			}
		case "previous_page_uri":
			if err := func() error {
				s.PreviousPageURI.Reset()
				if err := s.PreviousPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_page_uri\"")
			}
		case "next_page_uri":
			if err := func() error {
				s.NextPageURI.Reset()
				if err := s.NextPageURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_uri\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlListRecordingTranscriptionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlListRecordingTranscriptionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlListRecordingTranscriptionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlPriceUnit as json.
func (s TexmlPriceUnit) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlPriceUnit from json.
func (s *TexmlPriceUnit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlPriceUnit to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlPriceUnit(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlPriceUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlPriceUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingDuration as json.
func (s TexmlRecordingDuration) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlRecordingDuration from json.
func (s *TexmlRecordingDuration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingDuration to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlRecordingDuration(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingDuration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingDuration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingMediaUrl as json.
func (s TexmlRecordingMediaUrl) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)

	json.EncodeURI(e, unwrapped)
}

// Decode decodes TexmlRecordingMediaUrl from json.
func (s *TexmlRecordingMediaUrl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingMediaUrl to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlRecordingMediaUrl(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingMediaUrl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingMediaUrl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingPrice as json.
func (s TexmlRecordingPrice) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlRecordingPrice from json.
func (s *TexmlRecordingPrice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingPrice to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlRecordingPrice(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingPrice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingPrice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingStatus as json.
func (s TexmlRecordingStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TexmlRecordingStatus from json.
func (s *TexmlRecordingStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TexmlRecordingStatus(v) {
	case TexmlRecordingStatusInProgress:
		*s = TexmlRecordingStatusInProgress
	case TexmlRecordingStatusCompleted:
		*s = TexmlRecordingStatusCompleted
	case TexmlRecordingStatusPaused:
		*s = TexmlRecordingStatusPaused
	case TexmlRecordingStatusStopped:
		*s = TexmlRecordingStatusStopped
	default:
		*s = TexmlRecordingStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlRecordingSubresourcesUris) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlRecordingSubresourcesUris) encodeFields(e *jx.Encoder) {
	{
		if s.Transcriptions.Set {
			e.FieldStart("transcriptions")
			s.Transcriptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlRecordingSubresourcesUris = [1]string{
	0: "transcriptions",
}

// Decode decodes TexmlRecordingSubresourcesUris from json.
func (s *TexmlRecordingSubresourcesUris) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingSubresourcesUris to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transcriptions":
			if err := func() error {
				s.Transcriptions.Reset()
				if err := s.Transcriptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcriptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlRecordingSubresourcesUris")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlRecordingSubresourcesUris) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingSubresourcesUris) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TexmlRecordingTranscription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TexmlRecordingTranscription) encodeFields(e *jx.Encoder) {
	{
		if s.AccountSid.Set {
			e.FieldStart("account_sid")
			s.AccountSid.Encode(e)
		}
	}
	{
		if s.CallSid.Set {
			e.FieldStart("call_sid")
			s.CallSid.Encode(e)
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.DateCreated.Set {
			e.FieldStart("date_created")
			s.DateCreated.Encode(e)
		}
	}
	{
		if s.DateUpdated.Set {
			e.FieldStart("date_updated")
			s.DateUpdated.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.RecordingSid.Set {
			e.FieldStart("recording_sid")
			s.RecordingSid.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TranscriptionText.Set {
			e.FieldStart("transcription_text")
			s.TranscriptionText.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfTexmlRecordingTranscription = [11]string{
	0:  "account_sid",
	1:  "call_sid",
	2:  "api_version",
	3:  "date_created",
	4:  "date_updated",
	5:  "duration",
	6:  "sid",
	7:  "recording_sid",
	8:  "status",
	9:  "transcription_text",
	10: "uri",
}

// Decode decodes TexmlRecordingTranscription from json.
func (s *TexmlRecordingTranscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingTranscription to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "account_sid":
			if err := func() error {
				s.AccountSid.Reset()
				if err := s.AccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_sid\"")
			}
		case "call_sid":
			if err := func() error {
				s.CallSid.Reset()
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "date_created":
			if err := func() error {
				s.DateCreated.Reset()
				if err := s.DateCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_updated":
			if err := func() error {
				s.DateUpdated.Reset()
				if err := s.DateUpdated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_updated\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "recording_sid":
			if err := func() error {
				s.RecordingSid.Reset()
				if err := s.RecordingSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_sid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "transcription_text":
			if err := func() error {
				s.TranscriptionText.Reset()
				if err := s.TranscriptionText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription_text\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TexmlRecordingTranscription")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TexmlRecordingTranscription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingTranscription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlRecordingTranscriptionStatus as json.
func (s TexmlRecordingTranscriptionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TexmlRecordingTranscriptionStatus from json.
func (s *TexmlRecordingTranscriptionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlRecordingTranscriptionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TexmlRecordingTranscriptionStatus(v) {
	case TexmlRecordingTranscriptionStatusInProgress:
		*s = TexmlRecordingTranscriptionStatusInProgress
	case TexmlRecordingTranscriptionStatusCompleted:
		*s = TexmlRecordingTranscriptionStatusCompleted
	default:
		*s = TexmlRecordingTranscriptionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlRecordingTranscriptionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlRecordingTranscriptionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TexmlSid as json.
func (s TexmlSid) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TexmlSid from json.
func (s *TexmlSid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TexmlSid to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TexmlSid(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TexmlSid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TexmlSid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TranscriptionStartRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TranscriptionStartRequest) encodeFields(e *jx.Encoder) {
	{
		if s.TranscriptionEngine.Set {
			e.FieldStart("transcription_engine")
			s.TranscriptionEngine.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.InterimResults.Set {
			e.FieldStart("interim_results")
			s.InterimResults.Encode(e)
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.TranscriptionTracks.Set {
			e.FieldStart("transcription_tracks")
			s.TranscriptionTracks.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTranscriptionStartRequest = [6]string{
	0: "transcription_engine",
	1: "language",
	2: "interim_results",
	3: "client_state",
	4: "transcription_tracks",
	5: "command_id",
}

// Decode decodes TranscriptionStartRequest from json.
func (s *TranscriptionStartRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionStartRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transcription_engine":
			if err := func() error {
				s.TranscriptionEngine.Reset()
				if err := s.TranscriptionEngine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription_engine\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "interim_results":
			if err := func() error {
				s.InterimResults.Reset()
				if err := s.InterimResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interim_results\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "transcription_tracks":
			if err := func() error {
				s.TranscriptionTracks.Reset()
				if err := s.TranscriptionTracks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription_tracks\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TranscriptionStartRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TranscriptionStartRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionStartRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscriptionStartRequestLanguage as json.
func (s TranscriptionStartRequestLanguage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TranscriptionStartRequestLanguage from json.
func (s *TranscriptionStartRequestLanguage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionStartRequestLanguage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TranscriptionStartRequestLanguage(v) {
	case TranscriptionStartRequestLanguageDe:
		*s = TranscriptionStartRequestLanguageDe
	case TranscriptionStartRequestLanguageEn:
		*s = TranscriptionStartRequestLanguageEn
	case TranscriptionStartRequestLanguageEs:
		*s = TranscriptionStartRequestLanguageEs
	case TranscriptionStartRequestLanguageFr:
		*s = TranscriptionStartRequestLanguageFr
	case TranscriptionStartRequestLanguageIt:
		*s = TranscriptionStartRequestLanguageIt
	case TranscriptionStartRequestLanguagePl:
		*s = TranscriptionStartRequestLanguagePl
	default:
		*s = TranscriptionStartRequestLanguage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TranscriptionStartRequestLanguage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionStartRequestLanguage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TranscriptionStartRequestTranscriptionEngine as json.
func (s TranscriptionStartRequestTranscriptionEngine) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TranscriptionStartRequestTranscriptionEngine from json.
func (s *TranscriptionStartRequestTranscriptionEngine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionStartRequestTranscriptionEngine to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TranscriptionStartRequestTranscriptionEngine(v) {
	case TranscriptionStartRequestTranscriptionEngineA:
		*s = TranscriptionStartRequestTranscriptionEngineA
	case TranscriptionStartRequestTranscriptionEngineB:
		*s = TranscriptionStartRequestTranscriptionEngineB
	default:
		*s = TranscriptionStartRequestTranscriptionEngine(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TranscriptionStartRequestTranscriptionEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionStartRequestTranscriptionEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TranscriptionStopRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TranscriptionStopRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTranscriptionStopRequest = [2]string{
	0: "client_state",
	1: "command_id",
}

// Decode decodes TranscriptionStopRequest from json.
func (s *TranscriptionStopRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TranscriptionStopRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TranscriptionStopRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TranscriptionStopRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TranscriptionStopRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferCallRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("to")
		e.Str(s.To)
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.FromDisplayName.Set {
			e.FieldStart("from_display_name")
			s.FromDisplayName.Encode(e)
		}
	}
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		if s.MediaName.Set {
			e.FieldStart("media_name")
			s.MediaName.Encode(e)
		}
	}
	{
		if s.TimeoutSecs.Set {
			e.FieldStart("timeout_secs")
			s.TimeoutSecs.Encode(e)
		}
	}
	{
		if s.TimeLimitSecs.Set {
			e.FieldStart("time_limit_secs")
			s.TimeLimitSecs.Encode(e)
		}
	}
	{
		if s.AnsweringMachineDetection.Set {
			e.FieldStart("answering_machine_detection")
			s.AnsweringMachineDetection.Encode(e)
		}
	}
	{
		if s.AnsweringMachineDetectionConfig.Set {
			e.FieldStart("answering_machine_detection_config")
			s.AnsweringMachineDetectionConfig.Encode(e)
		}
	}
	{
		if s.CustomHeaders != nil {
			e.FieldStart("custom_headers")
			e.ArrStart()
			for _, elem := range s.CustomHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ClientState.Set {
			e.FieldStart("client_state")
			s.ClientState.Encode(e)
		}
	}
	{
		if s.TargetLegClientState.Set {
			e.FieldStart("target_leg_client_state")
			s.TargetLegClientState.Encode(e)
		}
	}
	{
		if s.CommandID.Set {
			e.FieldStart("command_id")
			s.CommandID.Encode(e)
		}
	}
	{
		if s.MediaEncryption.Set {
			e.FieldStart("media_encryption")
			s.MediaEncryption.Encode(e)
		}
	}
	{
		if s.SipAuthUsername.Set {
			e.FieldStart("sip_auth_username")
			s.SipAuthUsername.Encode(e)
		}
	}
	{
		if s.SipAuthPassword.Set {
			e.FieldStart("sip_auth_password")
			s.SipAuthPassword.Encode(e)
		}
	}
	{
		if s.SipHeaders != nil {
			e.FieldStart("sip_headers")
			e.ArrStart()
			for _, elem := range s.SipHeaders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SipTransportProtocol.Set {
			e.FieldStart("sip_transport_protocol")
			s.SipTransportProtocol.Encode(e)
		}
	}
	{
		if s.SoundModifications.Set {
			e.FieldStart("sound_modifications")
			s.SoundModifications.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhook_url")
			s.WebhookURL.Encode(e)
		}
	}
	{
		if s.WebhookURLMethod.Set {
			e.FieldStart("webhook_url_method")
			s.WebhookURLMethod.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransferCallRequest = [21]string{
	0:  "to",
	1:  "from",
	2:  "from_display_name",
	3:  "audio_url",
	4:  "media_name",
	5:  "timeout_secs",
	6:  "time_limit_secs",
	7:  "answering_machine_detection",
	8:  "answering_machine_detection_config",
	9:  "custom_headers",
	10: "client_state",
	11: "target_leg_client_state",
	12: "command_id",
	13: "media_encryption",
	14: "sip_auth_username",
	15: "sip_auth_password",
	16: "sip_headers",
	17: "sip_transport_protocol",
	18: "sound_modifications",
	19: "webhook_url",
	20: "webhook_url_method",
}

// Decode decodes TransferCallRequest from json.
func (s *TransferCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequest to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "to":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "from_display_name":
			if err := func() error {
				s.FromDisplayName.Reset()
				if err := s.FromDisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_display_name\"")
			}
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "media_name":
			if err := func() error {
				s.MediaName.Reset()
				if err := s.MediaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_name\"")
			}
		case "timeout_secs":
			if err := func() error {
				s.TimeoutSecs.Reset()
				if err := s.TimeoutSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_secs\"")
			}
		case "time_limit_secs":
			if err := func() error {
				s.TimeLimitSecs.Reset()
				if err := s.TimeLimitSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_limit_secs\"")
			}
		case "answering_machine_detection":
			if err := func() error {
				s.AnsweringMachineDetection.Reset()
				if err := s.AnsweringMachineDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answering_machine_detection\"")
			}
		case "answering_machine_detection_config":
			if err := func() error {
				s.AnsweringMachineDetectionConfig.Reset()
				if err := s.AnsweringMachineDetectionConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answering_machine_detection_config\"")
			}
		case "custom_headers":
			if err := func() error {
				s.CustomHeaders = make([]CustomSipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CustomSipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CustomHeaders = append(s.CustomHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_headers\"")
			}
		case "client_state":
			if err := func() error {
				s.ClientState.Reset()
				if err := s.ClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_state\"")
			}
		case "target_leg_client_state":
			if err := func() error {
				s.TargetLegClientState.Reset()
				if err := s.TargetLegClientState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_leg_client_state\"")
			}
		case "command_id":
			if err := func() error {
				s.CommandID.Reset()
				if err := s.CommandID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command_id\"")
			}
		case "media_encryption":
			if err := func() error {
				s.MediaEncryption.Reset()
				if err := s.MediaEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_encryption\"")
			}
		case "sip_auth_username":
			if err := func() error {
				s.SipAuthUsername.Reset()
				if err := s.SipAuthUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_username\"")
			}
		case "sip_auth_password":
			if err := func() error {
				s.SipAuthPassword.Reset()
				if err := s.SipAuthPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_auth_password\"")
			}
		case "sip_headers":
			if err := func() error {
				s.SipHeaders = make([]SipHeader, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SipHeader
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SipHeaders = append(s.SipHeaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_headers\"")
			}
		case "sip_transport_protocol":
			if err := func() error {
				s.SipTransportProtocol.Reset()
				if err := s.SipTransportProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_transport_protocol\"")
			}
		case "sound_modifications":
			if err := func() error {
				s.SoundModifications.Reset()
				if err := s.SoundModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sound_modifications\"")
			}
		case "webhook_url":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		case "webhook_url_method":
			if err := func() error {
				s.WebhookURLMethod.Reset()
				if err := s.WebhookURLMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url_method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferCallRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransferCallRequest) {
					name = jsonFieldsNameOfTransferCallRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestAnsweringMachineDetection as json.
func (s TransferCallRequestAnsweringMachineDetection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferCallRequestAnsweringMachineDetection from json.
func (s *TransferCallRequestAnsweringMachineDetection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestAnsweringMachineDetection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferCallRequestAnsweringMachineDetection(v) {
	case TransferCallRequestAnsweringMachineDetectionPremium:
		*s = TransferCallRequestAnsweringMachineDetectionPremium
	case TransferCallRequestAnsweringMachineDetectionDetect:
		*s = TransferCallRequestAnsweringMachineDetectionDetect
	case TransferCallRequestAnsweringMachineDetectionDetectBeep:
		*s = TransferCallRequestAnsweringMachineDetectionDetectBeep
	case TransferCallRequestAnsweringMachineDetectionDetectWords:
		*s = TransferCallRequestAnsweringMachineDetectionDetectWords
	case TransferCallRequestAnsweringMachineDetectionGreetingEnd:
		*s = TransferCallRequestAnsweringMachineDetectionGreetingEnd
	case TransferCallRequestAnsweringMachineDetectionDisabled:
		*s = TransferCallRequestAnsweringMachineDetectionDisabled
	default:
		*s = TransferCallRequestAnsweringMachineDetection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferCallRequestAnsweringMachineDetection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestAnsweringMachineDetection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) encodeFields(e *jx.Encoder) {
	{
		if s.TotalAnalysisTimeMillis.Set {
			e.FieldStart("total_analysis_time_millis")
			s.TotalAnalysisTimeMillis.Encode(e)
		}
	}
	{
		if s.AfterGreetingSilenceMillis.Set {
			e.FieldStart("after_greeting_silence_millis")
			s.AfterGreetingSilenceMillis.Encode(e)
		}
	}
	{
		if s.BetweenWordsSilenceMillis.Set {
			e.FieldStart("between_words_silence_millis")
			s.BetweenWordsSilenceMillis.Encode(e)
		}
	}
	{
		if s.GreetingDurationMillis.Set {
			e.FieldStart("greeting_duration_millis")
			s.GreetingDurationMillis.Encode(e)
		}
	}
	{
		if s.InitialSilenceMillis.Set {
			e.FieldStart("initial_silence_millis")
			s.InitialSilenceMillis.Encode(e)
		}
	}
	{
		if s.MaximumNumberOfWords.Set {
			e.FieldStart("maximum_number_of_words")
			s.MaximumNumberOfWords.Encode(e)
		}
	}
	{
		if s.MaximumWordLengthMillis.Set {
			e.FieldStart("maximum_word_length_millis")
			s.MaximumWordLengthMillis.Encode(e)
		}
	}
	{
		if s.SilenceThreshold.Set {
			e.FieldStart("silence_threshold")
			s.SilenceThreshold.Encode(e)
		}
	}
	{
		if s.GreetingTotalAnalysisTimeMillis.Set {
			e.FieldStart("greeting_total_analysis_time_millis")
			s.GreetingTotalAnalysisTimeMillis.Encode(e)
		}
	}
	{
		if s.GreetingSilenceDurationMillis.Set {
			e.FieldStart("greeting_silence_duration_millis")
			s.GreetingSilenceDurationMillis.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransferCallRequestAnsweringMachineDetectionConfig = [10]string{
	0: "total_analysis_time_millis",
	1: "after_greeting_silence_millis",
	2: "between_words_silence_millis",
	3: "greeting_duration_millis",
	4: "initial_silence_millis",
	5: "maximum_number_of_words",
	6: "maximum_word_length_millis",
	7: "silence_threshold",
	8: "greeting_total_analysis_time_millis",
	9: "greeting_silence_duration_millis",
}

// Decode decodes TransferCallRequestAnsweringMachineDetectionConfig from json.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestAnsweringMachineDetectionConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_analysis_time_millis":
			if err := func() error {
				s.TotalAnalysisTimeMillis.Reset()
				if err := s.TotalAnalysisTimeMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_analysis_time_millis\"")
			}
		case "after_greeting_silence_millis":
			if err := func() error {
				s.AfterGreetingSilenceMillis.Reset()
				if err := s.AfterGreetingSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"after_greeting_silence_millis\"")
			}
		case "between_words_silence_millis":
			if err := func() error {
				s.BetweenWordsSilenceMillis.Reset()
				if err := s.BetweenWordsSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"between_words_silence_millis\"")
			}
		case "greeting_duration_millis":
			if err := func() error {
				s.GreetingDurationMillis.Reset()
				if err := s.GreetingDurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_duration_millis\"")
			}
		case "initial_silence_millis":
			if err := func() error {
				s.InitialSilenceMillis.Reset()
				if err := s.InitialSilenceMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initial_silence_millis\"")
			}
		case "maximum_number_of_words":
			if err := func() error {
				s.MaximumNumberOfWords.Reset()
				if err := s.MaximumNumberOfWords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_number_of_words\"")
			}
		case "maximum_word_length_millis":
			if err := func() error {
				s.MaximumWordLengthMillis.Reset()
				if err := s.MaximumWordLengthMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_word_length_millis\"")
			}
		case "silence_threshold":
			if err := func() error {
				s.SilenceThreshold.Reset()
				if err := s.SilenceThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"silence_threshold\"")
			}
		case "greeting_total_analysis_time_millis":
			if err := func() error {
				s.GreetingTotalAnalysisTimeMillis.Reset()
				if err := s.GreetingTotalAnalysisTimeMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_total_analysis_time_millis\"")
			}
		case "greeting_silence_duration_millis":
			if err := func() error {
				s.GreetingSilenceDurationMillis.Reset()
				if err := s.GreetingSilenceDurationMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"greeting_silence_duration_millis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferCallRequestAnsweringMachineDetectionConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestAnsweringMachineDetectionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestMediaEncryption as json.
func (s TransferCallRequestMediaEncryption) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferCallRequestMediaEncryption from json.
func (s *TransferCallRequestMediaEncryption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestMediaEncryption to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferCallRequestMediaEncryption(v) {
	case TransferCallRequestMediaEncryptionDisabled:
		*s = TransferCallRequestMediaEncryptionDisabled
	case TransferCallRequestMediaEncryptionSRTP:
		*s = TransferCallRequestMediaEncryptionSRTP
	default:
		*s = TransferCallRequestMediaEncryption(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferCallRequestMediaEncryption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestMediaEncryption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestSipTransportProtocol as json.
func (s TransferCallRequestSipTransportProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferCallRequestSipTransportProtocol from json.
func (s *TransferCallRequestSipTransportProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestSipTransportProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferCallRequestSipTransportProtocol(v) {
	case TransferCallRequestSipTransportProtocolUDP:
		*s = TransferCallRequestSipTransportProtocolUDP
	case TransferCallRequestSipTransportProtocolTCP:
		*s = TransferCallRequestSipTransportProtocolTCP
	case TransferCallRequestSipTransportProtocolTLS:
		*s = TransferCallRequestSipTransportProtocolTLS
	default:
		*s = TransferCallRequestSipTransportProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferCallRequestSipTransportProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestSipTransportProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferCallRequestWebhookURLMethod as json.
func (s TransferCallRequestWebhookURLMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferCallRequestWebhookURLMethod from json.
func (s *TransferCallRequestWebhookURLMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferCallRequestWebhookURLMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferCallRequestWebhookURLMethod(v) {
	case TransferCallRequestWebhookURLMethodPOST:
		*s = TransferCallRequestWebhookURLMethodPOST
	case TransferCallRequestWebhookURLMethodGET:
		*s = TransferCallRequestWebhookURLMethodGET
	default:
		*s = TransferCallRequestWebhookURLMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferCallRequestWebhookURLMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferCallRequestWebhookURLMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TwimlRecordingChannels as json.
func (s TwimlRecordingChannels) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes TwimlRecordingChannels from json.
func (s *TwimlRecordingChannels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TwimlRecordingChannels to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = TwimlRecordingChannels(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TwimlRecordingChannels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TwimlRecordingChannels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCallRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCallRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("Status")
			s.Status.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("Url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("Method")
			s.Method.Encode(e)
		}
	}
	{
		if s.FallbackUrl.Set {
			e.FieldStart("FallbackUrl")
			s.FallbackUrl.Encode(e)
		}
	}
	{
		if s.FallbackMethod.Set {
			e.FieldStart("FallbackMethod")
			s.FallbackMethod.Encode(e)
		}
	}
	{
		if s.StatusCallback.Set {
			e.FieldStart("StatusCallback")
			s.StatusCallback.Encode(e)
		}
	}
	{
		if s.StatusCallbackMethod.Set {
			e.FieldStart("StatusCallbackMethod")
			s.StatusCallbackMethod.Encode(e)
		}
	}
	{
		if s.Texml.Set {
			e.FieldStart("Texml")
			s.Texml.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCallRequest = [8]string{
	0: "Status",
	1: "Url",
	2: "Method",
	3: "FallbackUrl",
	4: "FallbackMethod",
	5: "StatusCallback",
	6: "StatusCallbackMethod",
	7: "Texml",
}

// Decode decodes UpdateCallRequest from json.
func (s *UpdateCallRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Status\"")
			}
		case "Url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Url\"")
			}
		case "Method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Method\"")
			}
		case "FallbackUrl":
			if err := func() error {
				s.FallbackUrl.Reset()
				if err := s.FallbackUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FallbackUrl\"")
			}
		case "FallbackMethod":
			if err := func() error {
				s.FallbackMethod.Reset()
				if err := s.FallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FallbackMethod\"")
			}
		case "StatusCallback":
			if err := func() error {
				s.StatusCallback.Reset()
				if err := s.StatusCallback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallback\"")
			}
		case "StatusCallbackMethod":
			if err := func() error {
				s.StatusCallbackMethod.Reset()
				if err := s.StatusCallbackMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"StatusCallbackMethod\"")
			}
		case "Texml":
			if err := func() error {
				s.Texml.Reset()
				if err := s.Texml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Texml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCallRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCallRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestFallbackMethod as json.
func (s UpdateCallRequestFallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallRequestFallbackMethod from json.
func (s *UpdateCallRequestFallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallRequestFallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallRequestFallbackMethod(v) {
	case UpdateCallRequestFallbackMethodGET:
		*s = UpdateCallRequestFallbackMethodGET
	case UpdateCallRequestFallbackMethodPOST:
		*s = UpdateCallRequestFallbackMethodPOST
	default:
		*s = UpdateCallRequestFallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallRequestFallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallRequestFallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestMethod as json.
func (s UpdateCallRequestMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallRequestMethod from json.
func (s *UpdateCallRequestMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallRequestMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallRequestMethod(v) {
	case UpdateCallRequestMethodGET:
		*s = UpdateCallRequestMethodGET
	case UpdateCallRequestMethodPOST:
		*s = UpdateCallRequestMethodPOST
	default:
		*s = UpdateCallRequestMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallRequestMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallRequestMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCallRequestStatusCallbackMethod as json.
func (s UpdateCallRequestStatusCallbackMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCallRequestStatusCallbackMethod from json.
func (s *UpdateCallRequestStatusCallbackMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCallRequestStatusCallbackMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCallRequestStatusCallbackMethod(v) {
	case UpdateCallRequestStatusCallbackMethodGET:
		*s = UpdateCallRequestStatusCallbackMethodGET
	case UpdateCallRequestStatusCallbackMethodPOST:
		*s = UpdateCallRequestStatusCallbackMethodPOST
	default:
		*s = UpdateCallRequestStatusCallbackMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCallRequestStatusCallbackMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCallRequestStatusCallbackMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCommandResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCommandResult) encodeFields(e *jx.Encoder) {
	{
		if s.Sid.Set {
			e.FieldStart("sid")
			s.Sid.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCommandResult = [2]string{
	0: "sid",
	1: "status",
}

// Decode decodes UpdateCommandResult from json.
func (s *UpdateCommandResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCommandResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sid":
			if err := func() error {
				s.Sid.Reset()
				if err := s.Sid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCommandResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCommandResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCommandResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTeXMLCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTeXMLCallResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTeXMLCallResponse = [1]string{
	0: "data",
}

// Decode decodes UpdateTeXMLCallResponse from json.
func (s *UpdateTeXMLCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTeXMLCallResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTeXMLCallResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTeXMLCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTeXMLCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
