// Code generated by ogen, DO NOT EDIT.

package telnyx

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AnswerCall invokes AnswerCall operation.
	//
	// Answer an incoming call. You must issue this command before executing subsequent commands on an
	// incoming call.
	// **Expected Webhooks:**
	// - `call.answered`
	// - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set.
	//
	// POST /calls/{call_control_id}/actions/answer
	AnswerCall(ctx context.Context, request *AnswerRequest, params AnswerCallParams) (AnswerCallRes, error)
	// AudioPublicAudioTranscriptionsPost invokes audio_public_audio_transcriptions_post operation.
	//
	// Transcribe speech to text. This endpoint is consistent with the [OpenAI Transcription
	// API](https://platform.openai.com/docs/api-reference/audio/createTranscription) and may be used
	// with the OpenAI JS or Python SDK.
	//
	// POST /ai/audio/transcriptions
	AudioPublicAudioTranscriptionsPost(ctx context.Context, request *AudioTranscriptionRequestMultipart) (AudioPublicAudioTranscriptionsPostRes, error)
	// BridgeCall invokes BridgeCall operation.
	//
	// Bridge two call control calls.
	// **Expected Webhooks:**
	// - `call.bridged` for Leg A
	// - `call.bridged` for Leg B.
	//
	// POST /calls/{call_control_id}/actions/bridge
	BridgeCall(ctx context.Context, request *BridgeRequest, params BridgeCallParams) (BridgeCallRes, error)
	// BulkCredentialAction invokes BulkCredentialAction operation.
	//
	// Perform activate or deactivate action on all credentials filtered by the provided tag. Activate
	// action will change the status to active, making it possible to connect calls with the credential.
	// Deactivate action will change the status to inactive, making it impossible to connect calls with
	// the credential.
	//
	// POST /actions/{action}/telephony_credentials
	BulkCredentialAction(ctx context.Context, params BulkCredentialActionParams) (BulkCredentialActionRes, error)
	// CreateBulkTelephonyCredentials invokes CreateBulkTelephonyCredentials operation.
	//
	// Creates several credentials in bulk.
	//
	// POST /actions/bulk/telephony_credentials
	CreateBulkTelephonyCredentials(ctx context.Context, request *BulkCredentialRequest) (CreateBulkTelephonyCredentialsRes, error)
	// CreateCallControlApplication invokes CreateCallControlApplication operation.
	//
	// Create a call control application.
	//
	// POST /call_control_applications
	CreateCallControlApplication(ctx context.Context, request *CreateCallControlApplicationRequest) (CreateCallControlApplicationRes, error)
	// CreateCustomStorageCredentials invokes CreateCustomStorageCredentials operation.
	//
	// Creates a custom storage credentials configuration.
	//
	// POST /custom_storage_credentials/{connection_id}
	CreateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params CreateCustomStorageCredentialsParams) (CreateCustomStorageCredentialsRes, error)
	// CreateFlashcallVerification invokes CreateFlashcallVerification operation.
	//
	// Trigger Flash call verification.
	//
	// POST /verifications/flashcall
	CreateFlashcallVerification(ctx context.Context, request *CreateVerificationRequestFlashcall) (CreateFlashcallVerificationRes, error)
	// CreateProfile invokes CreateProfile operation.
	//
	// Creates a Verified Calls Display Profile associated with the given Business Identity.
	//
	// POST /verified_calls_display_profiles
	CreateProfile(ctx context.Context, request *CreateVerifiedCallsDisplayProfileRequest) (CreateProfileRes, error)
	// CreateProfileVerificationRequest invokes CreateProfileVerificationRequest operation.
	//
	// Starts a new Verified Calls Display Profile verification process.
	//
	// POST /verified_calls_display_profiles/{id}/verification_request
	CreateProfileVerificationRequest(ctx context.Context, params CreateProfileVerificationRequestParams) (CreateProfileVerificationRequestRes, error)
	// CreateTelephonyCredential invokes CreateTelephonyCredential operation.
	//
	// Create a credential.
	//
	// POST /telephony_credentials
	CreateTelephonyCredential(ctx context.Context, request *TelephonyCredentialCreateRequest) (CreateTelephonyCredentialRes, error)
	// CreateTelephonyCredentialToken invokes CreateTelephonyCredentialToken operation.
	//
	// Create an Access Token (JWT) for the credential.
	//
	// POST /telephony_credentials/{id}/token
	CreateTelephonyCredentialToken(ctx context.Context, params CreateTelephonyCredentialTokenParams) (CreateTelephonyCredentialTokenRes, error)
	// CreateTexmlApplication invokes CreateTexmlApplication operation.
	//
	// Creates a TeXML Application.
	//
	// POST /texml_applications
	CreateTexmlApplication(ctx context.Context, request *CreateTexmlApplicationRequest) (CreateTexmlApplicationRes, error)
	// CreateTexmlSecret invokes CreateTexmlSecret operation.
	//
	// Create a TeXML secret which can be later used as a Dynamic Parameter for TeXML when using Mustache
	// Templates in your TeXML. In your TeXML you will be able to use your secret name, and this name
	// will be replaced by the actual secret value when processing the TeXML on Telnyx side.  The secrets
	// are not visible in any logs.
	//
	// POST /texml/secrets
	CreateTexmlSecret(ctx context.Context, request *CreateTeXMLSecretRequest) (CreateTexmlSecretRes, error)
	// CreateVerificationCall invokes CreateVerificationCall operation.
	//
	// Trigger Call verification.
	//
	// POST /verifications/call
	CreateVerificationCall(ctx context.Context, request *CreateVerificationRequestCall) (CreateVerificationCallRes, error)
	// CreateVerificationSms invokes CreateVerificationSms operation.
	//
	// Trigger SMS verification.
	//
	// POST /verifications/sms
	CreateVerificationSms(ctx context.Context, request *CreateVerificationRequestSMS) (CreateVerificationSmsRes, error)
	// CreateVerifiedNumber invokes CreateVerifiedNumber operation.
	//
	// Initiates phone number verification procedure.
	//
	// POST /verified_numbers
	CreateVerifiedNumber(ctx context.Context, request *CreateVerifiedNumberReq) (CreateVerifiedNumberRes, error)
	// CreateVerifyProfile invokes CreateVerifyProfile operation.
	//
	// Creates a new Verify profile to associate verifications with.
	//
	// POST /verify_profiles
	CreateVerifyProfile(ctx context.Context, request *CreateVerifyProfileReq) (CreateVerifyProfileRes, error)
	// DeleteCallControlApplication invokes DeleteCallControlApplication operation.
	//
	// Deletes a call control application.
	//
	// DELETE /call_control_applications/{id}
	DeleteCallControlApplication(ctx context.Context, params DeleteCallControlApplicationParams) (DeleteCallControlApplicationRes, error)
	// DeleteCustomStorageCredentials invokes DeleteCustomStorageCredentials operation.
	//
	// Deletes a stored custom credentials configuration.
	//
	// DELETE /custom_storage_credentials/{connection_id}
	DeleteCustomStorageCredentials(ctx context.Context, params DeleteCustomStorageCredentialsParams) (DeleteCustomStorageCredentialsRes, error)
	// DeleteProfile invokes DeleteProfile operation.
	//
	// Delete Verify profile.
	//
	// DELETE /verify_profiles/{verify_profile_id}
	DeleteProfile(ctx context.Context, params DeleteProfileParams) (DeleteProfileRes, error)
	// DeleteRecording invokes DeleteRecording operation.
	//
	// Permanently deletes a call recording.
	//
	// DELETE /recordings/{recording_id}
	DeleteRecording(ctx context.Context, params DeleteRecordingParams) (DeleteRecordingRes, error)
	// DeleteRecordingTranscription invokes deleteRecordingTranscription operation.
	//
	// Permanently deletes a recording transcription.
	//
	// DELETE /recording_transcriptions/{recording_transcription_id}
	DeleteRecordingTranscription(ctx context.Context, params DeleteRecordingTranscriptionParams) (DeleteRecordingTranscriptionRes, error)
	// DeleteRecordings invokes DeleteRecordings operation.
	//
	// Permanently deletes a list of call recordings.
	//
	// DELETE /recordings/actions/delete
	DeleteRecordings(ctx context.Context, request []string) (DeleteRecordingsRes, error)
	// DeleteRoomRecording invokes DeleteRoomRecording operation.
	//
	// Synchronously delete a Room Recording.
	//
	// DELETE /room_recordings/{room_recording_id}
	DeleteRoomRecording(ctx context.Context, params DeleteRoomRecordingParams) (DeleteRoomRecordingRes, error)
	// DeleteRoomRecordings invokes DeleteRoomRecordings operation.
	//
	// Delete several room recordings in a bulk.
	//
	// DELETE /room_recordings
	DeleteRoomRecordings(ctx context.Context, params DeleteRoomRecordingsParams) (DeleteRoomRecordingsRes, error)
	// DeleteTeXMLCallRecording invokes DeleteTeXMLCallRecording operation.
	//
	// Deletes recording resource identified by recording id.
	//
	// DELETE /texml/Accounts/{account_sid}/Recordings/{recording_sid}.json
	DeleteTeXMLCallRecording(ctx context.Context, params DeleteTeXMLCallRecordingParams) (DeleteTeXMLCallRecordingRes, error)
	// DeleteTeXMLRecordingTranscription invokes DeleteTeXMLRecordingTranscription operation.
	//
	// Permanently deletes a recording transcription.
	//
	// DELETE /texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json
	DeleteTeXMLRecordingTranscription(ctx context.Context, params DeleteTeXMLRecordingTranscriptionParams) (DeleteTeXMLRecordingTranscriptionRes, error)
	// DeleteTelephonyCredential invokes DeleteTelephonyCredential operation.
	//
	// Delete an existing credential.
	//
	// DELETE /telephony_credentials/{id}
	DeleteTelephonyCredential(ctx context.Context, params DeleteTelephonyCredentialParams) (DeleteTelephonyCredentialRes, error)
	// DeleteTelephonyCredentials invokes DeleteTelephonyCredentials operation.
	//
	// Delete several credentials in bulk.
	//
	// DELETE /actions/bulk/telephony_credentials
	DeleteTelephonyCredentials(ctx context.Context, params DeleteTelephonyCredentialsParams) (DeleteTelephonyCredentialsRes, error)
	// DeleteTexmlApplication invokes DeleteTexmlApplication operation.
	//
	// Deletes a TeXML Application.
	//
	// DELETE /texml_applications/{id}
	DeleteTexmlApplication(ctx context.Context, params DeleteTexmlApplicationParams) (DeleteTexmlApplicationRes, error)
	// DeleteTexmlConferenceParticipant invokes DeleteTexmlConferenceParticipant operation.
	//
	// Deletes a conference participant.
	//
	// DELETE /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
	DeleteTexmlConferenceParticipant(ctx context.Context, params DeleteTexmlConferenceParticipantParams) (DeleteTexmlConferenceParticipantRes, error)
	// DeleteVerifiedCallDisplayProfile invokes DeleteVerifiedCallDisplayProfile operation.
	//
	// Deletes the Verified Calls Display Profile. This action will fail if any verification requests
	// have been made for this Verified Calls Display Profile. Please contact support@telnyx.com in case
	// you want to delete a Verified Calls Display Profile in that situation.
	//
	// DELETE /verified_calls_display_profiles/{id}
	DeleteVerifiedCallDisplayProfile(ctx context.Context, params DeleteVerifiedCallDisplayProfileParams) (DeleteVerifiedCallDisplayProfileRes, error)
	// DeleteVerifiedNumber invokes DeleteVerifiedNumber operation.
	//
	// Delete a verified number.
	//
	// DELETE /verified_numbers/{phone_number}
	DeleteVerifiedNumber(ctx context.Context, params DeleteVerifiedNumberParams) (DeleteVerifiedNumberRes, error)
	// DialCall invokes DialCall operation.
	//
	// Dial a number or SIP URI from a given connection. A successful response will include a
	// `call_leg_id` which can be used to correlate the command with subsequent webhooks.
	// **Expected Webhooks:**
	// - `call.initiated`
	// - `call.answered` or `call.hangup`
	// - `call.machine.detection.ended` if `answering_machine_detection` was requested
	// - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end
	// of machine greeting
	// - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
	// - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and
	// a beep was detected
	// - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set.
	//
	// POST /calls
	DialCall(ctx context.Context, request *CallRequest) (DialCallRes, error)
	// DialTexmlConferenceParticipant invokes DialTexmlConferenceParticipant operation.
	//
	// Dials a new conference participant.
	//
	// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants
	DialTexmlConferenceParticipant(ctx context.Context, request *DialConferenceParticipantRequest, params DialTexmlConferenceParticipantParams) (DialTexmlConferenceParticipantRes, error)
	// DisplayProfile invokes DisplayProfile operation.
	//
	// Display the Verified Calls Display Profile.
	//
	// GET /verified_calls_display_profiles/{id}
	DisplayProfile(ctx context.Context, params DisplayProfileParams) (DisplayProfileRes, error)
	// EnqueueCall invokes EnqueueCall operation.
	//
	// Put the call in a queue.
	//
	// POST /calls/{call_control_id}/actions/enqueue
	EnqueueCall(ctx context.Context, request *EnqueueRequest, params EnqueueCallParams) (EnqueueCallRes, error)
	// FetchTeXMLCallRecordings invokes FetchTeXMLCallRecordings operation.
	//
	// Returns recordings for a call identified by call_sid.
	//
	// GET /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json
	FetchTeXMLCallRecordings(ctx context.Context, params FetchTeXMLCallRecordingsParams) (FetchTeXMLCallRecordingsRes, error)
	// FetchTeXMLConferenceRecordings invokes FetchTeXMLConferenceRecordings operation.
	//
	// Returns recordings for a conference identified by conference_sid.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings.json
	FetchTeXMLConferenceRecordings(ctx context.Context, params FetchTeXMLConferenceRecordingsParams) (FetchTeXMLConferenceRecordingsRes, error)
	// FindTelephonyCredentials invokes FindTelephonyCredentials operation.
	//
	// List all On-demand Credentials.
	//
	// GET /telephony_credentials
	FindTelephonyCredentials(ctx context.Context, params FindTelephonyCredentialsParams) (FindTelephonyCredentialsRes, error)
	// FindTexmlApplications invokes FindTexmlApplications operation.
	//
	// Returns a list of your TeXML Applications.
	//
	// GET /texml_applications
	FindTexmlApplications(ctx context.Context, params FindTexmlApplicationsParams) (FindTexmlApplicationsRes, error)
	// GatherCall invokes GatherCall operation.
	//
	// Gather DTMF signals to build interactive menus.
	// You can pass a list of valid digits. The `Answer` command must be issued before the `gather`
	// command.
	// **Expected Webhooks:**
	// - `call.dtmf.received` (you may receive many of these webhooks)
	// - `call.gather.ended`.
	//
	// POST /calls/{call_control_id}/actions/gather
	GatherCall(ctx context.Context, request *GatherRequest, params GatherCallParams) (GatherCallRes, error)
	// GatherUsingAudio invokes GatherUsingAudio operation.
	//
	// Play an audio file on the call until the required DTMF signals are gathered to build interactive
	// menus.
	// You can pass a list of valid digits along with an 'invalid_audio_url', which will be played back
	// at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The
	// `Answer command must be issued before the `gather_using_audio` command.
	// **Expected Webhooks:**
	// - `call.playback.started`
	// - `call.playback.ended`
	// - `call.dtmf.received` (you may receive many of these webhooks)
	// - `call.gather.ended`.
	//
	// POST /calls/{call_control_id}/actions/gather_using_audio
	GatherUsingAudio(ctx context.Context, request *GatherUsingAudioRequest, params GatherUsingAudioParams) (GatherUsingAudioRes, error)
	// GatherUsingSpeak invokes GatherUsingSpeak operation.
	//
	// Convert text to speech and play it on the call until the required DTMF signals are gathered to
	// build interactive menus.
	// You can pass a list of valid digits along with an 'invalid_payload', which will be played back at
	// the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The
	// `Answer` command must be issued before the `gather_using_speak` command.
	// **Expected Webhooks:**
	// - `call.dtmf.received` (you may receive many of these webhooks)
	// - `call.gather.ended`.
	//
	// POST /calls/{call_control_id}/actions/gather_using_speak
	GatherUsingSpeak(ctx context.Context, request *GatherUsingSpeakRequest, params GatherUsingSpeakParams) (GatherUsingSpeakRes, error)
	// GetCustomStorageCredentials invokes GetCustomStorageCredentials operation.
	//
	// Returns the information about custom storage credentials.
	//
	// GET /custom_storage_credentials/{connection_id}
	GetCustomStorageCredentials(ctx context.Context, params GetCustomStorageCredentialsParams) (GetCustomStorageCredentialsRes, error)
	// GetRecording invokes GetRecording operation.
	//
	// Retrieves the details of an existing call recording.
	//
	// GET /recordings/{recording_id}
	GetRecording(ctx context.Context, params GetRecordingParams) (GetRecordingRes, error)
	// GetRecordingTranscription invokes getRecordingTranscription operation.
	//
	// Retrieves the details of an existing recording transcription.
	//
	// GET /recording_transcriptions/{recording_transcription_id}
	GetRecordingTranscription(ctx context.Context, params GetRecordingTranscriptionParams) (GetRecordingTranscriptionRes, error)
	// GetRecordingTranscriptions invokes getRecordingTranscriptions operation.
	//
	// Returns a list of your recording transcriptions.
	//
	// GET /recording_transcriptions
	GetRecordingTranscriptions(ctx context.Context) (GetRecordingTranscriptionsRes, error)
	// GetRecordings invokes GetRecordings operation.
	//
	// Returns a list of your call recordings.
	//
	// GET /recordings
	GetRecordings(ctx context.Context, params GetRecordingsParams) (GetRecordingsRes, error)
	// GetTeXMLCallRecording invokes GetTeXMLCallRecording operation.
	//
	// Returns recording resource identified by recording id.
	//
	// GET /texml/Accounts/{account_sid}/Recordings/{recording_sid}.json
	GetTeXMLCallRecording(ctx context.Context, params GetTeXMLCallRecordingParams) (GetTeXMLCallRecordingRes, error)
	// GetTeXMLCallRecordings invokes GetTeXMLCallRecordings operation.
	//
	// Returns multiple recording resources for an account.
	//
	// GET /texml/Accounts/{account_sid}/Recordings.json
	GetTeXMLCallRecordings(ctx context.Context, params GetTeXMLCallRecordingsParams) (GetTeXMLCallRecordingsRes, error)
	// GetTeXMLRecordingTranscription invokes GetTeXMLRecordingTranscription operation.
	//
	// Returns the recording transcription resource identified by its ID.
	//
	// GET /texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json
	GetTeXMLRecordingTranscription(ctx context.Context, params GetTeXMLRecordingTranscriptionParams) (GetTeXMLRecordingTranscriptionRes, error)
	// GetTeXMLRecordingTranscriptions invokes GetTeXMLRecordingTranscriptions operation.
	//
	// Returns multiple recording transcription resources for an account.
	//
	// GET /texml/Accounts/{account_sid}/Transcriptions.json
	GetTeXMLRecordingTranscriptions(ctx context.Context, params GetTeXMLRecordingTranscriptionsParams) (GetTeXMLRecordingTranscriptionsRes, error)
	// GetTelephonyCredential invokes GetTelephonyCredential operation.
	//
	// Get the details of an existing On-demand Credential.
	//
	// GET /telephony_credentials/{id}
	GetTelephonyCredential(ctx context.Context, params GetTelephonyCredentialParams) (GetTelephonyCredentialRes, error)
	// GetTexmlApplication invokes GetTexmlApplication operation.
	//
	// Retrieves the details of an existing TeXML Application.
	//
	// GET /texml_applications/{id}
	GetTexmlApplication(ctx context.Context, params GetTexmlApplicationParams) (GetTexmlApplicationRes, error)
	// GetTexmlCall invokes GetTexmlCall operation.
	//
	// Returns an individual call identified by its CallSid. This endpoint is eventually consistent.
	//
	// GET /texml/Accounts/{account_sid}/Calls/{call_sid}
	GetTexmlCall(ctx context.Context, params GetTexmlCallParams) (GetTexmlCallRes, error)
	// GetTexmlCalls invokes GetTexmlCalls operation.
	//
	// Returns multiple call resouces for an account. This endpoint is eventually consistent.
	//
	// GET /texml/Accounts/{account_sid}/Calls
	GetTexmlCalls(ctx context.Context, params GetTexmlCallsParams) (GetTexmlCallsRes, error)
	// GetTexmlConference invokes GetTexmlConference operation.
	//
	// Returns a conference resource.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}
	GetTexmlConference(ctx context.Context, params GetTexmlConferenceParams) (GetTexmlConferenceRes, error)
	// GetTexmlConferenceParticipant invokes GetTexmlConferenceParticipant operation.
	//
	// Gets conference participant resource.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
	GetTexmlConferenceParticipant(ctx context.Context, params GetTexmlConferenceParticipantParams) (GetTexmlConferenceParticipantRes, error)
	// GetTexmlConferenceParticipants invokes GetTexmlConferenceParticipants operation.
	//
	// Lists conference participants.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants
	GetTexmlConferenceParticipants(ctx context.Context, params GetTexmlConferenceParticipantsParams) (GetTexmlConferenceParticipantsRes, error)
	// GetTexmlConferenceRecordings invokes GetTexmlConferenceRecordings operation.
	//
	// Lists conference recordings.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings
	GetTexmlConferenceRecordings(ctx context.Context, params GetTexmlConferenceRecordingsParams) (GetTexmlConferenceRecordingsRes, error)
	// GetTexmlConferences invokes GetTexmlConferences operation.
	//
	// Lists conference resources.
	//
	// GET /texml/Accounts/{account_sid}/Conferences
	GetTexmlConferences(ctx context.Context, params GetTexmlConferencesParams) (GetTexmlConferencesRes, error)
	// GetUsageReportByApplication invokes GetUsageReportByApplication operation.
	//
	// Get Telnyx usage data by product, broken out by the specified dimensions.
	//
	// GET /usage_reports
	GetUsageReportByApplication(ctx context.Context, params GetUsageReportByApplicationParams) (GetUsageReportByApplicationRes, error)
	// GetUsageReportSync invokes GetUsageReportSync operation.
	//
	// Generate and fetch messaging usage report synchronously. This endpoint will both generate and
	// fetch the messaging report over a specified time period. No polling is necessary but the response
	// may take up to a couple of minutes.
	//
	// GET /reports/mdr_usage_reports/sync
	GetUsageReportSync(ctx context.Context, params GetUsageReportSyncParams) (*MdrGetSyncUsageReportResponse, error)
	// GetUsageReports invokes GetUsageReports operation.
	//
	// Fetch all messaging usage reports. Usage reports are aggregated messaging data for specified time
	// period and breakdown.
	//
	// GET /reports/mdr_usage_reports
	GetUsageReports(ctx context.Context, params GetUsageReportsParams) (*MdrGetUsageReportsResponse, error)
	// GetUserBalance invokes GetUserBalance operation.
	//
	// Get user balance details.
	//
	// GET /balance
	GetUserBalance(ctx context.Context) (GetUserBalanceRes, error)
	// GetVerifiedNumber invokes GetVerifiedNumber operation.
	//
	// Retrieve a verified number.
	//
	// GET /verified_numbers/{phone_number}
	GetVerifiedNumber(ctx context.Context, params GetVerifiedNumberParams) (GetVerifiedNumberRes, error)
	// GetVerifyProfile invokes GetVerifyProfile operation.
	//
	// Gets a single Verify profile.
	//
	// GET /verify_profiles/{verify_profile_id}
	GetVerifyProfile(ctx context.Context, params GetVerifyProfileParams) (GetVerifyProfileRes, error)
	// GetWebhookDelivery invokes GetWebhookDelivery operation.
	//
	// Provides webhook_delivery debug data, such as timestamps, delivery status and attempts.
	//
	// GET /webhook_deliveries/{id}
	GetWebhookDelivery(ctx context.Context, params GetWebhookDeliveryParams) (GetWebhookDeliveryRes, error)
	// HangupCall invokes HangupCall operation.
	//
	// Hang up the call.
	// **Expected Webhooks:**
	// - `call.hangup`
	// - `call.recording.saved`.
	//
	// POST /calls/{call_control_id}/actions/hangup
	HangupCall(ctx context.Context, request *HangupRequest, params HangupCallParams) (HangupCallRes, error)
	// InitiateTexmlCallByAccount invokes InitiateTexmlCallByAccount operation.
	//
	// Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for
	// the connection in the Mission Control Portal.
	//
	// POST /texml/Accounts/{account_sid}/Calls
	InitiateTexmlCallByAccount(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByAccountParams) (*InitiateCallResponse, error)
	// InitiateTexmlCallByApplication invokes InitiateTexmlCallByApplication operation.
	//
	// Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for
	// the connection in the Mission Control Portal.
	//
	// POST /texml/calls/{application_id}
	InitiateTexmlCallByApplication(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByApplicationParams) (*InitiateCallResponse, error)
	// LeaveQueue invokes LeaveQueue operation.
	//
	// Removes the call from a queue.
	//
	// POST /calls/{call_control_id}/actions/leave_queue
	LeaveQueue(ctx context.Context, request *LeaveQueueRequest, params LeaveQueueParams) (LeaveQueueRes, error)
	// ListCallControlApplications invokes ListCallControlApplications operation.
	//
	// Return a list of call control applications.
	//
	// GET /call_control_applications
	ListCallControlApplications(ctx context.Context, params ListCallControlApplicationsParams) (ListCallControlApplicationsRes, error)
	// ListConnectionActiveCalls invokes ListConnectionActiveCalls operation.
	//
	// Lists all active calls for given connection. Acceptable connections are either SIP connections
	// with webhook_url or xml_request_url, call control or texml. Returned results are cursor paginated.
	//
	// GET /connections/{connection_id}/active_calls
	ListConnectionActiveCalls(ctx context.Context, params ListConnectionActiveCallsParams) (ListConnectionActiveCallsRes, error)
	// ListProfileMessageTemplates invokes ListProfileMessageTemplates operation.
	//
	// List all Verify profile message templates.
	//
	// GET /verify_profiles/templates
	ListProfileMessageTemplates(ctx context.Context) (*ListVerifyProfileMessageTemplateResponse, error)
	// ListProfiles invokes ListProfiles operation.
	//
	// Gets a paginated list of Verify profiles.
	//
	// GET /verify_profiles
	ListProfiles(ctx context.Context, params ListProfilesParams) (ListProfilesRes, error)
	// ListQueueCalls invokes ListQueueCalls operation.
	//
	// Retrieve the list of calls in an existing queue.
	//
	// GET /queues/{queue_name}/calls
	ListQueueCalls(ctx context.Context, params ListQueueCallsParams) (ListQueueCallsRes, error)
	// ListRoomRecordings invokes ListRoomRecordings operation.
	//
	// View a list of room recordings.
	//
	// GET /room_recordings
	ListRoomRecordings(ctx context.Context, params ListRoomRecordingsParams) (*ListRoomRecordingsResponse, error)
	// ListTags invokes ListTags operation.
	//
	// Returns a list of tags used on Credentials.
	//
	// GET /telephony_credentials/tags
	ListTags(ctx context.Context, params ListTagsParams) (ListTagsRes, error)
	// ListUsageReportsOptions invokes ListUsageReportsOptions operation.
	//
	// Get the Usage Reports options for querying usage, including the products available and their
	// respective metrics and dimensions.
	//
	// GET /usage_reports/options
	ListUsageReportsOptions(ctx context.Context, params ListUsageReportsOptionsParams) (ListUsageReportsOptionsRes, error)
	// ListVerifications invokes ListVerifications operation.
	//
	// List verifications by phone number.
	//
	// GET /verifications/by_phone_number/{phone_number}
	ListVerifications(ctx context.Context, params ListVerificationsParams) (ListVerificationsRes, error)
	// ListVerifiedCallDisplayProfiles invokes ListVerifiedCallDisplayProfiles operation.
	//
	// Lists the Verified Calls Display Profiles owned by the current user/organization.
	//
	// GET /verified_calls_display_profiles
	ListVerifiedCallDisplayProfiles(ctx context.Context, params ListVerifiedCallDisplayProfilesParams) (ListVerifiedCallDisplayProfilesRes, error)
	// ListVerifiedNumbers invokes ListVerifiedNumbers operation.
	//
	// Gets a paginated list of Verified Numbers.
	//
	// GET /verified_numbers
	ListVerifiedNumbers(ctx context.Context, params ListVerifiedNumbersParams) (ListVerifiedNumbersRes, error)
	// NoiseSuppressionStart invokes noiseSuppressionStart operation.
	//
	// Noise Suppression Start (BETA).
	//
	// POST /calls/{call_control_id}/actions/suppression_start
	NoiseSuppressionStart(ctx context.Context, request *NoiseSuppressionStart, params NoiseSuppressionStartParams) (NoiseSuppressionStartRes, error)
	// NoiseSuppressionStop invokes noiseSuppressionStop operation.
	//
	// Noise Suppression Stop (BETA).
	//
	// POST /calls/{call_control_id}/actions/suppression_stop
	NoiseSuppressionStop(ctx context.Context, request *NoiseSuppressionStop, params NoiseSuppressionStopParams) (NoiseSuppressionStopRes, error)
	// PauseCallRecording invokes PauseCallRecording operation.
	//
	// Pause recording the call. Recording can be resumed via Resume recording command.
	// **Expected Webhooks:**
	// There are no webhooks associated with this command.
	//
	// POST /calls/{call_control_id}/actions/record_pause
	PauseCallRecording(ctx context.Context, request *PauseRecordingRequest, params PauseCallRecordingParams) (PauseCallRecordingRes, error)
	// PerformCredentialAction invokes PerformCredentialAction operation.
	//
	// Perform activate or deactivate action on provided Credential. Activate action will change the
	// status to active, making it possible to connect calls with the credential. Deactivate action will
	// change the status to inactive, making it impossible to connect calls with the credential.
	//
	// POST /telephony_credentials/{id}/actions/{action}
	PerformCredentialAction(ctx context.Context, params PerformCredentialActionParams) (PerformCredentialActionRes, error)
	// ReferCall invokes ReferCall operation.
	//
	// Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any point in the
	// duration of a call.
	// **Expected Webhooks:**
	// - `call.refer.started`
	// - `call.refer.completed`
	// - `call.refer.failed`.
	//
	// POST /calls/{call_control_id}/actions/refer
	ReferCall(ctx context.Context, request *ReferRequest, params ReferCallParams) (ReferCallRes, error)
	// RegisterCall invokes RegisterCall operation.
	//
	// Register the call before dialing to show your brand on callee's phone.
	//
	// POST /calls/register
	RegisterCall(ctx context.Context, request *RegisterCallRequest) (RegisterCallRes, error)
	// RejectCall invokes RejectCall operation.
	//
	// Reject an incoming call.
	// **Expected Webhooks:**
	// - `call.hangup`.
	//
	// POST /calls/{call_control_id}/actions/reject
	RejectCall(ctx context.Context, request *RejectRequest, params RejectCallParams) (RejectCallRes, error)
	// ReportsCdrUsageReportsSyncGet invokes GET /reports/cdr_usage_reports/sync operation.
	//
	// Generate and fetch voice usage report synchronously. This endpoint will both generate and fetch
	// the voice report over a specified time period. No polling is necessary but the response may take
	// up to a couple of minutes.
	//
	// GET /reports/cdr_usage_reports/sync
	ReportsCdrUsageReportsSyncGet(ctx context.Context, params ReportsCdrUsageReportsSyncGetParams) (*CdrGetSyncUsageReportResponse, error)
	// ResumeCallRecording invokes ResumeCallRecording operation.
	//
	// Resume recording the call.
	// **Expected Webhooks:**
	// There are no webhooks associated with this command.
	//
	// POST /calls/{call_control_id}/actions/record_resume
	ResumeCallRecording(ctx context.Context, request *ResumeRecordingRequest, params ResumeCallRecordingParams) (ResumeCallRecordingRes, error)
	// RetrieveCallControlApplication invokes RetrieveCallControlApplication operation.
	//
	// Retrieves the details of an existing call control application.
	//
	// GET /call_control_applications/{id}
	RetrieveCallControlApplication(ctx context.Context, params RetrieveCallControlApplicationParams) (RetrieveCallControlApplicationRes, error)
	// RetrieveCallFromQueue invokes RetrieveCallFromQueue operation.
	//
	// Retrieve an existing call from an existing queue.
	//
	// GET /queues/{queue_name}/calls/{call_control_id}
	RetrieveCallFromQueue(ctx context.Context, params RetrieveCallFromQueueParams) (RetrieveCallFromQueueRes, error)
	// RetrieveCallStatus invokes RetrieveCallStatus operation.
	//
	// Returns the status of a call (data is available 10 minutes after call ended).
	//
	// GET /calls/{call_control_id}
	RetrieveCallStatus(ctx context.Context, params RetrieveCallStatusParams) (RetrieveCallStatusRes, error)
	// RetrieveVerification invokes RetrieveVerification operation.
	//
	// Retrieve verification.
	//
	// GET /verifications/{verification_id}
	RetrieveVerification(ctx context.Context, params RetrieveVerificationParams) (RetrieveVerificationRes, error)
	// SendDTMF invokes SendDTMF operation.
	//
	// Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.
	// **Expected Webhooks:**
	// There are no webhooks associated with this command.
	//
	// POST /calls/{call_control_id}/actions/send_dtmf
	SendDTMF(ctx context.Context, request *SendDTMFRequest, params SendDTMFParams) (SendDTMFRes, error)
	// SpeakCall invokes SpeakCall operation.
	//
	// Convert text to speech and play it back on the call. If multiple speak text commands are issued
	// consecutively, the audio files will be placed in a queue awaiting playback.
	// **Expected Webhooks:**
	// - `call.speak.started`
	// - `call.speak.ended`.
	//
	// POST /calls/{call_control_id}/actions/speak
	SpeakCall(ctx context.Context, request *SpeakRequest, params SpeakCallParams) (SpeakCallRes, error)
	// StartCallFork invokes StartCallFork operation.
	//
	// Call forking allows you to stream the media from a call to a specific target in realtime.
	// This stream can be used to enable realtime audio analysis to support a
	// variety of use cases, including fraud detection, or the creation of AI-generated audio responses.
	// Requests must specify either the `target` attribute or the `rx` and `tx` attributes.
	// **Expected Webhooks:**
	// - `call.fork.started`
	// - `call.fork.stopped`
	// **Simple Telnyx RTP Encapsulation Protocol (STREP)**
	// *Note: This header/encapsulation is not used when the `rx` and `tx`
	// parameters have been specified; it only applies when media is forked
	// using the `target` attribute.*
	// If the destination for forked media is specified using the "target"
	// attribute, the RTP will be encapsulated in an extra Telnyx protocol,
	// which adds a 24 byte header to the RTP payload in each packet. The STREP
	// header includes the Call Control `call_leg_id` for stream
	// identification, along with bits that represent the direction (inbound or
	// outbound) of the media. This 24-byte header sits between the UDP header
	// and the RTP header.
	// The STREP header makes it possible to fork RTP for multiple calls (or
	// two RTP streams for the same call) to the same IP:port, where the
	// streams can be demultiplexed by your application using the information
	// in the header. Of course, it's still possible to ignore this header
	// completely, for example, if sending forked media for different calls to
	// different ports or IP addresses. In this case, simply strip 24 bytes
	// (or use the second byte to find the header length) from the received UDP
	// payload to get the RTP (RTP header and payload).
	// ```
	// STREP Specification
	// 0                   1                   2                   3
	// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |
	// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// |       reserved (4 bytes, for UDP ports or anything else)      |
	// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// |               The call_leg_id                                 |
	// |                   from Call Control                           |
	// |                       (128 bits / 16 bytes)                   |
	// |                           (this is binary data)               |
	// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// 11
	// Static bits 11, always set to 11 to easily distinguish forked media
	// from RTP (10) and T.38 media (usually 00) and SIP (which begins
	// with a capital letter, so begins with bits 01). This is a magic number.
	// Version
	// Four bits to indicate the version number of the protocol, starting at 0001.
	// L
	// One bit to represent the leg of the call (A or B).
	// 0 represents the A (first) leg of the call.
	// 1 represents the B (second) leg of the call.
	// D
	// One bit to represent the direction of this RTP stream.
	// 0 represents media received by Telnyx.
	// 1 represents media transmitted by Telnyx.
	// HeaderLen (1 byte)
	// The length of the header in bytes.
	// Note that this value does not include the length of the payload. The total
	// size of the RTP can be calculated by subtracting the HeaderLen from the UDP
	// length (minus 8 for the UDP header).
	// In version 1, this value will always be 24.
	// Reserved (6 bytes)
	// Reserved for future use and to make sure that the header is a multiple of 32 bits
	// Call Leg ID
	// A 128-bit identifier for the call leg.
	// This is the call_leg_id from Call Control.
	// ```.
	//
	// POST /calls/{call_control_id}/actions/fork_start
	StartCallFork(ctx context.Context, request *StartForkingRequest, params StartCallForkParams) (StartCallForkRes, error)
	// StartCallPlayback invokes StartCallPlayback operation.
	//
	// Play an audio file on the call. If multiple play audio commands are issued consecutively,
	// the audio files will be placed in a queue awaiting playback.
	// *Notes:*
	// - When `overlay` is enabled, `target_legs` is limited to `self`.
	// - A customer cannot Play Audio with `overlay=true` unless there is a Play Audio with
	// `overlay=false` actively playing.
	// **Expected Webhooks:**
	// - `call.playback.started`
	// - `call.playback.ended`.
	//
	// POST /calls/{call_control_id}/actions/playback_start
	StartCallPlayback(ctx context.Context, request *PlayAudioUrlRequest, params StartCallPlaybackParams) (StartCallPlaybackRes, error)
	// StartCallRecord invokes StartCallRecord operation.
	//
	// Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop
	// Recording command.
	// **Expected Webhooks:**
	// - `call.recording.saved`.
	//
	// POST /calls/{call_control_id}/actions/record_start
	StartCallRecord(ctx context.Context, request *StartRecordingRequest, params StartCallRecordParams) (StartCallRecordRes, error)
	// StartCallStreaming invokes StartCallStreaming operation.
	//
	// Start streaming the media from a call to a specific WebSocket address or Dialogflow connection in
	// near-realtime. Audio will be delivered as base64-encoded RTP payload (raw audio), wrapped in JSON
	// payloads.
	// **Example: Starting a stream to a Websocket address**
	// The `stream_url` param is mandatory.
	// ```
	// curl -X POST \
	// --header "Content-Type: application/json" \
	// --header "Accept: application/json" \
	// --header "Authorization: Bearer YOUR_API_KEY" \
	// --data '{
	// "stream_url": "wss://www.example.com/websocket",\
	// "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d",\
	// "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901" \
	// }' \
	// https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
	// ```
	// **Example: Starting a stream to a Dialogflow connection**
	// Enable the Dialogflow integration by sending `"enable_dialogflow": true` in the request. You need
	// to have a Dialogflow connection associated with your Call Control application first, [click here
	// for instructions](https://developers.telnyx.com/docs/voice/programmable-voice/dialogflow-es).
	// ```
	// curl -X POST \
	// --header "Content-Type: application/json" \
	// --header "Accept: application/json" \
	// --header "Authorization: Bearer YOUR_API_KEY" \
	// --data '{
	// "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d", \
	// "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901", \
	// "enable_dialogflow": true \
	// }' \
	// https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
	// ```
	// **Expected Webhooks:**
	// - `streaming.started`
	// - `streaming.stopped`
	// - `streaming.failed`
	// **WebSocket events**
	// When the WebSocket connection is established, the following event is being sent over it:
	// ```
	// {
	// "event": "connected",
	// "version": "1.0.0"
	// }
	// ```
	// And when the call is started, an event which contains information about the encoding and
	// `stream_id` that identifies a particular stream:
	// ```
	// {
	// "event": "start",
	// "sequence_number": "1",
	// "start": {
	// "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
	// "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
	// "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
	// "media_format": {
	// "encoding": "audio/x-mulaw",
	// "sample_rate": 8000,
	// "channels": 1
	// }
	// },
	// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
	// }
	// ```
	// The start event is followed by the following media events that contain base64-encoded RTP payload
	// (raw audio, no RTP headers) (:
	// ```
	// {
	// "event": "media",
	// "sequence_number": "4",
	// "media": {
	// "track": "inbound/outbound",
	// "chunk": "2",
	// "timestamp": "5",
	// "payload": "no+JhoaJjpzSHxAKBgYJD...IsSbjomGhoqQn1Ic"
	// },
	// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
	// }
	// ```
	// Please note that the order of events is not guaranteed and the chunk number can be used to reorder
	// the events.
	// When the call ends, the stop event over WebSockets connection is sent:
	// ```
	// {
	// "event": "stop",
	// "sequence_number": "5",
	// "stop": {
	// "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
	// "call_control_id": "v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQ"
	// },
	// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
	// }
	// ```
	// **Bidirectional Media Streaming**
	// Media can be sent back to the call through the websocket as well. This is done in a way very
	// similar to the [playback_start](https://developers.telnyx.
	// com/docs/api/v2/call-control/Call-Commands#callPlaybackStart)
	// command, when using a base64 encoded mp3 file in the payload. Simply send a packet to the
	// websocket connection as follows:
	// ```
	// {
	// "event": "media",
	// "media": {
	// "payload" : <your base64 encoded mp3 file>
	// }
	// }
	// ```
	// The payload, which is a base64-encoded mp3 file, will be played on the call.
	// Some limitations to be aware of:
	// - Media payloads can only be submitted once per second.
	// - Media _must_ be base64 encoded mp3
	// **Stream Errors**
	// Any errors in the media packet, including when a rate limit is reached, will result in an error
	// frame being
	// sent to your websocket server. The error frame will appear as follows:
	// ```
	// {
	// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc",
	// "event": "error",
	// "sequence_number": "6",
	// "error": {
	// "title": "rate_limit_reached",
	// "code": "100005",
	// "detail": "Too many requests"
	// }
	// }
	// ```
	// Possible errors are as follows:
	// - Error 100002: `"unknown_error"`
	// - Error 100003: `"malformed_frame"`
	// - Error 100004: `"invalid_media"`
	// - Error 100005: `"rate_limit_reached"`.
	//
	// POST /calls/{call_control_id}/actions/streaming_start
	StartCallStreaming(ctx context.Context, request *StartStreamingRequest, params StartCallStreamingParams) (StartCallStreamingRes, error)
	// StartCallTranscription invokes StartCallTranscription operation.
	//
	// Start real-time transcription. Transcription will stop on call hang-up, or can be initiated via
	// the Transcription stop command.
	// **Expected Webhooks:**
	// - `call.transcription`.
	//
	// POST /calls/{call_control_id}/actions/transcription_start
	StartCallTranscription(ctx context.Context, request *TranscriptionStartRequest, params StartCallTranscriptionParams) (StartCallTranscriptionRes, error)
	// StartTeXMLCallRecording invokes StartTeXMLCallRecording operation.
	//
	// Starts recording with specified parameters for call idientified by call_sid.
	//
	// POST /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json
	StartTeXMLCallRecording(ctx context.Context, request OptTexmlCreateCallRecordingRequestBody, params StartTeXMLCallRecordingParams) (StartTeXMLCallRecordingRes, error)
	// StopCallFork invokes StopCallFork operation.
	//
	// Stop forking a call.
	// **Expected Webhooks:**
	// - `call.fork.stopped`.
	//
	// POST /calls/{call_control_id}/actions/fork_stop
	StopCallFork(ctx context.Context, request *StopForkingRequest, params StopCallForkParams) (StopCallForkRes, error)
	// StopCallGather invokes StopCallGather operation.
	//
	// Stop current gather.
	// **Expected Webhooks:**
	// - `call.gather.ended`.
	//
	// POST /calls/{call_control_id}/actions/gather_stop
	StopCallGather(ctx context.Context, request *StopGatherRequest, params StopCallGatherParams) (StopCallGatherRes, error)
	// StopCallPlayback invokes StopCallPlayback operation.
	//
	// Stop audio being played on the call.
	// **Expected Webhooks:**
	// - `call.playback.ended` or `call.speak.ended`.
	//
	// POST /calls/{call_control_id}/actions/playback_stop
	StopCallPlayback(ctx context.Context, request *PlaybackStopRequest, params StopCallPlaybackParams) (StopCallPlaybackRes, error)
	// StopCallRecording invokes StopCallRecording operation.
	//
	// Stop recording the call.
	// **Expected Webhooks:**
	// - `call.recording.saved`.
	//
	// POST /calls/{call_control_id}/actions/record_stop
	StopCallRecording(ctx context.Context, request *StopRecordingRequest, params StopCallRecordingParams) (StopCallRecordingRes, error)
	// StopCallStreaming invokes StopCallStreaming operation.
	//
	// Stop streaming a call to a WebSocket.
	// **Expected Webhooks:**
	// - `streaming.stopped`.
	//
	// POST /calls/{call_control_id}/actions/streaming_stop
	StopCallStreaming(ctx context.Context, request *StopStreamingRequest, params StopCallStreamingParams) (StopCallStreamingRes, error)
	// StopCallTranscription invokes StopCallTranscription operation.
	//
	// Stop real-time transcription.
	//
	// POST /calls/{call_control_id}/actions/transcription_stop
	StopCallTranscription(ctx context.Context, request *TranscriptionStopRequest, params StopCallTranscriptionParams) (StopCallTranscriptionRes, error)
	// TransferCall invokes TransferCall operation.
	//
	// Transfer a call to a new destination. If the transfer is unsuccessful, a `call.hangup` webhook for
	// the other call (Leg B) will be sent indicating that the transfer could not be completed. The
	// original call will remain active and may be issued additional commands, potentially transfering
	// the call to an alternate destination.
	// **Expected Webhooks:**
	// - `call.initiated`
	// - `call.bridged` to Leg B
	// - `call.answered` or `call.hangup`
	// - `call.machine.detection.ended` if `answering_machine_detection` was requested
	// - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end
	// of machine greeting
	// - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
	// - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and
	// a beep was detected.
	//
	// POST /calls/{call_control_id}/actions/transfer
	TransferCall(ctx context.Context, request *TransferCallRequest, params TransferCallParams) (TransferCallRes, error)
	// UpdateBulkTelephonyCredential invokes UpdateBulkTelephonyCredential operation.
	//
	// Update several credentials in bulk.
	//
	// PATCH /actions/bulk/telephony_credentials
	UpdateBulkTelephonyCredential(ctx context.Context, request *BulkCredentialRequest, params UpdateBulkTelephonyCredentialParams) (UpdateBulkTelephonyCredentialRes, error)
	// UpdateCallControlApplication invokes UpdateCallControlApplication operation.
	//
	// Updates settings of an existing call control application.
	//
	// PATCH /call_control_applications/{id}
	UpdateCallControlApplication(ctx context.Context, request *UpdateCallControlApplicationRequest, params UpdateCallControlApplicationParams) (UpdateCallControlApplicationRes, error)
	// UpdateClientState invokes UpdateClientState operation.
	//
	// Updates client state.
	//
	// PUT /calls/{call_control_id}/actions/client_state_update
	UpdateClientState(ctx context.Context, request *ClientStateUpdateRequest, params UpdateClientStateParams) (UpdateClientStateRes, error)
	// UpdateCustomStorageCredentials invokes UpdateCustomStorageCredentials operation.
	//
	// Updates a stored custom credentials configuration.
	//
	// PUT /custom_storage_credentials/{connection_id}
	UpdateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params UpdateCustomStorageCredentialsParams) (UpdateCustomStorageCredentialsRes, error)
	// UpdateProfile invokes UpdateProfile operation.
	//
	// Update an existing Verified Calls Display Profile and allows adding/removing nested Call Reasons
	// and Phone Numbers. Different attributes can be updated depending on the Verified Calls Display
	// Profile's status: For the VERIFICATION_STATE_PENDING status, no fields can be updated. For the
	// VERIFICATION_STATE_VERIFIED status, it is allowed only to add/remove Call Reaons and Phone Numbers.
	//  For the other statuses, all fields can be updated. All existing Call Reasons and Phone Numbers
	// must be sent during the request, or the update will fail.
	//
	// PATCH /verified_calls_display_profiles/{id}
	UpdateProfile(ctx context.Context, request *UpdateVerifiedCallsDisplayProfileRequest, params UpdateProfileParams) (UpdateProfileRes, error)
	// UpdateTeXMLCallRecording invokes UpdateTeXMLCallRecording operation.
	//
	// Updates recording resource for particular call.
	//
	// POST /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings/{recording_sid}.json
	UpdateTeXMLCallRecording(ctx context.Context, request OptTexmlUpdateCallRecordingRequestBody, params UpdateTeXMLCallRecordingParams) (UpdateTeXMLCallRecordingRes, error)
	// UpdateTelephonyCredential invokes UpdateTelephonyCredential operation.
	//
	// Update an existing credential.
	//
	// PATCH /telephony_credentials/{id}
	UpdateTelephonyCredential(ctx context.Context, request *TelephonyCredentialUpdateRequest, params UpdateTelephonyCredentialParams) (UpdateTelephonyCredentialRes, error)
	// UpdateTexmlApplication invokes UpdateTexmlApplication operation.
	//
	// Updates settings of an existing TeXML Application.
	//
	// PATCH /texml_applications/{id}
	UpdateTexmlApplication(ctx context.Context, request *UpdateTexmlApplicationRequest, params UpdateTexmlApplicationParams) (UpdateTexmlApplicationRes, error)
	// UpdateTexmlCall invokes UpdateTexmlCall operation.
	//
	// Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase
	// as specified in the example.
	//
	// POST /texml/calls/{call_sid}/update
	UpdateTexmlCall(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallParams) (*UpdateTeXMLCallResponse, error)
	// UpdateTexmlCallByAccount invokes UpdateTexmlCallByAccount operation.
	//
	// Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase
	// as specified in the example.
	//
	// POST /texml/Accounts/{account_sid}/Calls/{call_sid}
	UpdateTexmlCallByAccount(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallByAccountParams) (*GetCallResponse, error)
	// UpdateTexmlConference invokes UpdateTexmlConference operation.
	//
	// Updates a conference resource.
	//
	// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}
	UpdateTexmlConference(ctx context.Context, request *UpdateConferenceRequest, params UpdateTexmlConferenceParams) (UpdateTexmlConferenceRes, error)
	// UpdateTexmlConferenceParticipant invokes UpdateTexmlConferenceParticipant operation.
	//
	// Updates a conference participant.
	//
	// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
	UpdateTexmlConferenceParticipant(ctx context.Context, request *UpdateConferenceParticipantRequest, params UpdateTexmlConferenceParticipantParams) (UpdateTexmlConferenceParticipantRes, error)
	// UpdateVerifyProfile invokes UpdateVerifyProfile operation.
	//
	// Update Verify profile.
	//
	// PATCH /verify_profiles/{verify_profile_id}
	UpdateVerifyProfile(ctx context.Context, request *UpdateVerifyProfileReq, params UpdateVerifyProfileParams) (UpdateVerifyProfileRes, error)
	// VerifyVerificationCode invokes VerifyVerificationCode operation.
	//
	// Submit verification code.
	//
	// POST /verified_numbers/{phone_number}/actions/verify
	VerifyVerificationCode(ctx context.Context, request *VerifyVerificationCodeReq, params VerifyVerificationCodeParams) (VerifyVerificationCodeRes, error)
	// VerifyVerificationCodeByPhoneNumber invokes VerifyVerificationCodeByPhoneNumber operation.
	//
	// Submit verification code.
	//
	// POST /verifications/by_phone_number/{phone_number}/actions/verify
	VerifyVerificationCodeByPhoneNumber(ctx context.Context, request *VerifyVerificationCodeRequest, params VerifyVerificationCodeByPhoneNumberParams) (VerifyVerificationCodeByPhoneNumberRes, error)
	// ViewRoomRecording invokes ViewRoomRecording operation.
	//
	// View a room recording.
	//
	// GET /room_recordings/{room_recording_id}
	ViewRoomRecording(ctx context.Context, params ViewRoomRecordingParams) (ViewRoomRecordingRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AnswerCall invokes AnswerCall operation.
//
// Answer an incoming call. You must issue this command before executing subsequent commands on an
// incoming call.
// **Expected Webhooks:**
// - `call.answered`
// - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set.
//
// POST /calls/{call_control_id}/actions/answer
func (c *Client) AnswerCall(ctx context.Context, request *AnswerRequest, params AnswerCallParams) (AnswerCallRes, error) {
	res, err := c.sendAnswerCall(ctx, request, params)
	return res, err
}

func (c *Client) sendAnswerCall(ctx context.Context, request *AnswerRequest, params AnswerCallParams) (res AnswerCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/answer"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnswerCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "AnswerCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAnswerCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AudioPublicAudioTranscriptionsPost invokes audio_public_audio_transcriptions_post operation.
//
// Transcribe speech to text. This endpoint is consistent with the [OpenAI Transcription
// API](https://platform.openai.com/docs/api-reference/audio/createTranscription) and may be used
// with the OpenAI JS or Python SDK.
//
// POST /ai/audio/transcriptions
func (c *Client) AudioPublicAudioTranscriptionsPost(ctx context.Context, request *AudioTranscriptionRequestMultipart) (AudioPublicAudioTranscriptionsPostRes, error) {
	res, err := c.sendAudioPublicAudioTranscriptionsPost(ctx, request)
	return res, err
}

func (c *Client) sendAudioPublicAudioTranscriptionsPost(ctx context.Context, request *AudioTranscriptionRequestMultipart) (res AudioPublicAudioTranscriptionsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ai/audio/transcriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAudioPublicAudioTranscriptionsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "AudioPublicAudioTranscriptionsPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAudioPublicAudioTranscriptionsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BridgeCall invokes BridgeCall operation.
//
// Bridge two call control calls.
// **Expected Webhooks:**
// - `call.bridged` for Leg A
// - `call.bridged` for Leg B.
//
// POST /calls/{call_control_id}/actions/bridge
func (c *Client) BridgeCall(ctx context.Context, request *BridgeRequest, params BridgeCallParams) (BridgeCallRes, error) {
	res, err := c.sendBridgeCall(ctx, request, params)
	return res, err
}

func (c *Client) sendBridgeCall(ctx context.Context, request *BridgeRequest, params BridgeCallParams) (res BridgeCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/bridge"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBridgeCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "BridgeCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBridgeCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BulkCredentialAction invokes BulkCredentialAction operation.
//
// Perform activate or deactivate action on all credentials filtered by the provided tag. Activate
// action will change the status to active, making it possible to connect calls with the credential.
// Deactivate action will change the status to inactive, making it impossible to connect calls with
// the credential.
//
// POST /actions/{action}/telephony_credentials
func (c *Client) BulkCredentialAction(ctx context.Context, params BulkCredentialActionParams) (BulkCredentialActionRes, error) {
	res, err := c.sendBulkCredentialAction(ctx, params)
	return res, err
}

func (c *Client) sendBulkCredentialAction(ctx context.Context, params BulkCredentialActionParams) (res BulkCredentialActionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/actions/"
	{
		// Encode "action" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "action",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Action)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilterTag))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "BulkCredentialAction", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBulkCredentialActionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateBulkTelephonyCredentials invokes CreateBulkTelephonyCredentials operation.
//
// Creates several credentials in bulk.
//
// POST /actions/bulk/telephony_credentials
func (c *Client) CreateBulkTelephonyCredentials(ctx context.Context, request *BulkCredentialRequest) (CreateBulkTelephonyCredentialsRes, error) {
	res, err := c.sendCreateBulkTelephonyCredentials(ctx, request)
	return res, err
}

func (c *Client) sendCreateBulkTelephonyCredentials(ctx context.Context, request *BulkCredentialRequest) (res CreateBulkTelephonyCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/actions/bulk/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBulkTelephonyCredentialsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateBulkTelephonyCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateBulkTelephonyCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCallControlApplication invokes CreateCallControlApplication operation.
//
// Create a call control application.
//
// POST /call_control_applications
func (c *Client) CreateCallControlApplication(ctx context.Context, request *CreateCallControlApplicationRequest) (CreateCallControlApplicationRes, error) {
	res, err := c.sendCreateCallControlApplication(ctx, request)
	return res, err
}

func (c *Client) sendCreateCallControlApplication(ctx context.Context, request *CreateCallControlApplicationRequest) (res CreateCallControlApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/call_control_applications"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCallControlApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateCallControlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCallControlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCustomStorageCredentials invokes CreateCustomStorageCredentials operation.
//
// Creates a custom storage credentials configuration.
//
// POST /custom_storage_credentials/{connection_id}
func (c *Client) CreateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params CreateCustomStorageCredentialsParams) (CreateCustomStorageCredentialsRes, error) {
	res, err := c.sendCreateCustomStorageCredentials(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params CreateCustomStorageCredentialsParams) (res CreateCustomStorageCredentialsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/custom_storage_credentials/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCustomStorageCredentialsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateCustomStorageCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCustomStorageCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateFlashcallVerification invokes CreateFlashcallVerification operation.
//
// Trigger Flash call verification.
//
// POST /verifications/flashcall
func (c *Client) CreateFlashcallVerification(ctx context.Context, request *CreateVerificationRequestFlashcall) (CreateFlashcallVerificationRes, error) {
	res, err := c.sendCreateFlashcallVerification(ctx, request)
	return res, err
}

func (c *Client) sendCreateFlashcallVerification(ctx context.Context, request *CreateVerificationRequestFlashcall) (res CreateFlashcallVerificationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verifications/flashcall"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateFlashcallVerificationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateFlashcallVerification", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateFlashcallVerificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProfile invokes CreateProfile operation.
//
// Creates a Verified Calls Display Profile associated with the given Business Identity.
//
// POST /verified_calls_display_profiles
func (c *Client) CreateProfile(ctx context.Context, request *CreateVerifiedCallsDisplayProfileRequest) (CreateProfileRes, error) {
	res, err := c.sendCreateProfile(ctx, request)
	return res, err
}

func (c *Client) sendCreateProfile(ctx context.Context, request *CreateVerifiedCallsDisplayProfileRequest) (res CreateProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verified_calls_display_profiles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProfileVerificationRequest invokes CreateProfileVerificationRequest operation.
//
// Starts a new Verified Calls Display Profile verification process.
//
// POST /verified_calls_display_profiles/{id}/verification_request
func (c *Client) CreateProfileVerificationRequest(ctx context.Context, params CreateProfileVerificationRequestParams) (CreateProfileVerificationRequestRes, error) {
	res, err := c.sendCreateProfileVerificationRequest(ctx, params)
	return res, err
}

func (c *Client) sendCreateProfileVerificationRequest(ctx context.Context, params CreateProfileVerificationRequestParams) (res CreateProfileVerificationRequestRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/verified_calls_display_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/verification_request"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateProfileVerificationRequest", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateProfileVerificationRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTelephonyCredential invokes CreateTelephonyCredential operation.
//
// Create a credential.
//
// POST /telephony_credentials
func (c *Client) CreateTelephonyCredential(ctx context.Context, request *TelephonyCredentialCreateRequest) (CreateTelephonyCredentialRes, error) {
	res, err := c.sendCreateTelephonyCredential(ctx, request)
	return res, err
}

func (c *Client) sendCreateTelephonyCredential(ctx context.Context, request *TelephonyCredentialCreateRequest) (res CreateTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTelephonyCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTelephonyCredentialToken invokes CreateTelephonyCredentialToken operation.
//
// Create an Access Token (JWT) for the credential.
//
// POST /telephony_credentials/{id}/token
func (c *Client) CreateTelephonyCredentialToken(ctx context.Context, params CreateTelephonyCredentialTokenParams) (CreateTelephonyCredentialTokenRes, error) {
	res, err := c.sendCreateTelephonyCredentialToken(ctx, params)
	return res, err
}

func (c *Client) sendCreateTelephonyCredentialToken(ctx context.Context, params CreateTelephonyCredentialTokenParams) (res CreateTelephonyCredentialTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateTelephonyCredentialToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTelephonyCredentialTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTexmlApplication invokes CreateTexmlApplication operation.
//
// Creates a TeXML Application.
//
// POST /texml_applications
func (c *Client) CreateTexmlApplication(ctx context.Context, request *CreateTexmlApplicationRequest) (CreateTexmlApplicationRes, error) {
	res, err := c.sendCreateTexmlApplication(ctx, request)
	return res, err
}

func (c *Client) sendCreateTexmlApplication(ctx context.Context, request *CreateTexmlApplicationRequest) (res CreateTexmlApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/texml_applications"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTexmlApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateTexmlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTexmlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTexmlSecret invokes CreateTexmlSecret operation.
//
// Create a TeXML secret which can be later used as a Dynamic Parameter for TeXML when using Mustache
// Templates in your TeXML. In your TeXML you will be able to use your secret name, and this name
// will be replaced by the actual secret value when processing the TeXML on Telnyx side.  The secrets
// are not visible in any logs.
//
// POST /texml/secrets
func (c *Client) CreateTexmlSecret(ctx context.Context, request *CreateTeXMLSecretRequest) (CreateTexmlSecretRes, error) {
	res, err := c.sendCreateTexmlSecret(ctx, request)
	return res, err
}

func (c *Client) sendCreateTexmlSecret(ctx context.Context, request *CreateTeXMLSecretRequest) (res CreateTexmlSecretRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/texml/secrets"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTexmlSecretRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateTexmlSecret", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTexmlSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerificationCall invokes CreateVerificationCall operation.
//
// Trigger Call verification.
//
// POST /verifications/call
func (c *Client) CreateVerificationCall(ctx context.Context, request *CreateVerificationRequestCall) (CreateVerificationCallRes, error) {
	res, err := c.sendCreateVerificationCall(ctx, request)
	return res, err
}

func (c *Client) sendCreateVerificationCall(ctx context.Context, request *CreateVerificationRequestCall) (res CreateVerificationCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verifications/call"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVerificationCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVerificationCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerificationCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerificationSms invokes CreateVerificationSms operation.
//
// Trigger SMS verification.
//
// POST /verifications/sms
func (c *Client) CreateVerificationSms(ctx context.Context, request *CreateVerificationRequestSMS) (CreateVerificationSmsRes, error) {
	res, err := c.sendCreateVerificationSms(ctx, request)
	return res, err
}

func (c *Client) sendCreateVerificationSms(ctx context.Context, request *CreateVerificationRequestSMS) (res CreateVerificationSmsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verifications/sms"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVerificationSmsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVerificationSms", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerificationSmsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerifiedNumber invokes CreateVerifiedNumber operation.
//
// Initiates phone number verification procedure.
//
// POST /verified_numbers
func (c *Client) CreateVerifiedNumber(ctx context.Context, request *CreateVerifiedNumberReq) (CreateVerifiedNumberRes, error) {
	res, err := c.sendCreateVerifiedNumber(ctx, request)
	return res, err
}

func (c *Client) sendCreateVerifiedNumber(ctx context.Context, request *CreateVerifiedNumberReq) (res CreateVerifiedNumberRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verified_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVerifiedNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVerifiedNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerifiedNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerifyProfile invokes CreateVerifyProfile operation.
//
// Creates a new Verify profile to associate verifications with.
//
// POST /verify_profiles
func (c *Client) CreateVerifyProfile(ctx context.Context, request *CreateVerifyProfileReq) (CreateVerifyProfileRes, error) {
	res, err := c.sendCreateVerifyProfile(ctx, request)
	return res, err
}

func (c *Client) sendCreateVerifyProfile(ctx context.Context, request *CreateVerifyProfileReq) (res CreateVerifyProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verify_profiles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVerifyProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVerifyProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerifyProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCallControlApplication invokes DeleteCallControlApplication operation.
//
// Deletes a call control application.
//
// DELETE /call_control_applications/{id}
func (c *Client) DeleteCallControlApplication(ctx context.Context, params DeleteCallControlApplicationParams) (DeleteCallControlApplicationRes, error) {
	res, err := c.sendDeleteCallControlApplication(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCallControlApplication(ctx context.Context, params DeleteCallControlApplicationParams) (res DeleteCallControlApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/call_control_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteCallControlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCallControlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCustomStorageCredentials invokes DeleteCustomStorageCredentials operation.
//
// Deletes a stored custom credentials configuration.
//
// DELETE /custom_storage_credentials/{connection_id}
func (c *Client) DeleteCustomStorageCredentials(ctx context.Context, params DeleteCustomStorageCredentialsParams) (DeleteCustomStorageCredentialsRes, error) {
	res, err := c.sendDeleteCustomStorageCredentials(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCustomStorageCredentials(ctx context.Context, params DeleteCustomStorageCredentialsParams) (res DeleteCustomStorageCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/custom_storage_credentials/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteCustomStorageCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCustomStorageCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProfile invokes DeleteProfile operation.
//
// Delete Verify profile.
//
// DELETE /verify_profiles/{verify_profile_id}
func (c *Client) DeleteProfile(ctx context.Context, params DeleteProfileParams) (DeleteProfileRes, error) {
	res, err := c.sendDeleteProfile(ctx, params)
	return res, err
}

func (c *Client) sendDeleteProfile(ctx context.Context, params DeleteProfileParams) (res DeleteProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verify_profiles/"
	{
		// Encode "verify_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "verify_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VerifyProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRecording invokes DeleteRecording operation.
//
// Permanently deletes a call recording.
//
// DELETE /recordings/{recording_id}
func (c *Client) DeleteRecording(ctx context.Context, params DeleteRecordingParams) (DeleteRecordingRes, error) {
	res, err := c.sendDeleteRecording(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRecording(ctx context.Context, params DeleteRecordingParams) (res DeleteRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/recordings/"
	{
		// Encode "recording_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRecordingTranscription invokes deleteRecordingTranscription operation.
//
// Permanently deletes a recording transcription.
//
// DELETE /recording_transcriptions/{recording_transcription_id}
func (c *Client) DeleteRecordingTranscription(ctx context.Context, params DeleteRecordingTranscriptionParams) (DeleteRecordingTranscriptionRes, error) {
	res, err := c.sendDeleteRecordingTranscription(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRecordingTranscription(ctx context.Context, params DeleteRecordingTranscriptionParams) (res DeleteRecordingTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/recording_transcriptions/"
	{
		// Encode "recording_transcription_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_transcription_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingTranscriptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRecordingTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRecordingTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRecordings invokes DeleteRecordings operation.
//
// Permanently deletes a list of call recordings.
//
// DELETE /recordings/actions/delete
func (c *Client) DeleteRecordings(ctx context.Context, request []string) (DeleteRecordingsRes, error) {
	res, err := c.sendDeleteRecordings(ctx, request)
	return res, err
}

func (c *Client) sendDeleteRecordings(ctx context.Context, request []string) (res DeleteRecordingsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if request == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/recordings/actions/delete"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteRecordingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRoomRecording invokes DeleteRoomRecording operation.
//
// Synchronously delete a Room Recording.
//
// DELETE /room_recordings/{room_recording_id}
func (c *Client) DeleteRoomRecording(ctx context.Context, params DeleteRoomRecordingParams) (DeleteRoomRecordingRes, error) {
	res, err := c.sendDeleteRoomRecording(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRoomRecording(ctx context.Context, params DeleteRoomRecordingParams) (res DeleteRoomRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/room_recordings/"
	{
		// Encode "room_recording_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "room_recording_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RoomRecordingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRoomRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRoomRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRoomRecordings invokes DeleteRoomRecordings operation.
//
// Delete several room recordings in a bulk.
//
// DELETE /room_recordings
func (c *Client) DeleteRoomRecordings(ctx context.Context, params DeleteRoomRecordingsParams) (DeleteRoomRecordingsRes, error) {
	res, err := c.sendDeleteRoomRecordings(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRoomRecordings(ctx context.Context, params DeleteRoomRecordingsParams) (res DeleteRoomRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/room_recordings"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[date_ended_at][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtEq.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_ended_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_ended_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtEq.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[room_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[room_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterRoomID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[participant_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[participant_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterParticipantID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[session_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[session_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterSessionID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[type]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsEq.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsLte.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsGte.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRoomRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRoomRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTeXMLCallRecording invokes DeleteTeXMLCallRecording operation.
//
// Deletes recording resource identified by recording id.
//
// DELETE /texml/Accounts/{account_sid}/Recordings/{recording_sid}.json
func (c *Client) DeleteTeXMLCallRecording(ctx context.Context, params DeleteTeXMLCallRecordingParams) (DeleteTeXMLCallRecordingRes, error) {
	res, err := c.sendDeleteTeXMLCallRecording(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTeXMLCallRecording(ctx context.Context, params DeleteTeXMLCallRecordingParams) (res DeleteTeXMLCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Recordings/"
	{
		// Encode "recording_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTeXMLCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTeXMLCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTeXMLRecordingTranscription invokes DeleteTeXMLRecordingTranscription operation.
//
// Permanently deletes a recording transcription.
//
// DELETE /texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json
func (c *Client) DeleteTeXMLRecordingTranscription(ctx context.Context, params DeleteTeXMLRecordingTranscriptionParams) (DeleteTeXMLRecordingTranscriptionRes, error) {
	res, err := c.sendDeleteTeXMLRecordingTranscription(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTeXMLRecordingTranscription(ctx context.Context, params DeleteTeXMLRecordingTranscriptionParams) (res DeleteTeXMLRecordingTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Transcriptions/"
	{
		// Encode "recording_transcription_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_transcription_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingTranscriptionSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTeXMLRecordingTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTeXMLRecordingTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTelephonyCredential invokes DeleteTelephonyCredential operation.
//
// Delete an existing credential.
//
// DELETE /telephony_credentials/{id}
func (c *Client) DeleteTelephonyCredential(ctx context.Context, params DeleteTelephonyCredentialParams) (DeleteTelephonyCredentialRes, error) {
	res, err := c.sendDeleteTelephonyCredential(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTelephonyCredential(ctx context.Context, params DeleteTelephonyCredentialParams) (res DeleteTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTelephonyCredentials invokes DeleteTelephonyCredentials operation.
//
// Delete several credentials in bulk.
//
// DELETE /actions/bulk/telephony_credentials
func (c *Client) DeleteTelephonyCredentials(ctx context.Context, params DeleteTelephonyCredentialsParams) (DeleteTelephonyCredentialsRes, error) {
	res, err := c.sendDeleteTelephonyCredentials(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTelephonyCredentials(ctx context.Context, params DeleteTelephonyCredentialsParams) (res DeleteTelephonyCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/actions/bulk/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilterTag))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTelephonyCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTelephonyCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTexmlApplication invokes DeleteTexmlApplication operation.
//
// Deletes a TeXML Application.
//
// DELETE /texml_applications/{id}
func (c *Client) DeleteTexmlApplication(ctx context.Context, params DeleteTexmlApplicationParams) (DeleteTexmlApplicationRes, error) {
	res, err := c.sendDeleteTexmlApplication(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTexmlApplication(ctx context.Context, params DeleteTexmlApplicationParams) (res DeleteTexmlApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/texml_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTexmlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTexmlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTexmlConferenceParticipant invokes DeleteTexmlConferenceParticipant operation.
//
// Deletes a conference participant.
//
// DELETE /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
func (c *Client) DeleteTexmlConferenceParticipant(ctx context.Context, params DeleteTexmlConferenceParticipantParams) (DeleteTexmlConferenceParticipantRes, error) {
	res, err := c.sendDeleteTexmlConferenceParticipant(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTexmlConferenceParticipant(ctx context.Context, params DeleteTexmlConferenceParticipantParams) (res DeleteTexmlConferenceParticipantRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTexmlConferenceParticipant", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTexmlConferenceParticipantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVerifiedCallDisplayProfile invokes DeleteVerifiedCallDisplayProfile operation.
//
// Deletes the Verified Calls Display Profile. This action will fail if any verification requests
// have been made for this Verified Calls Display Profile. Please contact support@telnyx.com in case
// you want to delete a Verified Calls Display Profile in that situation.
//
// DELETE /verified_calls_display_profiles/{id}
func (c *Client) DeleteVerifiedCallDisplayProfile(ctx context.Context, params DeleteVerifiedCallDisplayProfileParams) (DeleteVerifiedCallDisplayProfileRes, error) {
	res, err := c.sendDeleteVerifiedCallDisplayProfile(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVerifiedCallDisplayProfile(ctx context.Context, params DeleteVerifiedCallDisplayProfileParams) (res DeleteVerifiedCallDisplayProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_calls_display_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteVerifiedCallDisplayProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVerifiedCallDisplayProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVerifiedNumber invokes DeleteVerifiedNumber operation.
//
// Delete a verified number.
//
// DELETE /verified_numbers/{phone_number}
func (c *Client) DeleteVerifiedNumber(ctx context.Context, params DeleteVerifiedNumberParams) (DeleteVerifiedNumberRes, error) {
	res, err := c.sendDeleteVerifiedNumber(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVerifiedNumber(ctx context.Context, params DeleteVerifiedNumberParams) (res DeleteVerifiedNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_numbers/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteVerifiedNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVerifiedNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DialCall invokes DialCall operation.
//
// Dial a number or SIP URI from a given connection. A successful response will include a
// `call_leg_id` which can be used to correlate the command with subsequent webhooks.
// **Expected Webhooks:**
// - `call.initiated`
// - `call.answered` or `call.hangup`
// - `call.machine.detection.ended` if `answering_machine_detection` was requested
// - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end
// of machine greeting
// - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
// - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and
// a beep was detected
// - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set.
//
// POST /calls
func (c *Client) DialCall(ctx context.Context, request *CallRequest) (DialCallRes, error) {
	res, err := c.sendDialCall(ctx, request)
	return res, err
}

func (c *Client) sendDialCall(ctx context.Context, request *CallRequest) (res DialCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/calls"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDialCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DialCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDialCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DialTexmlConferenceParticipant invokes DialTexmlConferenceParticipant operation.
//
// Dials a new conference participant.
//
// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants
func (c *Client) DialTexmlConferenceParticipant(ctx context.Context, request *DialConferenceParticipantRequest, params DialTexmlConferenceParticipantParams) (DialTexmlConferenceParticipantRes, error) {
	res, err := c.sendDialTexmlConferenceParticipant(ctx, request, params)
	return res, err
}

func (c *Client) sendDialTexmlConferenceParticipant(ctx context.Context, request *DialConferenceParticipantRequest, params DialTexmlConferenceParticipantParams) (res DialTexmlConferenceParticipantRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDialTexmlConferenceParticipantRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DialTexmlConferenceParticipant", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDialTexmlConferenceParticipantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DisplayProfile invokes DisplayProfile operation.
//
// Display the Verified Calls Display Profile.
//
// GET /verified_calls_display_profiles/{id}
func (c *Client) DisplayProfile(ctx context.Context, params DisplayProfileParams) (DisplayProfileRes, error) {
	res, err := c.sendDisplayProfile(ctx, params)
	return res, err
}

func (c *Client) sendDisplayProfile(ctx context.Context, params DisplayProfileParams) (res DisplayProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_calls_display_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DisplayProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDisplayProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnqueueCall invokes EnqueueCall operation.
//
// Put the call in a queue.
//
// POST /calls/{call_control_id}/actions/enqueue
func (c *Client) EnqueueCall(ctx context.Context, request *EnqueueRequest, params EnqueueCallParams) (EnqueueCallRes, error) {
	res, err := c.sendEnqueueCall(ctx, request, params)
	return res, err
}

func (c *Client) sendEnqueueCall(ctx context.Context, request *EnqueueRequest, params EnqueueCallParams) (res EnqueueCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enqueue"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnqueueCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "EnqueueCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnqueueCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FetchTeXMLCallRecordings invokes FetchTeXMLCallRecordings operation.
//
// Returns recordings for a call identified by call_sid.
//
// GET /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json
func (c *Client) FetchTeXMLCallRecordings(ctx context.Context, params FetchTeXMLCallRecordingsParams) (FetchTeXMLCallRecordingsRes, error) {
	res, err := c.sendFetchTeXMLCallRecordings(ctx, params)
	return res, err
}

func (c *Client) sendFetchTeXMLCallRecordings(ctx context.Context, params FetchTeXMLCallRecordingsParams) (res FetchTeXMLCallRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FetchTeXMLCallRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFetchTeXMLCallRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FetchTeXMLConferenceRecordings invokes FetchTeXMLConferenceRecordings operation.
//
// Returns recordings for a conference identified by conference_sid.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings.json
func (c *Client) FetchTeXMLConferenceRecordings(ctx context.Context, params FetchTeXMLConferenceRecordingsParams) (FetchTeXMLConferenceRecordingsRes, error) {
	res, err := c.sendFetchTeXMLConferenceRecordings(ctx, params)
	return res, err
}

func (c *Client) sendFetchTeXMLConferenceRecordings(ctx context.Context, params FetchTeXMLConferenceRecordingsParams) (res FetchTeXMLConferenceRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FetchTeXMLConferenceRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFetchTeXMLConferenceRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindTelephonyCredentials invokes FindTelephonyCredentials operation.
//
// List all On-demand Credentials.
//
// GET /telephony_credentials
func (c *Client) FindTelephonyCredentials(ctx context.Context, params FindTelephonyCredentialsParams) (FindTelephonyCredentialsRes, error) {
	res, err := c.sendFindTelephonyCredentials(ctx, params)
	return res, err
}

func (c *Client) sendFindTelephonyCredentials(ctx context.Context, params FindTelephonyCredentialsParams) (res FindTelephonyCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTag.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[name]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[resource_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[resource_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterResourceID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[sip_username]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[sip_username]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterSipUsername.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FindTelephonyCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindTelephonyCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindTexmlApplications invokes FindTexmlApplications operation.
//
// Returns a list of your TeXML Applications.
//
// GET /texml_applications
func (c *Client) FindTexmlApplications(ctx context.Context, params FindTexmlApplicationsParams) (FindTexmlApplicationsRes, error) {
	res, err := c.sendFindTexmlApplications(ctx, params)
	return res, err
}

func (c *Client) sendFindTexmlApplications(ctx context.Context, params FindTexmlApplicationsParams) (res FindTexmlApplicationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/texml_applications"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[friendly_name][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[friendly_name][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterFriendlyNameContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[outbound_voice_profile_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[outbound_voice_profile_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterOutboundVoiceProfileID.Get(); ok {
				return e.EncodeValue(conv.StringInt64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FindTexmlApplications", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindTexmlApplicationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatherCall invokes GatherCall operation.
//
// Gather DTMF signals to build interactive menus.
// You can pass a list of valid digits. The `Answer` command must be issued before the `gather`
// command.
// **Expected Webhooks:**
// - `call.dtmf.received` (you may receive many of these webhooks)
// - `call.gather.ended`.
//
// POST /calls/{call_control_id}/actions/gather
func (c *Client) GatherCall(ctx context.Context, request *GatherRequest, params GatherCallParams) (GatherCallRes, error) {
	res, err := c.sendGatherCall(ctx, request, params)
	return res, err
}

func (c *Client) sendGatherCall(ctx context.Context, request *GatherRequest, params GatherCallParams) (res GatherCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/gather"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatherCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GatherCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGatherCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatherUsingAudio invokes GatherUsingAudio operation.
//
// Play an audio file on the call until the required DTMF signals are gathered to build interactive
// menus.
// You can pass a list of valid digits along with an 'invalid_audio_url', which will be played back
// at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The
// `Answer command must be issued before the `gather_using_audio` command.
// **Expected Webhooks:**
// - `call.playback.started`
// - `call.playback.ended`
// - `call.dtmf.received` (you may receive many of these webhooks)
// - `call.gather.ended`.
//
// POST /calls/{call_control_id}/actions/gather_using_audio
func (c *Client) GatherUsingAudio(ctx context.Context, request *GatherUsingAudioRequest, params GatherUsingAudioParams) (GatherUsingAudioRes, error) {
	res, err := c.sendGatherUsingAudio(ctx, request, params)
	return res, err
}

func (c *Client) sendGatherUsingAudio(ctx context.Context, request *GatherUsingAudioRequest, params GatherUsingAudioParams) (res GatherUsingAudioRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/gather_using_audio"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatherUsingAudioRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GatherUsingAudio", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGatherUsingAudioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatherUsingSpeak invokes GatherUsingSpeak operation.
//
// Convert text to speech and play it on the call until the required DTMF signals are gathered to
// build interactive menus.
// You can pass a list of valid digits along with an 'invalid_payload', which will be played back at
// the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The
// `Answer` command must be issued before the `gather_using_speak` command.
// **Expected Webhooks:**
// - `call.dtmf.received` (you may receive many of these webhooks)
// - `call.gather.ended`.
//
// POST /calls/{call_control_id}/actions/gather_using_speak
func (c *Client) GatherUsingSpeak(ctx context.Context, request *GatherUsingSpeakRequest, params GatherUsingSpeakParams) (GatherUsingSpeakRes, error) {
	res, err := c.sendGatherUsingSpeak(ctx, request, params)
	return res, err
}

func (c *Client) sendGatherUsingSpeak(ctx context.Context, request *GatherUsingSpeakRequest, params GatherUsingSpeakParams) (res GatherUsingSpeakRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/gather_using_speak"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatherUsingSpeakRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GatherUsingSpeak", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGatherUsingSpeakResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomStorageCredentials invokes GetCustomStorageCredentials operation.
//
// Returns the information about custom storage credentials.
//
// GET /custom_storage_credentials/{connection_id}
func (c *Client) GetCustomStorageCredentials(ctx context.Context, params GetCustomStorageCredentialsParams) (GetCustomStorageCredentialsRes, error) {
	res, err := c.sendGetCustomStorageCredentials(ctx, params)
	return res, err
}

func (c *Client) sendGetCustomStorageCredentials(ctx context.Context, params GetCustomStorageCredentialsParams) (res GetCustomStorageCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/custom_storage_credentials/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetCustomStorageCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCustomStorageCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecording invokes GetRecording operation.
//
// Retrieves the details of an existing call recording.
//
// GET /recordings/{recording_id}
func (c *Client) GetRecording(ctx context.Context, params GetRecordingParams) (GetRecordingRes, error) {
	res, err := c.sendGetRecording(ctx, params)
	return res, err
}

func (c *Client) sendGetRecording(ctx context.Context, params GetRecordingParams) (res GetRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/recordings/"
	{
		// Encode "recording_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecordingTranscription invokes getRecordingTranscription operation.
//
// Retrieves the details of an existing recording transcription.
//
// GET /recording_transcriptions/{recording_transcription_id}
func (c *Client) GetRecordingTranscription(ctx context.Context, params GetRecordingTranscriptionParams) (GetRecordingTranscriptionRes, error) {
	res, err := c.sendGetRecordingTranscription(ctx, params)
	return res, err
}

func (c *Client) sendGetRecordingTranscription(ctx context.Context, params GetRecordingTranscriptionParams) (res GetRecordingTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/recording_transcriptions/"
	{
		// Encode "recording_transcription_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_transcription_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingTranscriptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRecordingTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecordingTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecordingTranscriptions invokes getRecordingTranscriptions operation.
//
// Returns a list of your recording transcriptions.
//
// GET /recording_transcriptions
func (c *Client) GetRecordingTranscriptions(ctx context.Context) (GetRecordingTranscriptionsRes, error) {
	res, err := c.sendGetRecordingTranscriptions(ctx)
	return res, err
}

func (c *Client) sendGetRecordingTranscriptions(ctx context.Context) (res GetRecordingTranscriptionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/recording_transcriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRecordingTranscriptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecordingTranscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecordings invokes GetRecordings operation.
//
// Returns a list of your call recordings.
//
// GET /recordings
func (c *Client) GetRecordings(ctx context.Context, params GetRecordingsParams) (GetRecordingsRes, error) {
	res, err := c.sendGetRecordings(ctx, params)
	return res, err
}

func (c *Client) sendGetRecordings(ctx context.Context, params GetRecordingsParams) (res GetRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/recordings"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[conference_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[conference_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterConferenceID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[created_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[created_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCreatedAtGte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[created_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[created_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCreatedAtLte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[call_leg_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[call_leg_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCallLegID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[call_session_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[call_session_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCallSessionID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[from]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[from]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterFrom.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[to]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[to]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTo.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[connection_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[connection_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterConnectionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeXMLCallRecording invokes GetTeXMLCallRecording operation.
//
// Returns recording resource identified by recording id.
//
// GET /texml/Accounts/{account_sid}/Recordings/{recording_sid}.json
func (c *Client) GetTeXMLCallRecording(ctx context.Context, params GetTeXMLCallRecordingParams) (GetTeXMLCallRecordingRes, error) {
	res, err := c.sendGetTeXMLCallRecording(ctx, params)
	return res, err
}

func (c *Client) sendGetTeXMLCallRecording(ctx context.Context, params GetTeXMLCallRecordingParams) (res GetTeXMLCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Recordings/"
	{
		// Encode "recording_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTeXMLCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeXMLCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeXMLCallRecordings invokes GetTeXMLCallRecordings operation.
//
// Returns multiple recording resources for an account.
//
// GET /texml/Accounts/{account_sid}/Recordings.json
func (c *Client) GetTeXMLCallRecordings(ctx context.Context, params GetTeXMLCallRecordingsParams) (GetTeXMLCallRecordingsRes, error) {
	res, err := c.sendGetTeXMLCallRecordings(ctx, params)
	return res, err
}

func (c *Client) sendGetTeXMLCallRecordings(ctx context.Context, params GetTeXMLCallRecordingsParams) (res GetTeXMLCallRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Recordings.json"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "DateCreated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "DateCreated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateCreated.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTeXMLCallRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeXMLCallRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeXMLRecordingTranscription invokes GetTeXMLRecordingTranscription operation.
//
// Returns the recording transcription resource identified by its ID.
//
// GET /texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json
func (c *Client) GetTeXMLRecordingTranscription(ctx context.Context, params GetTeXMLRecordingTranscriptionParams) (GetTeXMLRecordingTranscriptionRes, error) {
	res, err := c.sendGetTeXMLRecordingTranscription(ctx, params)
	return res, err
}

func (c *Client) sendGetTeXMLRecordingTranscription(ctx context.Context, params GetTeXMLRecordingTranscriptionParams) (res GetTeXMLRecordingTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Transcriptions/"
	{
		// Encode "recording_transcription_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_transcription_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingTranscriptionSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTeXMLRecordingTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeXMLRecordingTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeXMLRecordingTranscriptions invokes GetTeXMLRecordingTranscriptions operation.
//
// Returns multiple recording transcription resources for an account.
//
// GET /texml/Accounts/{account_sid}/Transcriptions.json
func (c *Client) GetTeXMLRecordingTranscriptions(ctx context.Context, params GetTeXMLRecordingTranscriptionsParams) (GetTeXMLRecordingTranscriptionsRes, error) {
	res, err := c.sendGetTeXMLRecordingTranscriptions(ctx, params)
	return res, err
}

func (c *Client) sendGetTeXMLRecordingTranscriptions(ctx context.Context, params GetTeXMLRecordingTranscriptionsParams) (res GetTeXMLRecordingTranscriptionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Transcriptions.json"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "PageToken" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageToken",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTeXMLRecordingTranscriptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeXMLRecordingTranscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTelephonyCredential invokes GetTelephonyCredential operation.
//
// Get the details of an existing On-demand Credential.
//
// GET /telephony_credentials/{id}
func (c *Client) GetTelephonyCredential(ctx context.Context, params GetTelephonyCredentialParams) (GetTelephonyCredentialRes, error) {
	res, err := c.sendGetTelephonyCredential(ctx, params)
	return res, err
}

func (c *Client) sendGetTelephonyCredential(ctx context.Context, params GetTelephonyCredentialParams) (res GetTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlApplication invokes GetTexmlApplication operation.
//
// Retrieves the details of an existing TeXML Application.
//
// GET /texml_applications/{id}
func (c *Client) GetTexmlApplication(ctx context.Context, params GetTexmlApplicationParams) (GetTexmlApplicationRes, error) {
	res, err := c.sendGetTexmlApplication(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlApplication(ctx context.Context, params GetTexmlApplicationParams) (res GetTexmlApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/texml_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlCall invokes GetTexmlCall operation.
//
// Returns an individual call identified by its CallSid. This endpoint is eventually consistent.
//
// GET /texml/Accounts/{account_sid}/Calls/{call_sid}
func (c *Client) GetTexmlCall(ctx context.Context, params GetTexmlCallParams) (GetTexmlCallRes, error) {
	res, err := c.sendGetTexmlCall(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlCall(ctx context.Context, params GetTexmlCallParams) (res GetTexmlCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlCalls invokes GetTexmlCalls operation.
//
// Returns multiple call resouces for an account. This endpoint is eventually consistent.
//
// GET /texml/Accounts/{account_sid}/Calls
func (c *Client) GetTexmlCalls(ctx context.Context, params GetTexmlCallsParams) (GetTexmlCallsRes, error) {
	res, err := c.sendGetTexmlCalls(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlCalls(ctx context.Context, params GetTexmlCallsParams) (res GetTexmlCallsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageToken" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageToken",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "To" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "To",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "From" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "From",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "StartTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "StartTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "EndTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "EndTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlCalls", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConference invokes GetTexmlConference operation.
//
// Returns a conference resource.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}
func (c *Client) GetTexmlConference(ctx context.Context, params GetTexmlConferenceParams) (GetTexmlConferenceRes, error) {
	res, err := c.sendGetTexmlConference(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConference(ctx context.Context, params GetTexmlConferenceParams) (res GetTexmlConferenceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConference", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferenceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConferenceParticipant invokes GetTexmlConferenceParticipant operation.
//
// Gets conference participant resource.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
func (c *Client) GetTexmlConferenceParticipant(ctx context.Context, params GetTexmlConferenceParticipantParams) (GetTexmlConferenceParticipantRes, error) {
	res, err := c.sendGetTexmlConferenceParticipant(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConferenceParticipant(ctx context.Context, params GetTexmlConferenceParticipantParams) (res GetTexmlConferenceParticipantRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConferenceParticipant", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferenceParticipantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConferenceParticipants invokes GetTexmlConferenceParticipants operation.
//
// Lists conference participants.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants
func (c *Client) GetTexmlConferenceParticipants(ctx context.Context, params GetTexmlConferenceParticipantsParams) (GetTexmlConferenceParticipantsRes, error) {
	res, err := c.sendGetTexmlConferenceParticipants(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConferenceParticipants(ctx context.Context, params GetTexmlConferenceParticipantsParams) (res GetTexmlConferenceParticipantsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConferenceParticipants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferenceParticipantsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConferenceRecordings invokes GetTexmlConferenceRecordings operation.
//
// Lists conference recordings.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings
func (c *Client) GetTexmlConferenceRecordings(ctx context.Context, params GetTexmlConferenceRecordingsParams) (GetTexmlConferenceRecordingsRes, error) {
	res, err := c.sendGetTexmlConferenceRecordings(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConferenceRecordings(ctx context.Context, params GetTexmlConferenceRecordingsParams) (res GetTexmlConferenceRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConferenceRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferenceRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConferences invokes GetTexmlConferences operation.
//
// Lists conference resources.
//
// GET /texml/Accounts/{account_sid}/Conferences
func (c *Client) GetTexmlConferences(ctx context.Context, params GetTexmlConferencesParams) (GetTexmlConferencesRes, error) {
	res, err := c.sendGetTexmlConferences(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConferences(ctx context.Context, params GetTexmlConferencesParams) (res GetTexmlConferencesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageToken" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageToken",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "FriendlyName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "FriendlyName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FriendlyName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "DateCreated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "DateCreated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateCreated.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "DateUpdated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "DateUpdated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateUpdated.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConferences", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferencesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsageReportByApplication invokes GetUsageReportByApplication operation.
//
// Get Telnyx usage data by product, broken out by the specified dimensions.
//
// GET /usage_reports
func (c *Client) GetUsageReportByApplication(ctx context.Context, params GetUsageReportByApplicationParams) (GetUsageReportByApplicationRes, error) {
	res, err := c.sendGetUsageReportByApplication(ctx, params)
	return res, err
}

func (c *Client) sendGetUsageReportByApplication(ctx context.Context, params GetUsageReportByApplicationParams) (res GetUsageReportByApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/usage_reports"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "product" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "product",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Product))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dimensions" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dimensions",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Dimensions {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "metrics" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "metrics",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Metrics {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "date_range" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "date_range",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateRange.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "managed_accounts" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "managed_accounts",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ManagedAccounts.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Sort != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Sort {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Format.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetUsageReportByApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUsageReportByApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsageReportSync invokes GetUsageReportSync operation.
//
// Generate and fetch messaging usage report synchronously. This endpoint will both generate and
// fetch the messaging report over a specified time period. No polling is necessary but the response
// may take up to a couple of minutes.
//
// GET /reports/mdr_usage_reports/sync
func (c *Client) GetUsageReportSync(ctx context.Context, params GetUsageReportSyncParams) (*MdrGetSyncUsageReportResponse, error) {
	res, err := c.sendGetUsageReportSync(ctx, params)
	return res, err
}

func (c *Client) sendGetUsageReportSync(ctx context.Context, params GetUsageReportSyncParams) (res *MdrGetSyncUsageReportResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/reports/mdr_usage_reports/sync"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "aggregation_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "aggregation_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.AggregationType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "profiles" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "profiles",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Profiles != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Profiles {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetUsageReportSync", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUsageReportSyncResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsageReports invokes GetUsageReports operation.
//
// Fetch all messaging usage reports. Usage reports are aggregated messaging data for specified time
// period and breakdown.
//
// GET /reports/mdr_usage_reports
func (c *Client) GetUsageReports(ctx context.Context, params GetUsageReportsParams) (*MdrGetUsageReportsResponse, error) {
	res, err := c.sendGetUsageReports(ctx, params)
	return res, err
}

func (c *Client) sendGetUsageReports(ctx context.Context, params GetUsageReportsParams) (res *MdrGetUsageReportsResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/reports/mdr_usage_reports"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetUsageReports", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUsageReportsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserBalance invokes GetUserBalance operation.
//
// Get user balance details.
//
// GET /balance
func (c *Client) GetUserBalance(ctx context.Context) (GetUserBalanceRes, error) {
	res, err := c.sendGetUserBalance(ctx)
	return res, err
}

func (c *Client) sendGetUserBalance(ctx context.Context) (res GetUserBalanceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/balance"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetUserBalance", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserBalanceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVerifiedNumber invokes GetVerifiedNumber operation.
//
// Retrieve a verified number.
//
// GET /verified_numbers/{phone_number}
func (c *Client) GetVerifiedNumber(ctx context.Context, params GetVerifiedNumberParams) (GetVerifiedNumberRes, error) {
	res, err := c.sendGetVerifiedNumber(ctx, params)
	return res, err
}

func (c *Client) sendGetVerifiedNumber(ctx context.Context, params GetVerifiedNumberParams) (res GetVerifiedNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_numbers/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVerifiedNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVerifiedNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVerifyProfile invokes GetVerifyProfile operation.
//
// Gets a single Verify profile.
//
// GET /verify_profiles/{verify_profile_id}
func (c *Client) GetVerifyProfile(ctx context.Context, params GetVerifyProfileParams) (GetVerifyProfileRes, error) {
	res, err := c.sendGetVerifyProfile(ctx, params)
	return res, err
}

func (c *Client) sendGetVerifyProfile(ctx context.Context, params GetVerifyProfileParams) (res GetVerifyProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verify_profiles/"
	{
		// Encode "verify_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "verify_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VerifyProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVerifyProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVerifyProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookDelivery invokes GetWebhookDelivery operation.
//
// Provides webhook_delivery debug data, such as timestamps, delivery status and attempts.
//
// GET /webhook_deliveries/{id}
func (c *Client) GetWebhookDelivery(ctx context.Context, params GetWebhookDeliveryParams) (GetWebhookDeliveryRes, error) {
	res, err := c.sendGetWebhookDelivery(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhookDelivery(ctx context.Context, params GetWebhookDeliveryParams) (res GetWebhookDeliveryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/webhook_deliveries/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetWebhookDelivery", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookDeliveryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HangupCall invokes HangupCall operation.
//
// Hang up the call.
// **Expected Webhooks:**
// - `call.hangup`
// - `call.recording.saved`.
//
// POST /calls/{call_control_id}/actions/hangup
func (c *Client) HangupCall(ctx context.Context, request *HangupRequest, params HangupCallParams) (HangupCallRes, error) {
	res, err := c.sendHangupCall(ctx, request, params)
	return res, err
}

func (c *Client) sendHangupCall(ctx context.Context, request *HangupRequest, params HangupCallParams) (res HangupCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/hangup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHangupCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "HangupCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHangupCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InitiateTexmlCallByAccount invokes InitiateTexmlCallByAccount operation.
//
// Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for
// the connection in the Mission Control Portal.
//
// POST /texml/Accounts/{account_sid}/Calls
func (c *Client) InitiateTexmlCallByAccount(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByAccountParams) (*InitiateCallResponse, error) {
	res, err := c.sendInitiateTexmlCallByAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendInitiateTexmlCallByAccount(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByAccountParams) (res *InitiateCallResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInitiateTexmlCallByAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "InitiateTexmlCallByAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInitiateTexmlCallByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InitiateTexmlCallByApplication invokes InitiateTexmlCallByApplication operation.
//
// Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for
// the connection in the Mission Control Portal.
//
// POST /texml/calls/{application_id}
func (c *Client) InitiateTexmlCallByApplication(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByApplicationParams) (*InitiateCallResponse, error) {
	res, err := c.sendInitiateTexmlCallByApplication(ctx, request, params)
	return res, err
}

func (c *Client) sendInitiateTexmlCallByApplication(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByApplicationParams) (res *InitiateCallResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/texml/calls/"
	{
		// Encode "application_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "application_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApplicationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInitiateTexmlCallByApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "InitiateTexmlCallByApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInitiateTexmlCallByApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeaveQueue invokes LeaveQueue operation.
//
// Removes the call from a queue.
//
// POST /calls/{call_control_id}/actions/leave_queue
func (c *Client) LeaveQueue(ctx context.Context, request *LeaveQueueRequest, params LeaveQueueParams) (LeaveQueueRes, error) {
	res, err := c.sendLeaveQueue(ctx, request, params)
	return res, err
}

func (c *Client) sendLeaveQueue(ctx context.Context, request *LeaveQueueRequest, params LeaveQueueParams) (res LeaveQueueRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/leave_queue"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLeaveQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "LeaveQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeaveQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCallControlApplications invokes ListCallControlApplications operation.
//
// Return a list of call control applications.
//
// GET /call_control_applications
func (c *Client) ListCallControlApplications(ctx context.Context, params ListCallControlApplicationsParams) (ListCallControlApplicationsRes, error) {
	res, err := c.sendListCallControlApplications(ctx, params)
	return res, err
}

func (c *Client) sendListCallControlApplications(ctx context.Context, params ListCallControlApplicationsParams) (res ListCallControlApplicationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/call_control_applications"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[application_name][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[application_name][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterApplicationNameContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[outbound_voice_profile_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[outbound_voice_profile_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterOutboundVoiceProfileID.Get(); ok {
				return e.EncodeValue(conv.StringInt64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListCallControlApplications", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListCallControlApplicationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListConnectionActiveCalls invokes ListConnectionActiveCalls operation.
//
// Lists all active calls for given connection. Acceptable connections are either SIP connections
// with webhook_url or xml_request_url, call control or texml. Returned results are cursor paginated.
//
// GET /connections/{connection_id}/active_calls
func (c *Client) ListConnectionActiveCalls(ctx context.Context, params ListConnectionActiveCallsParams) (ListConnectionActiveCallsRes, error) {
	res, err := c.sendListConnectionActiveCalls(ctx, params)
	return res, err
}

func (c *Client) sendListConnectionActiveCalls(ctx context.Context, params ListConnectionActiveCallsParams) (res ListConnectionActiveCallsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connections/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/active_calls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[limit]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[limit]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageLimit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[after]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[after]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageAfter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[before]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[before]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageBefore.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListConnectionActiveCalls", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListConnectionActiveCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListProfileMessageTemplates invokes ListProfileMessageTemplates operation.
//
// List all Verify profile message templates.
//
// GET /verify_profiles/templates
func (c *Client) ListProfileMessageTemplates(ctx context.Context) (*ListVerifyProfileMessageTemplateResponse, error) {
	res, err := c.sendListProfileMessageTemplates(ctx)
	return res, err
}

func (c *Client) sendListProfileMessageTemplates(ctx context.Context) (res *ListVerifyProfileMessageTemplateResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verify_profiles/templates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListProfileMessageTemplates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListProfileMessageTemplatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListProfiles invokes ListProfiles operation.
//
// Gets a paginated list of Verify profiles.
//
// GET /verify_profiles
func (c *Client) ListProfiles(ctx context.Context, params ListProfilesParams) (ListProfilesRes, error) {
	res, err := c.sendListProfiles(ctx, params)
	return res, err
}

func (c *Client) sendListProfiles(ctx context.Context, params ListProfilesParams) (res ListProfilesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verify_profiles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[name]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListProfiles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListProfilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListQueueCalls invokes ListQueueCalls operation.
//
// Retrieve the list of calls in an existing queue.
//
// GET /queues/{queue_name}/calls
func (c *Client) ListQueueCalls(ctx context.Context, params ListQueueCallsParams) (ListQueueCallsRes, error) {
	res, err := c.sendListQueueCalls(ctx, params)
	return res, err
}

func (c *Client) sendListQueueCalls(ctx context.Context, params ListQueueCallsParams) (res ListQueueCallsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/queues/"
	{
		// Encode "queue_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueueName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListQueueCalls", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListQueueCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRoomRecordings invokes ListRoomRecordings operation.
//
// View a list of room recordings.
//
// GET /room_recordings
func (c *Client) ListRoomRecordings(ctx context.Context, params ListRoomRecordingsParams) (*ListRoomRecordingsResponse, error) {
	res, err := c.sendListRoomRecordings(ctx, params)
	return res, err
}

func (c *Client) sendListRoomRecordings(ctx context.Context, params ListRoomRecordingsParams) (res *ListRoomRecordingsResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/room_recordings"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[date_ended_at][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtEq.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_ended_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_ended_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtEq.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[room_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[room_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterRoomID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[participant_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[participant_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterParticipantID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[session_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[session_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterSessionID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[type]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsEq.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsLte.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsGte.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListRoomRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListRoomRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListTags invokes ListTags operation.
//
// Returns a list of tags used on Credentials.
//
// GET /telephony_credentials/tags
func (c *Client) ListTags(ctx context.Context, params ListTagsParams) (ListTagsRes, error) {
	res, err := c.sendListTags(ctx, params)
	return res, err
}

func (c *Client) sendListTags(ctx context.Context, params ListTagsParams) (res ListTagsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/telephony_credentials/tags"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListTags", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListUsageReportsOptions invokes ListUsageReportsOptions operation.
//
// Get the Usage Reports options for querying usage, including the products available and their
// respective metrics and dimensions.
//
// GET /usage_reports/options
func (c *Client) ListUsageReportsOptions(ctx context.Context, params ListUsageReportsOptionsParams) (ListUsageReportsOptionsRes, error) {
	res, err := c.sendListUsageReportsOptions(ctx, params)
	return res, err
}

func (c *Client) sendListUsageReportsOptions(ctx context.Context, params ListUsageReportsOptionsParams) (res ListUsageReportsOptionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/usage_reports/options"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "product" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "product",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Product.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListUsageReportsOptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListUsageReportsOptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListVerifications invokes ListVerifications operation.
//
// List verifications by phone number.
//
// GET /verifications/by_phone_number/{phone_number}
func (c *Client) ListVerifications(ctx context.Context, params ListVerificationsParams) (ListVerificationsRes, error) {
	res, err := c.sendListVerifications(ctx, params)
	return res, err
}

func (c *Client) sendListVerifications(ctx context.Context, params ListVerificationsParams) (res ListVerificationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verifications/by_phone_number/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListVerifications", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListVerificationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListVerifiedCallDisplayProfiles invokes ListVerifiedCallDisplayProfiles operation.
//
// Lists the Verified Calls Display Profiles owned by the current user/organization.
//
// GET /verified_calls_display_profiles
func (c *Client) ListVerifiedCallDisplayProfiles(ctx context.Context, params ListVerifiedCallDisplayProfilesParams) (ListVerifiedCallDisplayProfilesRes, error) {
	res, err := c.sendListVerifiedCallDisplayProfiles(ctx, params)
	return res, err
}

func (c *Client) sendListVerifiedCallDisplayProfiles(ctx context.Context, params ListVerifiedCallDisplayProfilesParams) (res ListVerifiedCallDisplayProfilesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verified_calls_display_profiles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListVerifiedCallDisplayProfiles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListVerifiedCallDisplayProfilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListVerifiedNumbers invokes ListVerifiedNumbers operation.
//
// Gets a paginated list of Verified Numbers.
//
// GET /verified_numbers
func (c *Client) ListVerifiedNumbers(ctx context.Context, params ListVerifiedNumbersParams) (ListVerifiedNumbersRes, error) {
	res, err := c.sendListVerifiedNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListVerifiedNumbers(ctx context.Context, params ListVerifiedNumbersParams) (res ListVerifiedNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verified_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListVerifiedNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListVerifiedNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NoiseSuppressionStart invokes noiseSuppressionStart operation.
//
// Noise Suppression Start (BETA).
//
// POST /calls/{call_control_id}/actions/suppression_start
func (c *Client) NoiseSuppressionStart(ctx context.Context, request *NoiseSuppressionStart, params NoiseSuppressionStartParams) (NoiseSuppressionStartRes, error) {
	res, err := c.sendNoiseSuppressionStart(ctx, request, params)
	return res, err
}

func (c *Client) sendNoiseSuppressionStart(ctx context.Context, request *NoiseSuppressionStart, params NoiseSuppressionStartParams) (res NoiseSuppressionStartRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/suppression_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNoiseSuppressionStartRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "NoiseSuppressionStart", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeNoiseSuppressionStartResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NoiseSuppressionStop invokes noiseSuppressionStop operation.
//
// Noise Suppression Stop (BETA).
//
// POST /calls/{call_control_id}/actions/suppression_stop
func (c *Client) NoiseSuppressionStop(ctx context.Context, request *NoiseSuppressionStop, params NoiseSuppressionStopParams) (NoiseSuppressionStopRes, error) {
	res, err := c.sendNoiseSuppressionStop(ctx, request, params)
	return res, err
}

func (c *Client) sendNoiseSuppressionStop(ctx context.Context, request *NoiseSuppressionStop, params NoiseSuppressionStopParams) (res NoiseSuppressionStopRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/suppression_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNoiseSuppressionStopRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "NoiseSuppressionStop", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeNoiseSuppressionStopResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PauseCallRecording invokes PauseCallRecording operation.
//
// Pause recording the call. Recording can be resumed via Resume recording command.
// **Expected Webhooks:**
// There are no webhooks associated with this command.
//
// POST /calls/{call_control_id}/actions/record_pause
func (c *Client) PauseCallRecording(ctx context.Context, request *PauseRecordingRequest, params PauseCallRecordingParams) (PauseCallRecordingRes, error) {
	res, err := c.sendPauseCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendPauseCallRecording(ctx context.Context, request *PauseRecordingRequest, params PauseCallRecordingParams) (res PauseCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/record_pause"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePauseCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "PauseCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePauseCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PerformCredentialAction invokes PerformCredentialAction operation.
//
// Perform activate or deactivate action on provided Credential. Activate action will change the
// status to active, making it possible to connect calls with the credential. Deactivate action will
// change the status to inactive, making it impossible to connect calls with the credential.
//
// POST /telephony_credentials/{id}/actions/{action}
func (c *Client) PerformCredentialAction(ctx context.Context, params PerformCredentialActionParams) (PerformCredentialActionRes, error) {
	res, err := c.sendPerformCredentialAction(ctx, params)
	return res, err
}

func (c *Client) sendPerformCredentialAction(ctx context.Context, params PerformCredentialActionParams) (res PerformCredentialActionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/"
	{
		// Encode "action" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "action",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Action)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "PerformCredentialAction", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePerformCredentialActionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReferCall invokes ReferCall operation.
//
// Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any point in the
// duration of a call.
// **Expected Webhooks:**
// - `call.refer.started`
// - `call.refer.completed`
// - `call.refer.failed`.
//
// POST /calls/{call_control_id}/actions/refer
func (c *Client) ReferCall(ctx context.Context, request *ReferRequest, params ReferCallParams) (ReferCallRes, error) {
	res, err := c.sendReferCall(ctx, request, params)
	return res, err
}

func (c *Client) sendReferCall(ctx context.Context, request *ReferRequest, params ReferCallParams) (res ReferCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/refer"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReferCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ReferCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReferCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RegisterCall invokes RegisterCall operation.
//
// Register the call before dialing to show your brand on callee's phone.
//
// POST /calls/register
func (c *Client) RegisterCall(ctx context.Context, request *RegisterCallRequest) (RegisterCallRes, error) {
	res, err := c.sendRegisterCall(ctx, request)
	return res, err
}

func (c *Client) sendRegisterCall(ctx context.Context, request *RegisterCallRequest) (res RegisterCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/calls/register"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRegisterCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RegisterCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRegisterCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RejectCall invokes RejectCall operation.
//
// Reject an incoming call.
// **Expected Webhooks:**
// - `call.hangup`.
//
// POST /calls/{call_control_id}/actions/reject
func (c *Client) RejectCall(ctx context.Context, request *RejectRequest, params RejectCallParams) (RejectCallRes, error) {
	res, err := c.sendRejectCall(ctx, request, params)
	return res, err
}

func (c *Client) sendRejectCall(ctx context.Context, request *RejectRequest, params RejectCallParams) (res RejectCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/reject"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRejectCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RejectCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRejectCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReportsCdrUsageReportsSyncGet invokes GET /reports/cdr_usage_reports/sync operation.
//
// Generate and fetch voice usage report synchronously. This endpoint will both generate and fetch
// the voice report over a specified time period. No polling is necessary but the response may take
// up to a couple of minutes.
//
// GET /reports/cdr_usage_reports/sync
func (c *Client) ReportsCdrUsageReportsSyncGet(ctx context.Context, params ReportsCdrUsageReportsSyncGetParams) (*CdrGetSyncUsageReportResponse, error) {
	res, err := c.sendReportsCdrUsageReportsSyncGet(ctx, params)
	return res, err
}

func (c *Client) sendReportsCdrUsageReportsSyncGet(ctx context.Context, params ReportsCdrUsageReportsSyncGetParams) (res *CdrGetSyncUsageReportResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/reports/cdr_usage_reports/sync"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "aggregation_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "aggregation_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.AggregationType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "product_breakdown" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "product_breakdown",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.ProductBreakdown)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "connections" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "connections",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Connections != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Connections {
						if err := func() error {
							return e.EncodeValue(conv.Float64ToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ReportsCdrUsageReportsSyncGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReportsCdrUsageReportsSyncGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ResumeCallRecording invokes ResumeCallRecording operation.
//
// Resume recording the call.
// **Expected Webhooks:**
// There are no webhooks associated with this command.
//
// POST /calls/{call_control_id}/actions/record_resume
func (c *Client) ResumeCallRecording(ctx context.Context, request *ResumeRecordingRequest, params ResumeCallRecordingParams) (ResumeCallRecordingRes, error) {
	res, err := c.sendResumeCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendResumeCallRecording(ctx context.Context, request *ResumeRecordingRequest, params ResumeCallRecordingParams) (res ResumeCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/record_resume"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeResumeCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ResumeCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeResumeCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveCallControlApplication invokes RetrieveCallControlApplication operation.
//
// Retrieves the details of an existing call control application.
//
// GET /call_control_applications/{id}
func (c *Client) RetrieveCallControlApplication(ctx context.Context, params RetrieveCallControlApplicationParams) (RetrieveCallControlApplicationRes, error) {
	res, err := c.sendRetrieveCallControlApplication(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveCallControlApplication(ctx context.Context, params RetrieveCallControlApplicationParams) (res RetrieveCallControlApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/call_control_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveCallControlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveCallControlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveCallFromQueue invokes RetrieveCallFromQueue operation.
//
// Retrieve an existing call from an existing queue.
//
// GET /queues/{queue_name}/calls/{call_control_id}
func (c *Client) RetrieveCallFromQueue(ctx context.Context, params RetrieveCallFromQueueParams) (RetrieveCallFromQueueRes, error) {
	res, err := c.sendRetrieveCallFromQueue(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveCallFromQueue(ctx context.Context, params RetrieveCallFromQueueParams) (res RetrieveCallFromQueueRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/queues/"
	{
		// Encode "queue_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueueName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveCallFromQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveCallFromQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveCallStatus invokes RetrieveCallStatus operation.
//
// Returns the status of a call (data is available 10 minutes after call ended).
//
// GET /calls/{call_control_id}
func (c *Client) RetrieveCallStatus(ctx context.Context, params RetrieveCallStatusParams) (RetrieveCallStatusRes, error) {
	res, err := c.sendRetrieveCallStatus(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveCallStatus(ctx context.Context, params RetrieveCallStatusParams) (res RetrieveCallStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveCallStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveCallStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveVerification invokes RetrieveVerification operation.
//
// Retrieve verification.
//
// GET /verifications/{verification_id}
func (c *Client) RetrieveVerification(ctx context.Context, params RetrieveVerificationParams) (RetrieveVerificationRes, error) {
	res, err := c.sendRetrieveVerification(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveVerification(ctx context.Context, params RetrieveVerificationParams) (res RetrieveVerificationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verifications/"
	{
		// Encode "verification_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "verification_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VerificationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveVerification", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveVerificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendDTMF invokes SendDTMF operation.
//
// Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.
// **Expected Webhooks:**
// There are no webhooks associated with this command.
//
// POST /calls/{call_control_id}/actions/send_dtmf
func (c *Client) SendDTMF(ctx context.Context, request *SendDTMFRequest, params SendDTMFParams) (SendDTMFRes, error) {
	res, err := c.sendSendDTMF(ctx, request, params)
	return res, err
}

func (c *Client) sendSendDTMF(ctx context.Context, request *SendDTMFRequest, params SendDTMFParams) (res SendDTMFRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/send_dtmf"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendDTMFRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "SendDTMF", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendDTMFResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpeakCall invokes SpeakCall operation.
//
// Convert text to speech and play it back on the call. If multiple speak text commands are issued
// consecutively, the audio files will be placed in a queue awaiting playback.
// **Expected Webhooks:**
// - `call.speak.started`
// - `call.speak.ended`.
//
// POST /calls/{call_control_id}/actions/speak
func (c *Client) SpeakCall(ctx context.Context, request *SpeakRequest, params SpeakCallParams) (SpeakCallRes, error) {
	res, err := c.sendSpeakCall(ctx, request, params)
	return res, err
}

func (c *Client) sendSpeakCall(ctx context.Context, request *SpeakRequest, params SpeakCallParams) (res SpeakCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/speak"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSpeakCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "SpeakCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSpeakCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallFork invokes StartCallFork operation.
//
// Call forking allows you to stream the media from a call to a specific target in realtime.
// This stream can be used to enable realtime audio analysis to support a
// variety of use cases, including fraud detection, or the creation of AI-generated audio responses.
// Requests must specify either the `target` attribute or the `rx` and `tx` attributes.
// **Expected Webhooks:**
// - `call.fork.started`
// - `call.fork.stopped`
// **Simple Telnyx RTP Encapsulation Protocol (STREP)**
// *Note: This header/encapsulation is not used when the `rx` and `tx`
// parameters have been specified; it only applies when media is forked
// using the `target` attribute.*
// If the destination for forked media is specified using the "target"
// attribute, the RTP will be encapsulated in an extra Telnyx protocol,
// which adds a 24 byte header to the RTP payload in each packet. The STREP
// header includes the Call Control `call_leg_id` for stream
// identification, along with bits that represent the direction (inbound or
// outbound) of the media. This 24-byte header sits between the UDP header
// and the RTP header.
// The STREP header makes it possible to fork RTP for multiple calls (or
// two RTP streams for the same call) to the same IP:port, where the
// streams can be demultiplexed by your application using the information
// in the header. Of course, it's still possible to ignore this header
// completely, for example, if sending forked media for different calls to
// different ports or IP addresses. In this case, simply strip 24 bytes
// (or use the second byte to find the header length) from the received UDP
// payload to get the RTP (RTP header and payload).
// ```
// STREP Specification
// 0                   1                   2                   3
// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |       reserved (4 bytes, for UDP ports or anything else)      |
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |               The call_leg_id                                 |
// |                   from Call Control                           |
// |                       (128 bits / 16 bytes)                   |
// |                           (this is binary data)               |
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 11
// Static bits 11, always set to 11 to easily distinguish forked media
// from RTP (10) and T.38 media (usually 00) and SIP (which begins
// with a capital letter, so begins with bits 01). This is a magic number.
// Version
// Four bits to indicate the version number of the protocol, starting at 0001.
// L
// One bit to represent the leg of the call (A or B).
// 0 represents the A (first) leg of the call.
// 1 represents the B (second) leg of the call.
// D
// One bit to represent the direction of this RTP stream.
// 0 represents media received by Telnyx.
// 1 represents media transmitted by Telnyx.
// HeaderLen (1 byte)
// The length of the header in bytes.
// Note that this value does not include the length of the payload. The total
// size of the RTP can be calculated by subtracting the HeaderLen from the UDP
// length (minus 8 for the UDP header).
// In version 1, this value will always be 24.
// Reserved (6 bytes)
// Reserved for future use and to make sure that the header is a multiple of 32 bits
// Call Leg ID
// A 128-bit identifier for the call leg.
// This is the call_leg_id from Call Control.
// ```.
//
// POST /calls/{call_control_id}/actions/fork_start
func (c *Client) StartCallFork(ctx context.Context, request *StartForkingRequest, params StartCallForkParams) (StartCallForkRes, error) {
	res, err := c.sendStartCallFork(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallFork(ctx context.Context, request *StartForkingRequest, params StartCallForkParams) (res StartCallForkRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/fork_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallForkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallFork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallForkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallPlayback invokes StartCallPlayback operation.
//
// Play an audio file on the call. If multiple play audio commands are issued consecutively,
// the audio files will be placed in a queue awaiting playback.
// *Notes:*
// - When `overlay` is enabled, `target_legs` is limited to `self`.
// - A customer cannot Play Audio with `overlay=true` unless there is a Play Audio with
// `overlay=false` actively playing.
// **Expected Webhooks:**
// - `call.playback.started`
// - `call.playback.ended`.
//
// POST /calls/{call_control_id}/actions/playback_start
func (c *Client) StartCallPlayback(ctx context.Context, request *PlayAudioUrlRequest, params StartCallPlaybackParams) (StartCallPlaybackRes, error) {
	res, err := c.sendStartCallPlayback(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallPlayback(ctx context.Context, request *PlayAudioUrlRequest, params StartCallPlaybackParams) (res StartCallPlaybackRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/playback_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallPlaybackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallPlayback", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallPlaybackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallRecord invokes StartCallRecord operation.
//
// Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop
// Recording command.
// **Expected Webhooks:**
// - `call.recording.saved`.
//
// POST /calls/{call_control_id}/actions/record_start
func (c *Client) StartCallRecord(ctx context.Context, request *StartRecordingRequest, params StartCallRecordParams) (StartCallRecordRes, error) {
	res, err := c.sendStartCallRecord(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallRecord(ctx context.Context, request *StartRecordingRequest, params StartCallRecordParams) (res StartCallRecordRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/record_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallRecordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallRecord", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallStreaming invokes StartCallStreaming operation.
//
// Start streaming the media from a call to a specific WebSocket address or Dialogflow connection in
// near-realtime. Audio will be delivered as base64-encoded RTP payload (raw audio), wrapped in JSON
// payloads.
// **Example: Starting a stream to a Websocket address**
// The `stream_url` param is mandatory.
// ```
// curl -X POST \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Authorization: Bearer YOUR_API_KEY" \
// --data '{
// "stream_url": "wss://www.example.com/websocket",\
// "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d",\
// "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901" \
// }' \
// https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
// ```
// **Example: Starting a stream to a Dialogflow connection**
// Enable the Dialogflow integration by sending `"enable_dialogflow": true` in the request. You need
// to have a Dialogflow connection associated with your Call Control application first, [click here
// for instructions](https://developers.telnyx.com/docs/voice/programmable-voice/dialogflow-es).
// ```
// curl -X POST \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Authorization: Bearer YOUR_API_KEY" \
// --data '{
// "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d", \
// "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901", \
// "enable_dialogflow": true \
// }' \
// https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
// ```
// **Expected Webhooks:**
// - `streaming.started`
// - `streaming.stopped`
// - `streaming.failed`
// **WebSocket events**
// When the WebSocket connection is established, the following event is being sent over it:
// ```
// {
// "event": "connected",
// "version": "1.0.0"
// }
// ```
// And when the call is started, an event which contains information about the encoding and
// `stream_id` that identifies a particular stream:
// ```
// {
// "event": "start",
// "sequence_number": "1",
// "start": {
// "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
// "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
// "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
// "media_format": {
// "encoding": "audio/x-mulaw",
// "sample_rate": 8000,
// "channels": 1
// }
// },
// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
// }
// ```
// The start event is followed by the following media events that contain base64-encoded RTP payload
// (raw audio, no RTP headers) (:
// ```
// {
// "event": "media",
// "sequence_number": "4",
// "media": {
// "track": "inbound/outbound",
// "chunk": "2",
// "timestamp": "5",
// "payload": "no+JhoaJjpzSHxAKBgYJD...IsSbjomGhoqQn1Ic"
// },
// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
// }
// ```
// Please note that the order of events is not guaranteed and the chunk number can be used to reorder
// the events.
// When the call ends, the stop event over WebSockets connection is sent:
// ```
// {
// "event": "stop",
// "sequence_number": "5",
// "stop": {
// "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
// "call_control_id": "v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQ"
// },
// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
// }
// ```
// **Bidirectional Media Streaming**
// Media can be sent back to the call through the websocket as well. This is done in a way very
// similar to the [playback_start](https://developers.telnyx.
// com/docs/api/v2/call-control/Call-Commands#callPlaybackStart)
// command, when using a base64 encoded mp3 file in the payload. Simply send a packet to the
// websocket connection as follows:
// ```
// {
// "event": "media",
// "media": {
// "payload" : <your base64 encoded mp3 file>
// }
// }
// ```
// The payload, which is a base64-encoded mp3 file, will be played on the call.
// Some limitations to be aware of:
// - Media payloads can only be submitted once per second.
// - Media _must_ be base64 encoded mp3
// **Stream Errors**
// Any errors in the media packet, including when a rate limit is reached, will result in an error
// frame being
// sent to your websocket server. The error frame will appear as follows:
// ```
// {
// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc",
// "event": "error",
// "sequence_number": "6",
// "error": {
// "title": "rate_limit_reached",
// "code": "100005",
// "detail": "Too many requests"
// }
// }
// ```
// Possible errors are as follows:
// - Error 100002: `"unknown_error"`
// - Error 100003: `"malformed_frame"`
// - Error 100004: `"invalid_media"`
// - Error 100005: `"rate_limit_reached"`.
//
// POST /calls/{call_control_id}/actions/streaming_start
func (c *Client) StartCallStreaming(ctx context.Context, request *StartStreamingRequest, params StartCallStreamingParams) (StartCallStreamingRes, error) {
	res, err := c.sendStartCallStreaming(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallStreaming(ctx context.Context, request *StartStreamingRequest, params StartCallStreamingParams) (res StartCallStreamingRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/streaming_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallStreamingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallStreaming", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallStreamingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallTranscription invokes StartCallTranscription operation.
//
// Start real-time transcription. Transcription will stop on call hang-up, or can be initiated via
// the Transcription stop command.
// **Expected Webhooks:**
// - `call.transcription`.
//
// POST /calls/{call_control_id}/actions/transcription_start
func (c *Client) StartCallTranscription(ctx context.Context, request *TranscriptionStartRequest, params StartCallTranscriptionParams) (StartCallTranscriptionRes, error) {
	res, err := c.sendStartCallTranscription(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallTranscription(ctx context.Context, request *TranscriptionStartRequest, params StartCallTranscriptionParams) (res StartCallTranscriptionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/transcription_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallTranscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartTeXMLCallRecording invokes StartTeXMLCallRecording operation.
//
// Starts recording with specified parameters for call idientified by call_sid.
//
// POST /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json
func (c *Client) StartTeXMLCallRecording(ctx context.Context, request OptTexmlCreateCallRecordingRequestBody, params StartTeXMLCallRecordingParams) (StartTeXMLCallRecordingRes, error) {
	res, err := c.sendStartTeXMLCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendStartTeXMLCallRecording(ctx context.Context, request OptTexmlCreateCallRecordingRequestBody, params StartTeXMLCallRecordingParams) (res StartTeXMLCallRecordingRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartTeXMLCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartTeXMLCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartTeXMLCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallFork invokes StopCallFork operation.
//
// Stop forking a call.
// **Expected Webhooks:**
// - `call.fork.stopped`.
//
// POST /calls/{call_control_id}/actions/fork_stop
func (c *Client) StopCallFork(ctx context.Context, request *StopForkingRequest, params StopCallForkParams) (StopCallForkRes, error) {
	res, err := c.sendStopCallFork(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallFork(ctx context.Context, request *StopForkingRequest, params StopCallForkParams) (res StopCallForkRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/fork_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallForkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallFork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallForkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallGather invokes StopCallGather operation.
//
// Stop current gather.
// **Expected Webhooks:**
// - `call.gather.ended`.
//
// POST /calls/{call_control_id}/actions/gather_stop
func (c *Client) StopCallGather(ctx context.Context, request *StopGatherRequest, params StopCallGatherParams) (StopCallGatherRes, error) {
	res, err := c.sendStopCallGather(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallGather(ctx context.Context, request *StopGatherRequest, params StopCallGatherParams) (res StopCallGatherRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/gather_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallGatherRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallGather", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallGatherResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallPlayback invokes StopCallPlayback operation.
//
// Stop audio being played on the call.
// **Expected Webhooks:**
// - `call.playback.ended` or `call.speak.ended`.
//
// POST /calls/{call_control_id}/actions/playback_stop
func (c *Client) StopCallPlayback(ctx context.Context, request *PlaybackStopRequest, params StopCallPlaybackParams) (StopCallPlaybackRes, error) {
	res, err := c.sendStopCallPlayback(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallPlayback(ctx context.Context, request *PlaybackStopRequest, params StopCallPlaybackParams) (res StopCallPlaybackRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/playback_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallPlaybackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallPlayback", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallPlaybackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallRecording invokes StopCallRecording operation.
//
// Stop recording the call.
// **Expected Webhooks:**
// - `call.recording.saved`.
//
// POST /calls/{call_control_id}/actions/record_stop
func (c *Client) StopCallRecording(ctx context.Context, request *StopRecordingRequest, params StopCallRecordingParams) (StopCallRecordingRes, error) {
	res, err := c.sendStopCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallRecording(ctx context.Context, request *StopRecordingRequest, params StopCallRecordingParams) (res StopCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/record_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallStreaming invokes StopCallStreaming operation.
//
// Stop streaming a call to a WebSocket.
// **Expected Webhooks:**
// - `streaming.stopped`.
//
// POST /calls/{call_control_id}/actions/streaming_stop
func (c *Client) StopCallStreaming(ctx context.Context, request *StopStreamingRequest, params StopCallStreamingParams) (StopCallStreamingRes, error) {
	res, err := c.sendStopCallStreaming(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallStreaming(ctx context.Context, request *StopStreamingRequest, params StopCallStreamingParams) (res StopCallStreamingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/streaming_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallStreamingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallStreaming", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallStreamingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallTranscription invokes StopCallTranscription operation.
//
// Stop real-time transcription.
//
// POST /calls/{call_control_id}/actions/transcription_stop
func (c *Client) StopCallTranscription(ctx context.Context, request *TranscriptionStopRequest, params StopCallTranscriptionParams) (StopCallTranscriptionRes, error) {
	res, err := c.sendStopCallTranscription(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallTranscription(ctx context.Context, request *TranscriptionStopRequest, params StopCallTranscriptionParams) (res StopCallTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/transcription_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallTranscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TransferCall invokes TransferCall operation.
//
// Transfer a call to a new destination. If the transfer is unsuccessful, a `call.hangup` webhook for
// the other call (Leg B) will be sent indicating that the transfer could not be completed. The
// original call will remain active and may be issued additional commands, potentially transfering
// the call to an alternate destination.
// **Expected Webhooks:**
// - `call.initiated`
// - `call.bridged` to Leg B
// - `call.answered` or `call.hangup`
// - `call.machine.detection.ended` if `answering_machine_detection` was requested
// - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end
// of machine greeting
// - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
// - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and
// a beep was detected.
//
// POST /calls/{call_control_id}/actions/transfer
func (c *Client) TransferCall(ctx context.Context, request *TransferCallRequest, params TransferCallParams) (TransferCallRes, error) {
	res, err := c.sendTransferCall(ctx, request, params)
	return res, err
}

func (c *Client) sendTransferCall(ctx context.Context, request *TransferCallRequest, params TransferCallParams) (res TransferCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/transfer"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTransferCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "TransferCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTransferCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBulkTelephonyCredential invokes UpdateBulkTelephonyCredential operation.
//
// Update several credentials in bulk.
//
// PATCH /actions/bulk/telephony_credentials
func (c *Client) UpdateBulkTelephonyCredential(ctx context.Context, request *BulkCredentialRequest, params UpdateBulkTelephonyCredentialParams) (UpdateBulkTelephonyCredentialRes, error) {
	res, err := c.sendUpdateBulkTelephonyCredential(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateBulkTelephonyCredential(ctx context.Context, request *BulkCredentialRequest, params UpdateBulkTelephonyCredentialParams) (res UpdateBulkTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/actions/bulk/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilterTag))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBulkTelephonyCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateBulkTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBulkTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCallControlApplication invokes UpdateCallControlApplication operation.
//
// Updates settings of an existing call control application.
//
// PATCH /call_control_applications/{id}
func (c *Client) UpdateCallControlApplication(ctx context.Context, request *UpdateCallControlApplicationRequest, params UpdateCallControlApplicationParams) (UpdateCallControlApplicationRes, error) {
	res, err := c.sendUpdateCallControlApplication(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCallControlApplication(ctx context.Context, request *UpdateCallControlApplicationRequest, params UpdateCallControlApplicationParams) (res UpdateCallControlApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/call_control_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCallControlApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateCallControlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateCallControlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateClientState invokes UpdateClientState operation.
//
// Updates client state.
//
// PUT /calls/{call_control_id}/actions/client_state_update
func (c *Client) UpdateClientState(ctx context.Context, request *ClientStateUpdateRequest, params UpdateClientStateParams) (UpdateClientStateRes, error) {
	res, err := c.sendUpdateClientState(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateClientState(ctx context.Context, request *ClientStateUpdateRequest, params UpdateClientStateParams) (res UpdateClientStateRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/client_state_update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateClientStateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateClientState", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateClientStateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCustomStorageCredentials invokes UpdateCustomStorageCredentials operation.
//
// Updates a stored custom credentials configuration.
//
// PUT /custom_storage_credentials/{connection_id}
func (c *Client) UpdateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params UpdateCustomStorageCredentialsParams) (UpdateCustomStorageCredentialsRes, error) {
	res, err := c.sendUpdateCustomStorageCredentials(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params UpdateCustomStorageCredentialsParams) (res UpdateCustomStorageCredentialsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/custom_storage_credentials/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCustomStorageCredentialsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateCustomStorageCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateCustomStorageCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateProfile invokes UpdateProfile operation.
//
// Update an existing Verified Calls Display Profile and allows adding/removing nested Call Reasons
// and Phone Numbers. Different attributes can be updated depending on the Verified Calls Display
// Profile's status: For the VERIFICATION_STATE_PENDING status, no fields can be updated. For the
// VERIFICATION_STATE_VERIFIED status, it is allowed only to add/remove Call Reaons and Phone Numbers.
//
//	For the other statuses, all fields can be updated. All existing Call Reasons and Phone Numbers
//
// must be sent during the request, or the update will fail.
//
// PATCH /verified_calls_display_profiles/{id}
func (c *Client) UpdateProfile(ctx context.Context, request *UpdateVerifiedCallsDisplayProfileRequest, params UpdateProfileParams) (UpdateProfileRes, error) {
	res, err := c.sendUpdateProfile(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateProfile(ctx context.Context, request *UpdateVerifiedCallsDisplayProfileRequest, params UpdateProfileParams) (res UpdateProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_calls_display_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTeXMLCallRecording invokes UpdateTeXMLCallRecording operation.
//
// Updates recording resource for particular call.
//
// POST /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings/{recording_sid}.json
func (c *Client) UpdateTeXMLCallRecording(ctx context.Context, request OptTexmlUpdateCallRecordingRequestBody, params UpdateTeXMLCallRecordingParams) (UpdateTeXMLCallRecordingRes, error) {
	res, err := c.sendUpdateTeXMLCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTeXMLCallRecording(ctx context.Context, request OptTexmlUpdateCallRecordingRequestBody, params UpdateTeXMLCallRecordingParams) (res UpdateTeXMLCallRecordingRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings/"
	{
		// Encode "recording_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTeXMLCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTeXMLCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTeXMLCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTelephonyCredential invokes UpdateTelephonyCredential operation.
//
// Update an existing credential.
//
// PATCH /telephony_credentials/{id}
func (c *Client) UpdateTelephonyCredential(ctx context.Context, request *TelephonyCredentialUpdateRequest, params UpdateTelephonyCredentialParams) (UpdateTelephonyCredentialRes, error) {
	res, err := c.sendUpdateTelephonyCredential(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTelephonyCredential(ctx context.Context, request *TelephonyCredentialUpdateRequest, params UpdateTelephonyCredentialParams) (res UpdateTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTelephonyCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlApplication invokes UpdateTexmlApplication operation.
//
// Updates settings of an existing TeXML Application.
//
// PATCH /texml_applications/{id}
func (c *Client) UpdateTexmlApplication(ctx context.Context, request *UpdateTexmlApplicationRequest, params UpdateTexmlApplicationParams) (UpdateTexmlApplicationRes, error) {
	res, err := c.sendUpdateTexmlApplication(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlApplication(ctx context.Context, request *UpdateTexmlApplicationRequest, params UpdateTexmlApplicationParams) (res UpdateTexmlApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/texml_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlCall invokes UpdateTexmlCall operation.
//
// Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase
// as specified in the example.
//
// POST /texml/calls/{call_sid}/update
func (c *Client) UpdateTexmlCall(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallParams) (*UpdateTeXMLCallResponse, error) {
	res, err := c.sendUpdateTexmlCall(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlCall(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallParams) (res *UpdateTeXMLCallResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlCallByAccount invokes UpdateTexmlCallByAccount operation.
//
// Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase
// as specified in the example.
//
// POST /texml/Accounts/{account_sid}/Calls/{call_sid}
func (c *Client) UpdateTexmlCallByAccount(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallByAccountParams) (*GetCallResponse, error) {
	res, err := c.sendUpdateTexmlCallByAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlCallByAccount(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallByAccountParams) (res *GetCallResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlCallByAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlCallByAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlCallByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlConference invokes UpdateTexmlConference operation.
//
// Updates a conference resource.
//
// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}
func (c *Client) UpdateTexmlConference(ctx context.Context, request *UpdateConferenceRequest, params UpdateTexmlConferenceParams) (UpdateTexmlConferenceRes, error) {
	res, err := c.sendUpdateTexmlConference(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlConference(ctx context.Context, request *UpdateConferenceRequest, params UpdateTexmlConferenceParams) (res UpdateTexmlConferenceRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlConferenceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlConference", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlConferenceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlConferenceParticipant invokes UpdateTexmlConferenceParticipant operation.
//
// Updates a conference participant.
//
// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
func (c *Client) UpdateTexmlConferenceParticipant(ctx context.Context, request *UpdateConferenceParticipantRequest, params UpdateTexmlConferenceParticipantParams) (UpdateTexmlConferenceParticipantRes, error) {
	res, err := c.sendUpdateTexmlConferenceParticipant(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlConferenceParticipant(ctx context.Context, request *UpdateConferenceParticipantRequest, params UpdateTexmlConferenceParticipantParams) (res UpdateTexmlConferenceParticipantRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlConferenceParticipantRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlConferenceParticipant", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlConferenceParticipantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVerifyProfile invokes UpdateVerifyProfile operation.
//
// Update Verify profile.
//
// PATCH /verify_profiles/{verify_profile_id}
func (c *Client) UpdateVerifyProfile(ctx context.Context, request *UpdateVerifyProfileReq, params UpdateVerifyProfileParams) (UpdateVerifyProfileRes, error) {
	res, err := c.sendUpdateVerifyProfile(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVerifyProfile(ctx context.Context, request *UpdateVerifyProfileReq, params UpdateVerifyProfileParams) (res UpdateVerifyProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verify_profiles/"
	{
		// Encode "verify_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "verify_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VerifyProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVerifyProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateVerifyProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVerifyProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VerifyVerificationCode invokes VerifyVerificationCode operation.
//
// Submit verification code.
//
// POST /verified_numbers/{phone_number}/actions/verify
func (c *Client) VerifyVerificationCode(ctx context.Context, request *VerifyVerificationCodeReq, params VerifyVerificationCodeParams) (VerifyVerificationCodeRes, error) {
	res, err := c.sendVerifyVerificationCode(ctx, request, params)
	return res, err
}

func (c *Client) sendVerifyVerificationCode(ctx context.Context, request *VerifyVerificationCodeReq, params VerifyVerificationCodeParams) (res VerifyVerificationCodeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/verified_numbers/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/verify"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeVerifyVerificationCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "VerifyVerificationCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVerifyVerificationCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VerifyVerificationCodeByPhoneNumber invokes VerifyVerificationCodeByPhoneNumber operation.
//
// Submit verification code.
//
// POST /verifications/by_phone_number/{phone_number}/actions/verify
func (c *Client) VerifyVerificationCodeByPhoneNumber(ctx context.Context, request *VerifyVerificationCodeRequest, params VerifyVerificationCodeByPhoneNumberParams) (VerifyVerificationCodeByPhoneNumberRes, error) {
	res, err := c.sendVerifyVerificationCodeByPhoneNumber(ctx, request, params)
	return res, err
}

func (c *Client) sendVerifyVerificationCodeByPhoneNumber(ctx context.Context, request *VerifyVerificationCodeRequest, params VerifyVerificationCodeByPhoneNumberParams) (res VerifyVerificationCodeByPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/verifications/by_phone_number/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/verify"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeVerifyVerificationCodeByPhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "VerifyVerificationCodeByPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVerifyVerificationCodeByPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ViewRoomRecording invokes ViewRoomRecording operation.
//
// View a room recording.
//
// GET /room_recordings/{room_recording_id}
func (c *Client) ViewRoomRecording(ctx context.Context, params ViewRoomRecordingParams) (ViewRoomRecordingRes, error) {
	res, err := c.sendViewRoomRecording(ctx, params)
	return res, err
}

func (c *Client) sendViewRoomRecording(ctx context.Context, params ViewRoomRecordingParams) (res ViewRoomRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/room_recordings/"
	{
		// Encode "room_recording_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "room_recording_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RoomRecordingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ViewRoomRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeViewRoomRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
