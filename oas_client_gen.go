// Code generated by ogen, DO NOT EDIT.

package telnyx

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AnswerCall invokes AnswerCall operation.
	//
	// Answer an incoming call. You must issue this command before executing subsequent commands on an
	// incoming call.
	// **Expected Webhooks:**
	// - `call.answered`
	// - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set.
	//
	// POST /calls/{call_control_id}/actions/answer
	AnswerCall(ctx context.Context, request *AnswerRequest, params AnswerCallParams) (AnswerCallRes, error)
	// AssignPhoneNumber invokes AssignPhoneNumber operation.
	//
	// You should own the phone number being assigned to the channel zone. Remember that you should
	// reserve channels in this channel zone, otherwise you won't be able to receive incoming calls.
	//
	// POST /channel_zones/{channel_zone_id}/channel_zone_phone_numbers
	AssignPhoneNumber(ctx context.Context, request *AssignPhoneNumberReq, params AssignPhoneNumberParams) (AssignPhoneNumberRes, error)
	// AudioPublicAudioTranscriptionsPost invokes audio_public_audio_transcriptions_post operation.
	//
	// Transcribe speech to text. This endpoint is consistent with the [OpenAI Transcription
	// API](https://platform.openai.com/docs/api-reference/audio/createTranscription) and may be used
	// with the OpenAI JS or Python SDK.
	//
	// POST /ai/audio/transcriptions
	AudioPublicAudioTranscriptionsPost(ctx context.Context, request *AudioTranscriptionRequestMultipart) (AudioPublicAudioTranscriptionsPostRes, error)
	// BridgeCall invokes BridgeCall operation.
	//
	// Bridge two call control calls.
	// **Expected Webhooks:**
	// - `call.bridged` for Leg A
	// - `call.bridged` for Leg B.
	//
	// POST /calls/{call_control_id}/actions/bridge
	BridgeCall(ctx context.Context, request *BridgeRequest, params BridgeCallParams) (BridgeCallRes, error)
	// BulkCredentialAction invokes BulkCredentialAction operation.
	//
	// Perform activate or deactivate action on all credentials filtered by the provided tag. Activate
	// action will change the status to active, making it possible to connect calls with the credential.
	// Deactivate action will change the status to inactive, making it impossible to connect calls with
	// the credential.
	//
	// POST /actions/{action}/telephony_credentials
	BulkCredentialAction(ctx context.Context, params BulkCredentialActionParams) (BulkCredentialActionRes, error)
	// CreateBulkTelephonyCredentials invokes CreateBulkTelephonyCredentials operation.
	//
	// Creates several credentials in bulk.
	//
	// POST /actions/bulk/telephony_credentials
	CreateBulkTelephonyCredentials(ctx context.Context, request *BulkCredentialRequest) (CreateBulkTelephonyCredentialsRes, error)
	// CreateCallControlApplication invokes CreateCallControlApplication operation.
	//
	// Create a call control application.
	//
	// POST /call_control_applications
	CreateCallControlApplication(ctx context.Context, request *CreateCallControlApplicationRequest) (CreateCallControlApplicationRes, error)
	// CreateCsvDownload invokes CreateCsvDownload operation.
	//
	// Create a CSV download.
	//
	// POST /phone_numbers/csv_downloads
	CreateCsvDownload(ctx context.Context) (CreateCsvDownloadRes, error)
	// CreateCustomStorageCredentials invokes CreateCustomStorageCredentials operation.
	//
	// Creates a custom storage credentials configuration.
	//
	// POST /custom_storage_credentials/{connection_id}
	CreateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params CreateCustomStorageCredentialsParams) (CreateCustomStorageCredentialsRes, error)
	// CreateDefaultGateway invokes CreateDefaultGateway operation.
	//
	// Create Default Gateway.
	//
	// POST /networks/{id}/default_gateway
	CreateDefaultGateway(ctx context.Context, request *DefaultGateway, params CreateDefaultGatewayParams) (CreateDefaultGatewayRes, error)
	// CreateDeletePhoneNumbersJob invokes CreateDeletePhoneNumbersJob operation.
	//
	// Creates a new background job to delete a batch of numbers. At most one thousand numbers can be
	// updated per API call.
	//
	// POST /phone_numbers/jobs/delete_phone_numbers
	CreateDeletePhoneNumbersJob(ctx context.Context, request *PhoneNumbersJobDeletePhoneNumbersRequest) (CreateDeletePhoneNumbersJobRes, error)
	// CreateFlashcallVerification invokes CreateFlashcallVerification operation.
	//
	// Trigger Flash call verification.
	//
	// POST /verifications/flashcall
	CreateFlashcallVerification(ctx context.Context, request *CreateVerificationRequestFlashcall) (CreateFlashcallVerificationRes, error)
	// CreateGroupMmsMessage invokes CreateGroupMmsMessage operation.
	//
	// Send a group MMS message.
	//
	// POST /messages/group_mms
	CreateGroupMmsMessage(ctx context.Context, request OptCreateGroupMMSMessageRequest) (CreateGroupMmsMessageRes, error)
	// CreateLongCodeMessage invokes CreateLongCodeMessage operation.
	//
	// Send a long code message.
	//
	// POST /messages/long_code
	CreateLongCodeMessage(ctx context.Context, request OptCreateLongCodeMessageRequest) (CreateLongCodeMessageRes, error)
	// CreateMessagingHostedNumberOrder invokes CreateMessagingHostedNumberOrder operation.
	//
	// Create a messaging hosted number order.
	//
	// POST /messaging_hosted_number_orders
	CreateMessagingHostedNumberOrder(ctx context.Context, request OptCreateMessagingHostedNumberOrderRequest) (CreateMessagingHostedNumberOrderRes, error)
	// CreateNetwork invokes CreateNetwork operation.
	//
	// Create a new Network.
	//
	// POST /networks
	CreateNetwork(ctx context.Context, request *NetworkCreate) (CreateNetworkRes, error)
	// CreateNotificationChannels invokes CreateNotificationChannels operation.
	//
	// Create a notification channel.
	//
	// POST /notification_channels
	CreateNotificationChannels(ctx context.Context, request OptNotificationChannel) (CreateNotificationChannelsRes, error)
	// CreateNumberPoolMessage invokes CreateNumberPoolMessage operation.
	//
	// Send a message using number pool.
	//
	// POST /messages/number_pool
	CreateNumberPoolMessage(ctx context.Context, request OptCreateNumberPoolMessageRequest) (CreateNumberPoolMessageRes, error)
	// CreatePhoneNumbersJobUpdateEmergencySettings invokes CreatePhoneNumbersJobUpdateEmergencySettings operation.
	//
	// Creates a background job to update the emergency settings of a collection of phone numbers. At
	// most one thousand numbers can be updated per API call.
	//
	// POST /phone_numbers/jobs/update_emergency_settings
	CreatePhoneNumbersJobUpdateEmergencySettings(ctx context.Context, request *PhoneNumbersJobUpdateEmergencySettingsRequest) (CreatePhoneNumbersJobUpdateEmergencySettingsRes, error)
	// CreateProfile invokes CreateProfile operation.
	//
	// Creates a Verified Calls Display Profile associated with the given Business Identity.
	//
	// POST /verified_calls_display_profiles
	CreateProfile(ctx context.Context, request *CreateVerifiedCallsDisplayProfileRequest) (CreateProfileRes, error)
	// CreateProfileVerificationRequest invokes CreateProfileVerificationRequest operation.
	//
	// Starts a new Verified Calls Display Profile verification process.
	//
	// POST /verified_calls_display_profiles/{id}/verification_request
	CreateProfileVerificationRequest(ctx context.Context, params CreateProfileVerificationRequestParams) (CreateProfileVerificationRequestRes, error)
	// CreateShortCodeMessage invokes CreateShortCodeMessage operation.
	//
	// Send a short code message.
	//
	// POST /messages/short_code
	CreateShortCodeMessage(ctx context.Context, request OptCreateShortCodeMessageRequest) (CreateShortCodeMessageRes, error)
	// CreateTelephonyCredential invokes CreateTelephonyCredential operation.
	//
	// Create a credential.
	//
	// POST /telephony_credentials
	CreateTelephonyCredential(ctx context.Context, request *TelephonyCredentialCreateRequest) (CreateTelephonyCredentialRes, error)
	// CreateTelephonyCredentialToken invokes CreateTelephonyCredentialToken operation.
	//
	// Create an Access Token (JWT) for the credential.
	//
	// POST /telephony_credentials/{id}/token
	CreateTelephonyCredentialToken(ctx context.Context, params CreateTelephonyCredentialTokenParams) (CreateTelephonyCredentialTokenRes, error)
	// CreateTexmlApplication invokes CreateTexmlApplication operation.
	//
	// Creates a TeXML Application.
	//
	// POST /texml_applications
	CreateTexmlApplication(ctx context.Context, request *CreateTexmlApplicationRequest) (CreateTexmlApplicationRes, error)
	// CreateTexmlSecret invokes CreateTexmlSecret operation.
	//
	// Create a TeXML secret which can be later used as a Dynamic Parameter for TeXML when using Mustache
	// Templates in your TeXML. In your TeXML you will be able to use your secret name, and this name
	// will be replaced by the actual secret value when processing the TeXML on Telnyx side.  The secrets
	// are not visible in any logs.
	//
	// POST /texml/secrets
	CreateTexmlSecret(ctx context.Context, request *CreateTeXMLSecretRequest) (CreateTexmlSecretRes, error)
	// CreateUpdatePhoneNumbersJob invokes CreateUpdatePhoneNumbersJob operation.
	//
	// Creates a new background job to update a batch of numbers. At most one thousand numbers can be
	// updated per API call. At least one of the updateable fields must be submitted.
	//
	// POST /phone_numbers/jobs/update_phone_numbers
	CreateUpdatePhoneNumbersJob(ctx context.Context, request *PhoneNumbersJobUpdatePhoneNumbersRequest) (CreateUpdatePhoneNumbersJobRes, error)
	// CreateVerificationCall invokes CreateVerificationCall operation.
	//
	// Trigger Call verification.
	//
	// POST /verifications/call
	CreateVerificationCall(ctx context.Context, request *CreateVerificationRequestCall) (CreateVerificationCallRes, error)
	// CreateVerificationSms invokes CreateVerificationSms operation.
	//
	// Trigger SMS verification.
	//
	// POST /verifications/sms
	CreateVerificationSms(ctx context.Context, request *CreateVerificationRequestSMS) (CreateVerificationSmsRes, error)
	// CreateVerifiedNumber invokes CreateVerifiedNumber operation.
	//
	// Initiates phone number verification procedure.
	//
	// POST /verified_numbers
	CreateVerifiedNumber(ctx context.Context, request *CreateVerifiedNumberReq) (CreateVerifiedNumberRes, error)
	// CreateVerifyProfile invokes CreateVerifyProfile operation.
	//
	// Creates a new Verify profile to associate verifications with.
	//
	// POST /verify_profiles
	CreateVerifyProfile(ctx context.Context, request *CreateVerifyProfileReq) (CreateVerifyProfileRes, error)
	// DeleteCallControlApplication invokes DeleteCallControlApplication operation.
	//
	// Deletes a call control application.
	//
	// DELETE /call_control_applications/{id}
	DeleteCallControlApplication(ctx context.Context, params DeleteCallControlApplicationParams) (DeleteCallControlApplicationRes, error)
	// DeleteCustomStorageCredentials invokes DeleteCustomStorageCredentials operation.
	//
	// Deletes a stored custom credentials configuration.
	//
	// DELETE /custom_storage_credentials/{connection_id}
	DeleteCustomStorageCredentials(ctx context.Context, params DeleteCustomStorageCredentialsParams) (DeleteCustomStorageCredentialsRes, error)
	// DeleteDefaultGateway invokes DeleteDefaultGateway operation.
	//
	// Delete Default Gateway.
	//
	// DELETE /networks/{id}/default_gateway
	DeleteDefaultGateway(ctx context.Context, params DeleteDefaultGatewayParams) (DeleteDefaultGatewayRes, error)
	// DeleteExternalConnectionLogMessage invokes DeleteExternalConnectionLogMessage operation.
	//
	// Dismiss a log message for an external connection associated with your account.
	//
	// DELETE /external_connections/log_messages/{id}
	DeleteExternalConnectionLogMessage(ctx context.Context, params DeleteExternalConnectionLogMessageParams) (DeleteExternalConnectionLogMessageRes, error)
	// DeleteNetwork invokes DeleteNetwork operation.
	//
	// Delete a Network.
	//
	// DELETE /networks/{id}
	DeleteNetwork(ctx context.Context, params DeleteNetworkParams) (DeleteNetworkRes, error)
	// DeleteNotificationChannel invokes DeleteNotificationChannel operation.
	//
	// Delete a notification channel.
	//
	// DELETE /notification_channels/{id}
	DeleteNotificationChannel(ctx context.Context, params DeleteNotificationChannelParams) (DeleteNotificationChannelRes, error)
	// DeletePhoneNumber invokes DeletePhoneNumber operation.
	//
	// Delete a phone number.
	//
	// DELETE /phone_numbers/{id}
	DeletePhoneNumber(ctx context.Context, params DeletePhoneNumberParams) (DeletePhoneNumberRes, error)
	// DeleteProfile invokes DeleteProfile operation.
	//
	// Delete Verify profile.
	//
	// DELETE /verify_profiles/{verify_profile_id}
	DeleteProfile(ctx context.Context, params DeleteProfileParams) (DeleteProfileRes, error)
	// DeleteRecording invokes DeleteRecording operation.
	//
	// Permanently deletes a call recording.
	//
	// DELETE /recordings/{recording_id}
	DeleteRecording(ctx context.Context, params DeleteRecordingParams) (DeleteRecordingRes, error)
	// DeleteRecordingTranscription invokes deleteRecordingTranscription operation.
	//
	// Permanently deletes a recording transcription.
	//
	// DELETE /recording_transcriptions/{recording_transcription_id}
	DeleteRecordingTranscription(ctx context.Context, params DeleteRecordingTranscriptionParams) (DeleteRecordingTranscriptionRes, error)
	// DeleteRecordings invokes DeleteRecordings operation.
	//
	// Permanently deletes a list of call recordings.
	//
	// DELETE /recordings/actions/delete
	DeleteRecordings(ctx context.Context, request []string) (DeleteRecordingsRes, error)
	// DeleteRoomRecording invokes DeleteRoomRecording operation.
	//
	// Synchronously delete a Room Recording.
	//
	// DELETE /room_recordings/{room_recording_id}
	DeleteRoomRecording(ctx context.Context, params DeleteRoomRecordingParams) (DeleteRoomRecordingRes, error)
	// DeleteRoomRecordings invokes DeleteRoomRecordings operation.
	//
	// Delete several room recordings in a bulk.
	//
	// DELETE /room_recordings
	DeleteRoomRecordings(ctx context.Context, params DeleteRoomRecordingsParams) (DeleteRoomRecordingsRes, error)
	// DeleteTeXMLCallRecording invokes DeleteTeXMLCallRecording operation.
	//
	// Deletes recording resource identified by recording id.
	//
	// DELETE /texml/Accounts/{account_sid}/Recordings/{recording_sid}.json
	DeleteTeXMLCallRecording(ctx context.Context, params DeleteTeXMLCallRecordingParams) (DeleteTeXMLCallRecordingRes, error)
	// DeleteTeXMLRecordingTranscription invokes DeleteTeXMLRecordingTranscription operation.
	//
	// Permanently deletes a recording transcription.
	//
	// DELETE /texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json
	DeleteTeXMLRecordingTranscription(ctx context.Context, params DeleteTeXMLRecordingTranscriptionParams) (DeleteTeXMLRecordingTranscriptionRes, error)
	// DeleteTelephonyCredential invokes DeleteTelephonyCredential operation.
	//
	// Delete an existing credential.
	//
	// DELETE /telephony_credentials/{id}
	DeleteTelephonyCredential(ctx context.Context, params DeleteTelephonyCredentialParams) (DeleteTelephonyCredentialRes, error)
	// DeleteTelephonyCredentials invokes DeleteTelephonyCredentials operation.
	//
	// Delete several credentials in bulk.
	//
	// DELETE /actions/bulk/telephony_credentials
	DeleteTelephonyCredentials(ctx context.Context, params DeleteTelephonyCredentialsParams) (DeleteTelephonyCredentialsRes, error)
	// DeleteTexmlApplication invokes DeleteTexmlApplication operation.
	//
	// Deletes a TeXML Application.
	//
	// DELETE /texml_applications/{id}
	DeleteTexmlApplication(ctx context.Context, params DeleteTexmlApplicationParams) (DeleteTexmlApplicationRes, error)
	// DeleteTexmlConferenceParticipant invokes DeleteTexmlConferenceParticipant operation.
	//
	// Deletes a conference participant.
	//
	// DELETE /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
	DeleteTexmlConferenceParticipant(ctx context.Context, params DeleteTexmlConferenceParticipantParams) (DeleteTexmlConferenceParticipantRes, error)
	// DeleteVerifiedCallDisplayProfile invokes DeleteVerifiedCallDisplayProfile operation.
	//
	// Deletes the Verified Calls Display Profile. This action will fail if any verification requests
	// have been made for this Verified Calls Display Profile. Please contact support@telnyx.com in case
	// you want to delete a Verified Calls Display Profile in that situation.
	//
	// DELETE /verified_calls_display_profiles/{id}
	DeleteVerifiedCallDisplayProfile(ctx context.Context, params DeleteVerifiedCallDisplayProfileParams) (DeleteVerifiedCallDisplayProfileRes, error)
	// DeleteVerifiedNumber invokes DeleteVerifiedNumber operation.
	//
	// Delete a verified number.
	//
	// DELETE /verified_numbers/{phone_number}
	DeleteVerifiedNumber(ctx context.Context, params DeleteVerifiedNumberParams) (DeleteVerifiedNumberRes, error)
	// DialCall invokes DialCall operation.
	//
	// Dial a number or SIP URI from a given connection. A successful response will include a
	// `call_leg_id` which can be used to correlate the command with subsequent webhooks.
	// **Expected Webhooks:**
	// - `call.initiated`
	// - `call.answered` or `call.hangup`
	// - `call.machine.detection.ended` if `answering_machine_detection` was requested
	// - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end
	// of machine greeting
	// - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
	// - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and
	// a beep was detected
	// - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set.
	//
	// POST /calls
	DialCall(ctx context.Context, request *CallRequest) (DialCallRes, error)
	// DialTexmlConferenceParticipant invokes DialTexmlConferenceParticipant operation.
	//
	// Dials a new conference participant.
	//
	// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants
	DialTexmlConferenceParticipant(ctx context.Context, request *DialConferenceParticipantRequest, params DialTexmlConferenceParticipantParams) (DialTexmlConferenceParticipantRes, error)
	// DisplayProfile invokes DisplayProfile operation.
	//
	// Display the Verified Calls Display Profile.
	//
	// GET /verified_calls_display_profiles/{id}
	DisplayProfile(ctx context.Context, params DisplayProfileParams) (DisplayProfileRes, error)
	// EnablePhoneNumberEmergency invokes EnablePhoneNumberEmergency operation.
	//
	// Enable emergency for a phone number.
	//
	// POST /phone_numbers/{id}/actions/enable_emergency
	EnablePhoneNumberEmergency(ctx context.Context, request *PhoneNumberEnableEmergencyRequest, params EnablePhoneNumberEmergencyParams) (EnablePhoneNumberEmergencyRes, error)
	// EnqueueCall invokes EnqueueCall operation.
	//
	// Put the call in a queue.
	//
	// POST /calls/{call_control_id}/actions/enqueue
	EnqueueCall(ctx context.Context, request *EnqueueRequest, params EnqueueCallParams) (EnqueueCallRes, error)
	// FetchTeXMLCallRecordings invokes FetchTeXMLCallRecordings operation.
	//
	// Returns recordings for a call identified by call_sid.
	//
	// GET /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json
	FetchTeXMLCallRecordings(ctx context.Context, params FetchTeXMLCallRecordingsParams) (FetchTeXMLCallRecordingsRes, error)
	// FetchTeXMLConferenceRecordings invokes FetchTeXMLConferenceRecordings operation.
	//
	// Returns recordings for a conference identified by conference_sid.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings.json
	FetchTeXMLConferenceRecordings(ctx context.Context, params FetchTeXMLConferenceRecordingsParams) (FetchTeXMLConferenceRecordingsRes, error)
	// FindPortoutComments invokes FindPortoutComments operation.
	//
	// Returns a list of comments for a portout request.
	//
	// GET /portouts/{id}/comments
	FindPortoutComments(ctx context.Context, params FindPortoutCommentsParams) (FindPortoutCommentsRes, error)
	// FindPortoutRequest invokes FindPortoutRequest operation.
	//
	// Returns the portout request based on the ID provided.
	//
	// GET /portouts/{id}
	FindPortoutRequest(ctx context.Context, params FindPortoutRequestParams) (FindPortoutRequestRes, error)
	// FindTelephonyCredentials invokes FindTelephonyCredentials operation.
	//
	// List all On-demand Credentials.
	//
	// GET /telephony_credentials
	FindTelephonyCredentials(ctx context.Context, params FindTelephonyCredentialsParams) (FindTelephonyCredentialsRes, error)
	// FindTexmlApplications invokes FindTexmlApplications operation.
	//
	// Returns a list of your TeXML Applications.
	//
	// GET /texml_applications
	FindTexmlApplications(ctx context.Context, params FindTexmlApplicationsParams) (FindTexmlApplicationsRes, error)
	// GatherCall invokes GatherCall operation.
	//
	// Gather DTMF signals to build interactive menus.
	// You can pass a list of valid digits. The `Answer` command must be issued before the `gather`
	// command.
	// **Expected Webhooks:**
	// - `call.dtmf.received` (you may receive many of these webhooks)
	// - `call.gather.ended`.
	//
	// POST /calls/{call_control_id}/actions/gather
	GatherCall(ctx context.Context, request *GatherRequest, params GatherCallParams) (GatherCallRes, error)
	// GatherUsingAudio invokes GatherUsingAudio operation.
	//
	// Play an audio file on the call until the required DTMF signals are gathered to build interactive
	// menus.
	// You can pass a list of valid digits along with an 'invalid_audio_url', which will be played back
	// at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The
	// `Answer command must be issued before the `gather_using_audio` command.
	// **Expected Webhooks:**
	// - `call.playback.started`
	// - `call.playback.ended`
	// - `call.dtmf.received` (you may receive many of these webhooks)
	// - `call.gather.ended`.
	//
	// POST /calls/{call_control_id}/actions/gather_using_audio
	GatherUsingAudio(ctx context.Context, request *GatherUsingAudioRequest, params GatherUsingAudioParams) (GatherUsingAudioRes, error)
	// GatherUsingSpeak invokes GatherUsingSpeak operation.
	//
	// Convert text to speech and play it on the call until the required DTMF signals are gathered to
	// build interactive menus.
	// You can pass a list of valid digits along with an 'invalid_payload', which will be played back at
	// the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The
	// `Answer` command must be issued before the `gather_using_speak` command.
	// **Expected Webhooks:**
	// - `call.dtmf.received` (you may receive many of these webhooks)
	// - `call.gather.ended`.
	//
	// POST /calls/{call_control_id}/actions/gather_using_speak
	GatherUsingSpeak(ctx context.Context, request *GatherUsingSpeakRequest, params GatherUsingSpeakParams) (GatherUsingSpeakRes, error)
	// GetCsvDownload invokes GetCsvDownload operation.
	//
	// Retrieve a CSV download.
	//
	// GET /phone_numbers/csv_downloads/{id}
	GetCsvDownload(ctx context.Context, params GetCsvDownloadParams) (GetCsvDownloadRes, error)
	// GetCustomStorageCredentials invokes GetCustomStorageCredentials operation.
	//
	// Returns the information about custom storage credentials.
	//
	// GET /custom_storage_credentials/{connection_id}
	GetCustomStorageCredentials(ctx context.Context, params GetCustomStorageCredentialsParams) (GetCustomStorageCredentialsRes, error)
	// GetDefaultGateway invokes GetDefaultGateway operation.
	//
	// Get Default Gateway status.
	//
	// GET /networks/{id}/default_gateway
	GetDefaultGateway(ctx context.Context, params GetDefaultGatewayParams) (GetDefaultGatewayRes, error)
	// GetExternalConnectionLogMessage invokes GetExternalConnectionLogMessage operation.
	//
	// Retrieve a log message for an external connection associated with your account.
	//
	// GET /external_connections/log_messages/{id}
	GetExternalConnectionLogMessage(ctx context.Context, params GetExternalConnectionLogMessageParams) (GetExternalConnectionLogMessageRes, error)
	// GetExternalConnectionPhoneNumber invokes GetExternalConnectionPhoneNumber operation.
	//
	// Return the details of a phone number associated with the given external connection.
	//
	// GET /external_connections/{id}/phone_numbers/{phone_number_id}
	GetExternalConnectionPhoneNumber(ctx context.Context, params GetExternalConnectionPhoneNumberParams) (GetExternalConnectionPhoneNumberRes, error)
	// GetMessage invokes GetMessage operation.
	//
	// Note: This API endpoint can only retrieve messages that are no older than 10 days since their
	// creation. If you require messages older than this, please generate an [MDR report.
	// ](https://developers.telnyx.com/docs/api/v1/reports/MDR-Reports).
	//
	// GET /messages/{id}
	GetMessage(ctx context.Context, params GetMessageParams) (GetMessageRes, error)
	// GetMessagingHostedNumberOrder invokes GetMessagingHostedNumberOrder operation.
	//
	// Retrieve a messaging hosted number order.
	//
	// GET /messaging_hosted_number_orders/{id}
	GetMessagingHostedNumberOrder(ctx context.Context, params GetMessagingHostedNumberOrderParams) (GetMessagingHostedNumberOrderRes, error)
	// GetMobileNetworkOperators invokes GetMobileNetworkOperators operation.
	//
	// Telnyx has a set of GSM mobile operators partners that are available through our mobile network
	// roaming. This resource is entirely managed by Telnyx and may change over time. That means that
	// this resource won't allow any write operations for it. Still, it's available so it can be used as
	// a support resource that can be related to other resources or become a configuration option.
	//
	// GET /mobile_network_operators
	GetMobileNetworkOperators(ctx context.Context, params GetMobileNetworkOperatorsParams) (GetMobileNetworkOperatorsRes, error)
	// GetNetwork invokes GetNetwork operation.
	//
	// Retrieve a Network.
	//
	// GET /networks/{id}
	GetNetwork(ctx context.Context, params GetNetworkParams) (GetNetworkRes, error)
	// GetNotificationChannel invokes GetNotificationChannel operation.
	//
	// Get a notification channel.
	//
	// GET /notification_channels/{id}
	GetNotificationChannel(ctx context.Context, params GetNotificationChannelParams) (GetNotificationChannelRes, error)
	// GetNumberOrderPhoneNumber invokes GetNumberOrderPhoneNumber operation.
	//
	// Get an existing number order phone number.
	//
	// GET /number_order_phone_numbers/{number_order_phone_number_id}
	GetNumberOrderPhoneNumber(ctx context.Context, params GetNumberOrderPhoneNumberParams) (GetNumberOrderPhoneNumberRes, error)
	// GetPhoneNumberMessagingSettings invokes GetPhoneNumberMessagingSettings operation.
	//
	// Retrieve a phone number with messaging settings.
	//
	// GET /phone_numbers/{id}/messaging
	GetPhoneNumberMessagingSettings(ctx context.Context, params GetPhoneNumberMessagingSettingsParams) (GetPhoneNumberMessagingSettingsRes, error)
	// GetPhoneNumberVoiceSettings invokes GetPhoneNumberVoiceSettings operation.
	//
	// Retrieve a phone number with voice settings.
	//
	// GET /phone_numbers/{id}/voice
	GetPhoneNumberVoiceSettings(ctx context.Context, params GetPhoneNumberVoiceSettingsParams) (GetPhoneNumberVoiceSettingsRes, error)
	// GetPhoneNumbers invokes GetPhoneNumbers operation.
	//
	// Retrieve the assigned phone numbers in a channel zone. Phone numbers assigned to a channel zone
	// can receive concurrent calls up to the quantity reserved in that channel zone. Additional
	// concurrent calls are rejected with a busy signal.
	//
	// GET /channel_zones/{channel_zone_id}/channel_zone_phone_numbers
	GetPhoneNumbers(ctx context.Context, params GetPhoneNumbersParams) (*GetGcbPhoneNumbersRequestResponse, error)
	// GetPortRequestSupportingDocuments invokes GetPortRequestSupportingDocuments operation.
	//
	// List every supporting documents for a portout request.
	//
	// GET /portouts/{id}/supporting_documents
	GetPortRequestSupportingDocuments(ctx context.Context, params GetPortRequestSupportingDocumentsParams) (GetPortRequestSupportingDocumentsRes, error)
	// GetRecording invokes GetRecording operation.
	//
	// Retrieves the details of an existing call recording.
	//
	// GET /recordings/{recording_id}
	GetRecording(ctx context.Context, params GetRecordingParams) (GetRecordingRes, error)
	// GetRecordingTranscription invokes getRecordingTranscription operation.
	//
	// Retrieves the details of an existing recording transcription.
	//
	// GET /recording_transcriptions/{recording_transcription_id}
	GetRecordingTranscription(ctx context.Context, params GetRecordingTranscriptionParams) (GetRecordingTranscriptionRes, error)
	// GetRecordingTranscriptions invokes getRecordingTranscriptions operation.
	//
	// Returns a list of your recording transcriptions.
	//
	// GET /recording_transcriptions
	GetRecordingTranscriptions(ctx context.Context) (GetRecordingTranscriptionsRes, error)
	// GetRecordings invokes GetRecordings operation.
	//
	// Returns a list of your call recordings.
	//
	// GET /recordings
	GetRecordings(ctx context.Context, params GetRecordingsParams) (GetRecordingsRes, error)
	// GetTeXMLCallRecording invokes GetTeXMLCallRecording operation.
	//
	// Returns recording resource identified by recording id.
	//
	// GET /texml/Accounts/{account_sid}/Recordings/{recording_sid}.json
	GetTeXMLCallRecording(ctx context.Context, params GetTeXMLCallRecordingParams) (GetTeXMLCallRecordingRes, error)
	// GetTeXMLCallRecordings invokes GetTeXMLCallRecordings operation.
	//
	// Returns multiple recording resources for an account.
	//
	// GET /texml/Accounts/{account_sid}/Recordings.json
	GetTeXMLCallRecordings(ctx context.Context, params GetTeXMLCallRecordingsParams) (GetTeXMLCallRecordingsRes, error)
	// GetTeXMLRecordingTranscription invokes GetTeXMLRecordingTranscription operation.
	//
	// Returns the recording transcription resource identified by its ID.
	//
	// GET /texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json
	GetTeXMLRecordingTranscription(ctx context.Context, params GetTeXMLRecordingTranscriptionParams) (GetTeXMLRecordingTranscriptionRes, error)
	// GetTeXMLRecordingTranscriptions invokes GetTeXMLRecordingTranscriptions operation.
	//
	// Returns multiple recording transcription resources for an account.
	//
	// GET /texml/Accounts/{account_sid}/Transcriptions.json
	GetTeXMLRecordingTranscriptions(ctx context.Context, params GetTeXMLRecordingTranscriptionsParams) (GetTeXMLRecordingTranscriptionsRes, error)
	// GetTelephonyCredential invokes GetTelephonyCredential operation.
	//
	// Get the details of an existing On-demand Credential.
	//
	// GET /telephony_credentials/{id}
	GetTelephonyCredential(ctx context.Context, params GetTelephonyCredentialParams) (GetTelephonyCredentialRes, error)
	// GetTexmlApplication invokes GetTexmlApplication operation.
	//
	// Retrieves the details of an existing TeXML Application.
	//
	// GET /texml_applications/{id}
	GetTexmlApplication(ctx context.Context, params GetTexmlApplicationParams) (GetTexmlApplicationRes, error)
	// GetTexmlCall invokes GetTexmlCall operation.
	//
	// Returns an individual call identified by its CallSid. This endpoint is eventually consistent.
	//
	// GET /texml/Accounts/{account_sid}/Calls/{call_sid}
	GetTexmlCall(ctx context.Context, params GetTexmlCallParams) (GetTexmlCallRes, error)
	// GetTexmlCalls invokes GetTexmlCalls operation.
	//
	// Returns multiple call resouces for an account. This endpoint is eventually consistent.
	//
	// GET /texml/Accounts/{account_sid}/Calls
	GetTexmlCalls(ctx context.Context, params GetTexmlCallsParams) (GetTexmlCallsRes, error)
	// GetTexmlConference invokes GetTexmlConference operation.
	//
	// Returns a conference resource.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}
	GetTexmlConference(ctx context.Context, params GetTexmlConferenceParams) (GetTexmlConferenceRes, error)
	// GetTexmlConferenceParticipant invokes GetTexmlConferenceParticipant operation.
	//
	// Gets conference participant resource.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
	GetTexmlConferenceParticipant(ctx context.Context, params GetTexmlConferenceParticipantParams) (GetTexmlConferenceParticipantRes, error)
	// GetTexmlConferenceParticipants invokes GetTexmlConferenceParticipants operation.
	//
	// Lists conference participants.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants
	GetTexmlConferenceParticipants(ctx context.Context, params GetTexmlConferenceParticipantsParams) (GetTexmlConferenceParticipantsRes, error)
	// GetTexmlConferenceRecordings invokes GetTexmlConferenceRecordings operation.
	//
	// Lists conference recordings.
	//
	// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings
	GetTexmlConferenceRecordings(ctx context.Context, params GetTexmlConferenceRecordingsParams) (GetTexmlConferenceRecordingsRes, error)
	// GetTexmlConferences invokes GetTexmlConferences operation.
	//
	// Lists conference resources.
	//
	// GET /texml/Accounts/{account_sid}/Conferences
	GetTexmlConferences(ctx context.Context, params GetTexmlConferencesParams) (GetTexmlConferencesRes, error)
	// GetUserBalance invokes GetUserBalance operation.
	//
	// Get user balance details.
	//
	// GET /balance
	GetUserBalance(ctx context.Context) (GetUserBalanceRes, error)
	// GetVerifiedNumber invokes GetVerifiedNumber operation.
	//
	// Retrieve a verified number.
	//
	// GET /verified_numbers/{phone_number}
	GetVerifiedNumber(ctx context.Context, params GetVerifiedNumberParams) (GetVerifiedNumberRes, error)
	// GetVerifyProfile invokes GetVerifyProfile operation.
	//
	// Gets a single Verify profile.
	//
	// GET /verify_profiles/{verify_profile_id}
	GetVerifyProfile(ctx context.Context, params GetVerifyProfileParams) (GetVerifyProfileRes, error)
	// GetWebhookDeliveries invokes GetWebhookDeliveries operation.
	//
	// Lists webhook_deliveries for the authenticated user.
	//
	// GET /webhook_deliveries
	GetWebhookDeliveries(ctx context.Context, params GetWebhookDeliveriesParams) (GetWebhookDeliveriesRes, error)
	// GetWebhookDelivery invokes GetWebhookDelivery operation.
	//
	// Provides webhook_delivery debug data, such as timestamps, delivery status and attempts.
	//
	// GET /webhook_deliveries/{id}
	GetWebhookDelivery(ctx context.Context, params GetWebhookDeliveryParams) (GetWebhookDeliveryRes, error)
	// HangupCall invokes HangupCall operation.
	//
	// Hang up the call.
	// **Expected Webhooks:**
	// - `call.hangup`
	// - `call.recording.saved`.
	//
	// POST /calls/{call_control_id}/actions/hangup
	HangupCall(ctx context.Context, request *HangupRequest, params HangupCallParams) (HangupCallRes, error)
	// InitiateTexmlCallByAccount invokes InitiateTexmlCallByAccount operation.
	//
	// Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for
	// the connection in the Mission Control Portal.
	//
	// POST /texml/Accounts/{account_sid}/Calls
	InitiateTexmlCallByAccount(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByAccountParams) (*InitiateCallResponse, error)
	// InitiateTexmlCallByApplication invokes InitiateTexmlCallByApplication operation.
	//
	// Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for
	// the connection in the Mission Control Portal.
	//
	// POST /texml/calls/{application_id}
	InitiateTexmlCallByApplication(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByApplicationParams) (*InitiateCallResponse, error)
	// LeaveQueue invokes LeaveQueue operation.
	//
	// Removes the call from a queue.
	//
	// POST /calls/{call_control_id}/actions/leave_queue
	LeaveQueue(ctx context.Context, request *LeaveQueueRequest, params LeaveQueueParams) (LeaveQueueRes, error)
	// ListAvailablePhoneNumbers invokes ListAvailablePhoneNumbers operation.
	//
	// List available phone numbers.
	//
	// GET /available_phone_numbers
	ListAvailablePhoneNumbers(ctx context.Context, params ListAvailablePhoneNumbersParams) (ListAvailablePhoneNumbersRes, error)
	// ListCallControlApplications invokes ListCallControlApplications operation.
	//
	// Return a list of call control applications.
	//
	// GET /call_control_applications
	ListCallControlApplications(ctx context.Context, params ListCallControlApplicationsParams) (ListCallControlApplicationsRes, error)
	// ListConnectionActiveCalls invokes ListConnectionActiveCalls operation.
	//
	// Lists all active calls for given connection. Acceptable connections are either SIP connections
	// with webhook_url or xml_request_url, call control or texml. Returned results are cursor paginated.
	//
	// GET /connections/{connection_id}/active_calls
	ListConnectionActiveCalls(ctx context.Context, params ListConnectionActiveCallsParams) (ListConnectionActiveCallsRes, error)
	// ListCsvDownloads invokes ListCsvDownloads operation.
	//
	// List CSV downloads.
	//
	// GET /phone_numbers/csv_downloads
	ListCsvDownloads(ctx context.Context, params ListCsvDownloadsParams) (ListCsvDownloadsRes, error)
	// ListExternalConnectionLogMessages invokes ListExternalConnectionLogMessages operation.
	//
	// Retrieve a list of log messages for all external connections associated with your account.
	//
	// GET /external_connections/log_messages
	ListExternalConnectionLogMessages(ctx context.Context, params ListExternalConnectionLogMessagesParams) (ListExternalConnectionLogMessagesRes, error)
	// ListExternalConnectionPhoneNumbers invokes ListExternalConnectionPhoneNumbers operation.
	//
	// Returns a list of all active phone numbers associated with the given external connection.
	//
	// GET /external_connections/{id}/phone_numbers
	ListExternalConnectionPhoneNumbers(ctx context.Context, params ListExternalConnectionPhoneNumbersParams) (ListExternalConnectionPhoneNumbersRes, error)
	// ListInboundChannels invokes ListInboundChannels operation.
	//
	// Returns the inbound channels for your account. Inbound channels allows you to use Channel Billing
	// for calls to your Telnyx phone numbers. Please check the Telnyx Support Articles section for full
	// information and examples of how to utilize Channel Billing.
	//
	// GET /phone_numbers/inbound_channels
	ListInboundChannels(ctx context.Context) (ListInboundChannelsRes, error)
	// ListMessagingHostedNumberOrders invokes ListMessagingHostedNumberOrders operation.
	//
	// List messaging hosted number orders.
	//
	// GET /messaging_hosted_number_orders
	ListMessagingHostedNumberOrders(ctx context.Context, params ListMessagingHostedNumberOrdersParams) (ListMessagingHostedNumberOrdersRes, error)
	// ListMessagingUrlDomains invokes ListMessagingUrlDomains operation.
	//
	// List messaging URL domains.
	//
	// GET /messaging_url_domains
	ListMessagingUrlDomains(ctx context.Context, params ListMessagingUrlDomainsParams) (ListMessagingUrlDomainsRes, error)
	// ListNetworkInterfaces invokes ListNetworkInterfaces operation.
	//
	// List all Interfaces for a Network.
	//
	// GET /networks/{id}/network_interfaces
	ListNetworkInterfaces(ctx context.Context, params ListNetworkInterfacesParams) (ListNetworkInterfacesRes, error)
	// ListNetworks invokes ListNetworks operation.
	//
	// List all Networks.
	//
	// GET /networks
	ListNetworks(ctx context.Context, params ListNetworksParams) (ListNetworksRes, error)
	// ListNotificationChannels invokes ListNotificationChannels operation.
	//
	// List notification channels.
	//
	// GET /notification_channels
	ListNotificationChannels(ctx context.Context, params ListNotificationChannelsParams) (ListNotificationChannelsRes, error)
	// ListPhoneNumbers invokes ListPhoneNumbers operation.
	//
	// List phone numbers.
	//
	// GET /phone_numbers
	ListPhoneNumbers(ctx context.Context, params ListPhoneNumbersParams) (ListPhoneNumbersRes, error)
	// ListPhoneNumbersJobs invokes ListPhoneNumbersJobs operation.
	//
	// Lists the phone numbers jobs.
	//
	// GET /phone_numbers/jobs
	ListPhoneNumbersJobs(ctx context.Context, params ListPhoneNumbersJobsParams) (ListPhoneNumbersJobsRes, error)
	// ListPhoneNumbersWithMessagingSettings invokes ListPhoneNumbersWithMessagingSettings operation.
	//
	// List phone numbers with messaging settings.
	//
	// GET /phone_numbers/messaging
	ListPhoneNumbersWithMessagingSettings(ctx context.Context, params ListPhoneNumbersWithMessagingSettingsParams) (ListPhoneNumbersWithMessagingSettingsRes, error)
	// ListPhoneNumbersWithVoiceSettings invokes ListPhoneNumbersWithVoiceSettings operation.
	//
	// List phone numbers with voice settings.
	//
	// GET /phone_numbers/voice
	ListPhoneNumbersWithVoiceSettings(ctx context.Context, params ListPhoneNumbersWithVoiceSettingsParams) (ListPhoneNumbersWithVoiceSettingsRes, error)
	// ListPortingPhoneNumbers invokes ListPortingPhoneNumbers operation.
	//
	// Returns a list of your porting phone numbers.
	//
	// GET /porting_phone_numbers
	ListPortingPhoneNumbers(ctx context.Context, params ListPortingPhoneNumbersParams) (ListPortingPhoneNumbersRes, error)
	// ListProfileMessageTemplates invokes ListProfileMessageTemplates operation.
	//
	// List all Verify profile message templates.
	//
	// GET /verify_profiles/templates
	ListProfileMessageTemplates(ctx context.Context) (*ListVerifyProfileMessageTemplateResponse, error)
	// ListProfilePhoneNumbers invokes ListProfilePhoneNumbers operation.
	//
	// List phone numbers associated with a messaging profile.
	//
	// GET /messaging_profiles/{id}/phone_numbers
	ListProfilePhoneNumbers(ctx context.Context, params ListProfilePhoneNumbersParams) (ListProfilePhoneNumbersRes, error)
	// ListProfiles invokes ListProfiles operation.
	//
	// Gets a paginated list of Verify profiles.
	//
	// GET /verify_profiles
	ListProfiles(ctx context.Context, params ListProfilesParams) (ListProfilesRes, error)
	// ListQueueCalls invokes ListQueueCalls operation.
	//
	// Retrieve the list of calls in an existing queue.
	//
	// GET /queues/{queue_name}/calls
	ListQueueCalls(ctx context.Context, params ListQueueCallsParams) (ListQueueCallsRes, error)
	// ListRegulatoryRequirements invokes ListRegulatoryRequirements operation.
	//
	// Retrieve regulartory requirements.
	//
	// GET /phone_numbers_regulatory_requirements
	ListRegulatoryRequirements(ctx context.Context, params ListRegulatoryRequirementsParams) (ListRegulatoryRequirementsRes, error)
	// ListRoomRecordings invokes ListRoomRecordings operation.
	//
	// View a list of room recordings.
	//
	// GET /room_recordings
	ListRoomRecordings(ctx context.Context, params ListRoomRecordingsParams) (*ListRoomRecordingsResponse, error)
	// ListTags invokes ListTags operation.
	//
	// Returns a list of tags used on Credentials.
	//
	// GET /telephony_credentials/tags
	ListTags(ctx context.Context, params ListTagsParams) (ListTagsRes, error)
	// ListVerifications invokes ListVerifications operation.
	//
	// List verifications by phone number.
	//
	// GET /verifications/by_phone_number/{phone_number}
	ListVerifications(ctx context.Context, params ListVerificationsParams) (ListVerificationsRes, error)
	// ListVerifiedCallDisplayProfiles invokes ListVerifiedCallDisplayProfiles operation.
	//
	// Lists the Verified Calls Display Profiles owned by the current user/organization.
	//
	// GET /verified_calls_display_profiles
	ListVerifiedCallDisplayProfiles(ctx context.Context, params ListVerifiedCallDisplayProfilesParams) (ListVerifiedCallDisplayProfilesRes, error)
	// ListVerifiedNumbers invokes ListVerifiedNumbers operation.
	//
	// Gets a paginated list of Verified Numbers.
	//
	// GET /verified_numbers
	ListVerifiedNumbers(ctx context.Context, params ListVerifiedNumbersParams) (ListVerifiedNumbersRes, error)
	// LookupNumber invokes LookupNumber operation.
	//
	// Returns information about the provided phone number.
	//
	// GET /number_lookup/{phone_number}
	LookupNumber(ctx context.Context, params LookupNumberParams) (LookupNumberRes, error)
	// NoiseSuppressionStart invokes noiseSuppressionStart operation.
	//
	// Noise Suppression Start (BETA).
	//
	// POST /calls/{call_control_id}/actions/suppression_start
	NoiseSuppressionStart(ctx context.Context, request *NoiseSuppressionStart, params NoiseSuppressionStartParams) (NoiseSuppressionStartRes, error)
	// NoiseSuppressionStop invokes noiseSuppressionStop operation.
	//
	// Noise Suppression Stop (BETA).
	//
	// POST /calls/{call_control_id}/actions/suppression_stop
	NoiseSuppressionStop(ctx context.Context, request *NoiseSuppressionStop, params NoiseSuppressionStopParams) (NoiseSuppressionStopRes, error)
	// PauseCallRecording invokes PauseCallRecording operation.
	//
	// Pause recording the call. Recording can be resumed via Resume recording command.
	// **Expected Webhooks:**
	// There are no webhooks associated with this command.
	//
	// POST /calls/{call_control_id}/actions/record_pause
	PauseCallRecording(ctx context.Context, request *PauseRecordingRequest, params PauseCallRecordingParams) (PauseCallRecordingRes, error)
	// PerformCredentialAction invokes PerformCredentialAction operation.
	//
	// Perform activate or deactivate action on provided Credential. Activate action will change the
	// status to active, making it possible to connect calls with the credential. Deactivate action will
	// change the status to inactive, making it impossible to connect calls with the credential.
	//
	// POST /telephony_credentials/{id}/actions/{action}
	PerformCredentialAction(ctx context.Context, params PerformCredentialActionParams) (PerformCredentialActionRes, error)
	// PostPortRequestComment invokes PostPortRequestComment operation.
	//
	// Creates a comment on a portout request.
	//
	// POST /portouts/{id}/comments
	PostPortRequestComment(ctx context.Context, request *PostPortRequestCommentReq, params PostPortRequestCommentParams) (PostPortRequestCommentRes, error)
	// PostPortRequestSupportingDocuments invokes PostPortRequestSupportingDocuments operation.
	//
	// Creates a list of supporting documents on a portout request.
	//
	// POST /portouts/{id}/supporting_documents
	PostPortRequestSupportingDocuments(ctx context.Context, request *PostPortRequestSupportingDocumentsReq, params PostPortRequestSupportingDocumentsParams) (PostPortRequestSupportingDocumentsRes, error)
	// ReferCall invokes ReferCall operation.
	//
	// Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any point in the
	// duration of a call.
	// **Expected Webhooks:**
	// - `call.refer.started`
	// - `call.refer.completed`
	// - `call.refer.failed`.
	//
	// POST /calls/{call_control_id}/actions/refer
	ReferCall(ctx context.Context, request *ReferRequest, params ReferCallParams) (ReferCallRes, error)
	// RegisterCall invokes RegisterCall operation.
	//
	// Register the call before dialing to show your brand on callee's phone.
	//
	// POST /calls/register
	RegisterCall(ctx context.Context, request *RegisterCallRequest) (RegisterCallRes, error)
	// RejectCall invokes RejectCall operation.
	//
	// Reject an incoming call.
	// **Expected Webhooks:**
	// - `call.hangup`.
	//
	// POST /calls/{call_control_id}/actions/reject
	RejectCall(ctx context.Context, request *RejectRequest, params RejectCallParams) (RejectCallRes, error)
	// ResumeCallRecording invokes ResumeCallRecording operation.
	//
	// Resume recording the call.
	// **Expected Webhooks:**
	// There are no webhooks associated with this command.
	//
	// POST /calls/{call_control_id}/actions/record_resume
	ResumeCallRecording(ctx context.Context, request *ResumeRecordingRequest, params ResumeCallRecordingParams) (ResumeCallRecordingRes, error)
	// RetrieveCallControlApplication invokes RetrieveCallControlApplication operation.
	//
	// Retrieves the details of an existing call control application.
	//
	// GET /call_control_applications/{id}
	RetrieveCallControlApplication(ctx context.Context, params RetrieveCallControlApplicationParams) (RetrieveCallControlApplicationRes, error)
	// RetrieveCallFromQueue invokes RetrieveCallFromQueue operation.
	//
	// Retrieve an existing call from an existing queue.
	//
	// GET /queues/{queue_name}/calls/{call_control_id}
	RetrieveCallFromQueue(ctx context.Context, params RetrieveCallFromQueueParams) (RetrieveCallFromQueueRes, error)
	// RetrieveCallStatus invokes RetrieveCallStatus operation.
	//
	// Returns the status of a call (data is available 10 minutes after call ended).
	//
	// GET /calls/{call_control_id}
	RetrieveCallStatus(ctx context.Context, params RetrieveCallStatusParams) (RetrieveCallStatusRes, error)
	// RetrieveOrderPhoneNumbers invokes RetrieveOrderPhoneNumbers operation.
	//
	// Get a list of phone numbers associated to orders.
	//
	// GET /number_order_phone_numbers
	RetrieveOrderPhoneNumbers(ctx context.Context) (RetrieveOrderPhoneNumbersRes, error)
	// RetrievePhoneNumber invokes RetrievePhoneNumber operation.
	//
	// Retrieve a phone number.
	//
	// GET /phone_numbers/{id}
	RetrievePhoneNumber(ctx context.Context, params RetrievePhoneNumberParams) (RetrievePhoneNumberRes, error)
	// RetrievePhoneNumbersJob invokes RetrievePhoneNumbersJob operation.
	//
	// Retrieve a phone numbers job.
	//
	// GET /phone_numbers/jobs/{id}
	RetrievePhoneNumbersJob(ctx context.Context, params RetrievePhoneNumbersJobParams) (RetrievePhoneNumbersJobRes, error)
	// RetrieveVerification invokes RetrieveVerification operation.
	//
	// Retrieve verification.
	//
	// GET /verifications/{verification_id}
	RetrieveVerification(ctx context.Context, params RetrieveVerificationParams) (RetrieveVerificationRes, error)
	// SendDTMF invokes SendDTMF operation.
	//
	// Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.
	// **Expected Webhooks:**
	// There are no webhooks associated with this command.
	//
	// POST /calls/{call_control_id}/actions/send_dtmf
	SendDTMF(ctx context.Context, request *SendDTMFRequest, params SendDTMFParams) (SendDTMFRes, error)
	// SendMessage invokes SendMessage operation.
	//
	// Send a message with a Phone Number, Alphanumeric Sender ID, Short Code or Number Pool.
	// This endpoint allows you to send a message with any messaging resource.
	// Current messaging resources include: long-code, short-code, number-pool, and
	// alphanumeric-sender-id.
	//
	// POST /messages
	SendMessage(ctx context.Context, request OptCreateMessageRequest) (SendMessageRes, error)
	// SlimListPhoneNumbers invokes SlimListPhoneNumbers operation.
	//
	// List phone numbers, This endpoint is a lighter version of the /phone_numbers endpoint having
	// higher performance and rate limit.
	//
	// GET /phone_numbers/slim
	SlimListPhoneNumbers(ctx context.Context, params SlimListPhoneNumbersParams) (SlimListPhoneNumbersRes, error)
	// SpeakCall invokes SpeakCall operation.
	//
	// Convert text to speech and play it back on the call. If multiple speak text commands are issued
	// consecutively, the audio files will be placed in a queue awaiting playback.
	// **Expected Webhooks:**
	// - `call.speak.started`
	// - `call.speak.ended`.
	//
	// POST /calls/{call_control_id}/actions/speak
	SpeakCall(ctx context.Context, request *SpeakRequest, params SpeakCallParams) (SpeakCallRes, error)
	// StartCallFork invokes StartCallFork operation.
	//
	// Call forking allows you to stream the media from a call to a specific target in realtime.
	// This stream can be used to enable realtime audio analysis to support a
	// variety of use cases, including fraud detection, or the creation of AI-generated audio responses.
	// Requests must specify either the `target` attribute or the `rx` and `tx` attributes.
	// **Expected Webhooks:**
	// - `call.fork.started`
	// - `call.fork.stopped`
	// **Simple Telnyx RTP Encapsulation Protocol (STREP)**
	// *Note: This header/encapsulation is not used when the `rx` and `tx`
	// parameters have been specified; it only applies when media is forked
	// using the `target` attribute.*
	// If the destination for forked media is specified using the "target"
	// attribute, the RTP will be encapsulated in an extra Telnyx protocol,
	// which adds a 24 byte header to the RTP payload in each packet. The STREP
	// header includes the Call Control `call_leg_id` for stream
	// identification, along with bits that represent the direction (inbound or
	// outbound) of the media. This 24-byte header sits between the UDP header
	// and the RTP header.
	// The STREP header makes it possible to fork RTP for multiple calls (or
	// two RTP streams for the same call) to the same IP:port, where the
	// streams can be demultiplexed by your application using the information
	// in the header. Of course, it's still possible to ignore this header
	// completely, for example, if sending forked media for different calls to
	// different ports or IP addresses. In this case, simply strip 24 bytes
	// (or use the second byte to find the header length) from the received UDP
	// payload to get the RTP (RTP header and payload).
	// ```
	// STREP Specification
	// 0                   1                   2                   3
	// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |
	// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// |       reserved (4 bytes, for UDP ports or anything else)      |
	// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// |               The call_leg_id                                 |
	// |                   from Call Control                           |
	// |                       (128 bits / 16 bytes)                   |
	// |                           (this is binary data)               |
	// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// 11
	// Static bits 11, always set to 11 to easily distinguish forked media
	// from RTP (10) and T.38 media (usually 00) and SIP (which begins
	// with a capital letter, so begins with bits 01). This is a magic number.
	// Version
	// Four bits to indicate the version number of the protocol, starting at 0001.
	// L
	// One bit to represent the leg of the call (A or B).
	// 0 represents the A (first) leg of the call.
	// 1 represents the B (second) leg of the call.
	// D
	// One bit to represent the direction of this RTP stream.
	// 0 represents media received by Telnyx.
	// 1 represents media transmitted by Telnyx.
	// HeaderLen (1 byte)
	// The length of the header in bytes.
	// Note that this value does not include the length of the payload. The total
	// size of the RTP can be calculated by subtracting the HeaderLen from the UDP
	// length (minus 8 for the UDP header).
	// In version 1, this value will always be 24.
	// Reserved (6 bytes)
	// Reserved for future use and to make sure that the header is a multiple of 32 bits
	// Call Leg ID
	// A 128-bit identifier for the call leg.
	// This is the call_leg_id from Call Control.
	// ```.
	//
	// POST /calls/{call_control_id}/actions/fork_start
	StartCallFork(ctx context.Context, request *StartForkingRequest, params StartCallForkParams) (StartCallForkRes, error)
	// StartCallPlayback invokes StartCallPlayback operation.
	//
	// Play an audio file on the call. If multiple play audio commands are issued consecutively,
	// the audio files will be placed in a queue awaiting playback.
	// *Notes:*
	// - When `overlay` is enabled, `target_legs` is limited to `self`.
	// - A customer cannot Play Audio with `overlay=true` unless there is a Play Audio with
	// `overlay=false` actively playing.
	// **Expected Webhooks:**
	// - `call.playback.started`
	// - `call.playback.ended`.
	//
	// POST /calls/{call_control_id}/actions/playback_start
	StartCallPlayback(ctx context.Context, request *PlayAudioUrlRequest, params StartCallPlaybackParams) (StartCallPlaybackRes, error)
	// StartCallRecord invokes StartCallRecord operation.
	//
	// Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop
	// Recording command.
	// **Expected Webhooks:**
	// - `call.recording.saved`.
	//
	// POST /calls/{call_control_id}/actions/record_start
	StartCallRecord(ctx context.Context, request *StartRecordingRequest, params StartCallRecordParams) (StartCallRecordRes, error)
	// StartCallStreaming invokes StartCallStreaming operation.
	//
	// Start streaming the media from a call to a specific WebSocket address or Dialogflow connection in
	// near-realtime. Audio will be delivered as base64-encoded RTP payload (raw audio), wrapped in JSON
	// payloads.
	// **Example: Starting a stream to a Websocket address**
	// The `stream_url` param is mandatory.
	// ```
	// curl -X POST \
	// --header "Content-Type: application/json" \
	// --header "Accept: application/json" \
	// --header "Authorization: Bearer YOUR_API_KEY" \
	// --data '{
	// "stream_url": "wss://www.example.com/websocket",\
	// "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d",\
	// "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901" \
	// }' \
	// https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
	// ```
	// **Example: Starting a stream to a Dialogflow connection**
	// Enable the Dialogflow integration by sending `"enable_dialogflow": true` in the request. You need
	// to have a Dialogflow connection associated with your Call Control application first, [click here
	// for instructions](https://developers.telnyx.com/docs/voice/programmable-voice/dialogflow-es).
	// ```
	// curl -X POST \
	// --header "Content-Type: application/json" \
	// --header "Accept: application/json" \
	// --header "Authorization: Bearer YOUR_API_KEY" \
	// --data '{
	// "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d", \
	// "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901", \
	// "enable_dialogflow": true \
	// }' \
	// https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
	// ```
	// **Expected Webhooks:**
	// - `streaming.started`
	// - `streaming.stopped`
	// - `streaming.failed`
	// **WebSocket events**
	// When the WebSocket connection is established, the following event is being sent over it:
	// ```
	// {
	// "event": "connected",
	// "version": "1.0.0"
	// }
	// ```
	// And when the call is started, an event which contains information about the encoding and
	// `stream_id` that identifies a particular stream:
	// ```
	// {
	// "event": "start",
	// "sequence_number": "1",
	// "start": {
	// "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
	// "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
	// "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
	// "media_format": {
	// "encoding": "audio/x-mulaw",
	// "sample_rate": 8000,
	// "channels": 1
	// }
	// },
	// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
	// }
	// ```
	// The start event is followed by the following media events that contain base64-encoded RTP payload
	// (raw audio, no RTP headers) (:
	// ```
	// {
	// "event": "media",
	// "sequence_number": "4",
	// "media": {
	// "track": "inbound/outbound",
	// "chunk": "2",
	// "timestamp": "5",
	// "payload": "no+JhoaJjpzSHxAKBgYJD...IsSbjomGhoqQn1Ic"
	// },
	// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
	// }
	// ```
	// Please note that the order of events is not guaranteed and the chunk number can be used to reorder
	// the events.
	// When the call ends, the stop event over WebSockets connection is sent:
	// ```
	// {
	// "event": "stop",
	// "sequence_number": "5",
	// "stop": {
	// "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
	// "call_control_id": "v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQ"
	// },
	// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
	// }
	// ```
	// **Bidirectional Media Streaming**
	// Media can be sent back to the call through the websocket as well. This is done in a way very
	// similar to the [playback_start](https://developers.telnyx.
	// com/docs/api/v2/call-control/Call-Commands#callPlaybackStart)
	// command, when using a base64 encoded mp3 file in the payload. Simply send a packet to the
	// websocket connection as follows:
	// ```
	// {
	// "event": "media",
	// "media": {
	// "payload" : <your base64 encoded mp3 file>
	// }
	// }
	// ```
	// The payload, which is a base64-encoded mp3 file, will be played on the call.
	// Some limitations to be aware of:
	// - Media payloads can only be submitted once per second.
	// - Media _must_ be base64 encoded mp3
	// **Stream Errors**
	// Any errors in the media packet, including when a rate limit is reached, will result in an error
	// frame being
	// sent to your websocket server. The error frame will appear as follows:
	// ```
	// {
	// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc",
	// "event": "error",
	// "sequence_number": "6",
	// "error": {
	// "title": "rate_limit_reached",
	// "code": "100005",
	// "detail": "Too many requests"
	// }
	// }
	// ```
	// Possible errors are as follows:
	// - Error 100002: `"unknown_error"`
	// - Error 100003: `"malformed_frame"`
	// - Error 100004: `"invalid_media"`
	// - Error 100005: `"rate_limit_reached"`.
	//
	// POST /calls/{call_control_id}/actions/streaming_start
	StartCallStreaming(ctx context.Context, request *StartStreamingRequest, params StartCallStreamingParams) (StartCallStreamingRes, error)
	// StartCallTranscription invokes StartCallTranscription operation.
	//
	// Start real-time transcription. Transcription will stop on call hang-up, or can be initiated via
	// the Transcription stop command.
	// **Expected Webhooks:**
	// - `call.transcription`.
	//
	// POST /calls/{call_control_id}/actions/transcription_start
	StartCallTranscription(ctx context.Context, request *TranscriptionStartRequest, params StartCallTranscriptionParams) (StartCallTranscriptionRes, error)
	// StartTeXMLCallRecording invokes StartTeXMLCallRecording operation.
	//
	// Starts recording with specified parameters for call idientified by call_sid.
	//
	// POST /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json
	StartTeXMLCallRecording(ctx context.Context, request OptTexmlCreateCallRecordingRequestBody, params StartTeXMLCallRecordingParams) (StartTeXMLCallRecordingRes, error)
	// StopCallFork invokes StopCallFork operation.
	//
	// Stop forking a call.
	// **Expected Webhooks:**
	// - `call.fork.stopped`.
	//
	// POST /calls/{call_control_id}/actions/fork_stop
	StopCallFork(ctx context.Context, request *StopForkingRequest, params StopCallForkParams) (StopCallForkRes, error)
	// StopCallGather invokes StopCallGather operation.
	//
	// Stop current gather.
	// **Expected Webhooks:**
	// - `call.gather.ended`.
	//
	// POST /calls/{call_control_id}/actions/gather_stop
	StopCallGather(ctx context.Context, request *StopGatherRequest, params StopCallGatherParams) (StopCallGatherRes, error)
	// StopCallPlayback invokes StopCallPlayback operation.
	//
	// Stop audio being played on the call.
	// **Expected Webhooks:**
	// - `call.playback.ended` or `call.speak.ended`.
	//
	// POST /calls/{call_control_id}/actions/playback_stop
	StopCallPlayback(ctx context.Context, request *PlaybackStopRequest, params StopCallPlaybackParams) (StopCallPlaybackRes, error)
	// StopCallRecording invokes StopCallRecording operation.
	//
	// Stop recording the call.
	// **Expected Webhooks:**
	// - `call.recording.saved`.
	//
	// POST /calls/{call_control_id}/actions/record_stop
	StopCallRecording(ctx context.Context, request *StopRecordingRequest, params StopCallRecordingParams) (StopCallRecordingRes, error)
	// StopCallStreaming invokes StopCallStreaming operation.
	//
	// Stop streaming a call to a WebSocket.
	// **Expected Webhooks:**
	// - `streaming.stopped`.
	//
	// POST /calls/{call_control_id}/actions/streaming_stop
	StopCallStreaming(ctx context.Context, request *StopStreamingRequest, params StopCallStreamingParams) (StopCallStreamingRes, error)
	// StopCallTranscription invokes StopCallTranscription operation.
	//
	// Stop real-time transcription.
	//
	// POST /calls/{call_control_id}/actions/transcription_stop
	StopCallTranscription(ctx context.Context, request *TranscriptionStopRequest, params StopCallTranscriptionParams) (StopCallTranscriptionRes, error)
	// TransferCall invokes TransferCall operation.
	//
	// Transfer a call to a new destination. If the transfer is unsuccessful, a `call.hangup` webhook for
	// the other call (Leg B) will be sent indicating that the transfer could not be completed. The
	// original call will remain active and may be issued additional commands, potentially transfering
	// the call to an alternate destination.
	// **Expected Webhooks:**
	// - `call.initiated`
	// - `call.bridged` to Leg B
	// - `call.answered` or `call.hangup`
	// - `call.machine.detection.ended` if `answering_machine_detection` was requested
	// - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end
	// of machine greeting
	// - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
	// - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and
	// a beep was detected.
	//
	// POST /calls/{call_control_id}/actions/transfer
	TransferCall(ctx context.Context, request *TransferCallRequest, params TransferCallParams) (TransferCallRes, error)
	// UnassignPhoneNumber invokes UnassignPhoneNumber operation.
	//
	// Unassign a phone number from a channel zone.
	//
	// DELETE /channel_zones/{channel_zone_id}/channel_zone_phone_numbers/{phone_number}
	UnassignPhoneNumber(ctx context.Context, params UnassignPhoneNumberParams) (UnassignPhoneNumberRes, error)
	// UpdateBulkTelephonyCredential invokes UpdateBulkTelephonyCredential operation.
	//
	// Update several credentials in bulk.
	//
	// PATCH /actions/bulk/telephony_credentials
	UpdateBulkTelephonyCredential(ctx context.Context, request *BulkCredentialRequest, params UpdateBulkTelephonyCredentialParams) (UpdateBulkTelephonyCredentialRes, error)
	// UpdateCallControlApplication invokes UpdateCallControlApplication operation.
	//
	// Updates settings of an existing call control application.
	//
	// PATCH /call_control_applications/{id}
	UpdateCallControlApplication(ctx context.Context, request *UpdateCallControlApplicationRequest, params UpdateCallControlApplicationParams) (UpdateCallControlApplicationRes, error)
	// UpdateClientState invokes UpdateClientState operation.
	//
	// Updates client state.
	//
	// PUT /calls/{call_control_id}/actions/client_state_update
	UpdateClientState(ctx context.Context, request *ClientStateUpdateRequest, params UpdateClientStateParams) (UpdateClientStateRes, error)
	// UpdateCustomStorageCredentials invokes UpdateCustomStorageCredentials operation.
	//
	// Updates a stored custom credentials configuration.
	//
	// PUT /custom_storage_credentials/{connection_id}
	UpdateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params UpdateCustomStorageCredentialsParams) (UpdateCustomStorageCredentialsRes, error)
	// UpdateExternalConnectionPhoneNumber invokes UpdateExternalConnectionPhoneNumber operation.
	//
	// Asynchronously update settings of the phone number associated with the given external connection.
	//
	// PATCH /external_connections/{id}/phone_numbers/{phone_number_id}
	UpdateExternalConnectionPhoneNumber(ctx context.Context, request *UpdateExternalConnectionPhoneNumberRequest, params UpdateExternalConnectionPhoneNumberParams) (UpdateExternalConnectionPhoneNumberRes, error)
	// UpdateNetwork invokes UpdateNetwork operation.
	//
	// Update a Network.
	//
	// PATCH /networks/{id}
	UpdateNetwork(ctx context.Context, request *NetworkCreate, params UpdateNetworkParams) (UpdateNetworkRes, error)
	// UpdateNotificationChannel invokes UpdateNotificationChannel operation.
	//
	// Update a notification channel.
	//
	// PATCH /notification_channels/{id}
	UpdateNotificationChannel(ctx context.Context, request *NotificationChannel, params UpdateNotificationChannelParams) (UpdateNotificationChannelRes, error)
	// UpdateNumberOrderPhoneNumber invokes UpdateNumberOrderPhoneNumber operation.
	//
	// Updates a number order phone number.
	//
	// PATCH /number_order_phone_numbers/{number_order_phone_number_id}
	UpdateNumberOrderPhoneNumber(ctx context.Context, request *UpdateNumberOrderPhoneNumberRequest, params UpdateNumberOrderPhoneNumberParams) (UpdateNumberOrderPhoneNumberRes, error)
	// UpdateOutboundChannels invokes UpdateOutboundChannels operation.
	//
	// Update the inbound channels for the account.
	//
	// PATCH /phone_numbers/inbound_channels
	UpdateOutboundChannels(ctx context.Context, request *UpdateOutboundChannelsReq) (UpdateOutboundChannelsRes, error)
	// UpdatePhoneNumber invokes UpdatePhoneNumber operation.
	//
	// Update a phone number.
	//
	// PATCH /phone_numbers/{id}
	UpdatePhoneNumber(ctx context.Context, request *UpdatePhoneNumberRequest, params UpdatePhoneNumberParams) (UpdatePhoneNumberRes, error)
	// UpdatePhoneNumberMessagingSettings invokes UpdatePhoneNumberMessagingSettings operation.
	//
	// Update a phone number with messaging settings.
	//
	// PATCH /phone_numbers/{id}/messaging
	UpdatePhoneNumberMessagingSettings(ctx context.Context, request *UpdatePhoneNumberMessagingSettingsRequest, params UpdatePhoneNumberMessagingSettingsParams) (UpdatePhoneNumberMessagingSettingsRes, error)
	// UpdatePhoneNumberVoiceSettings invokes UpdatePhoneNumberVoiceSettings operation.
	//
	// Update a phone number with voice settings.
	//
	// PATCH /phone_numbers/{id}/voice
	UpdatePhoneNumberVoiceSettings(ctx context.Context, request *UpdatePhoneNumberVoiceSettingsRequest, params UpdatePhoneNumberVoiceSettingsParams) (UpdatePhoneNumberVoiceSettingsRes, error)
	// UpdatePortoutStatus invokes UpdatePortoutStatus operation.
	//
	// Authorize or reject portout request.
	//
	// PATCH /portouts/{id}/{status}
	UpdatePortoutStatus(ctx context.Context, request *UpdatePortoutStatusReq, params UpdatePortoutStatusParams) (UpdatePortoutStatusRes, error)
	// UpdateProfile invokes UpdateProfile operation.
	//
	// Update an existing Verified Calls Display Profile and allows adding/removing nested Call Reasons
	// and Phone Numbers. Different attributes can be updated depending on the Verified Calls Display
	// Profile's status: For the VERIFICATION_STATE_PENDING status, no fields can be updated. For the
	// VERIFICATION_STATE_VERIFIED status, it is allowed only to add/remove Call Reaons and Phone Numbers.
	//  For the other statuses, all fields can be updated. All existing Call Reasons and Phone Numbers
	// must be sent during the request, or the update will fail.
	//
	// PATCH /verified_calls_display_profiles/{id}
	UpdateProfile(ctx context.Context, request *UpdateVerifiedCallsDisplayProfileRequest, params UpdateProfileParams) (UpdateProfileRes, error)
	// UpdateTeXMLCallRecording invokes UpdateTeXMLCallRecording operation.
	//
	// Updates recording resource for particular call.
	//
	// POST /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings/{recording_sid}.json
	UpdateTeXMLCallRecording(ctx context.Context, request OptTexmlUpdateCallRecordingRequestBody, params UpdateTeXMLCallRecordingParams) (UpdateTeXMLCallRecordingRes, error)
	// UpdateTelephonyCredential invokes UpdateTelephonyCredential operation.
	//
	// Update an existing credential.
	//
	// PATCH /telephony_credentials/{id}
	UpdateTelephonyCredential(ctx context.Context, request *TelephonyCredentialUpdateRequest, params UpdateTelephonyCredentialParams) (UpdateTelephonyCredentialRes, error)
	// UpdateTexmlApplication invokes UpdateTexmlApplication operation.
	//
	// Updates settings of an existing TeXML Application.
	//
	// PATCH /texml_applications/{id}
	UpdateTexmlApplication(ctx context.Context, request *UpdateTexmlApplicationRequest, params UpdateTexmlApplicationParams) (UpdateTexmlApplicationRes, error)
	// UpdateTexmlCall invokes UpdateTexmlCall operation.
	//
	// Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase
	// as specified in the example.
	//
	// POST /texml/calls/{call_sid}/update
	UpdateTexmlCall(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallParams) (*UpdateTeXMLCallResponse, error)
	// UpdateTexmlCallByAccount invokes UpdateTexmlCallByAccount operation.
	//
	// Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase
	// as specified in the example.
	//
	// POST /texml/Accounts/{account_sid}/Calls/{call_sid}
	UpdateTexmlCallByAccount(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallByAccountParams) (*GetCallResponse, error)
	// UpdateTexmlConference invokes UpdateTexmlConference operation.
	//
	// Updates a conference resource.
	//
	// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}
	UpdateTexmlConference(ctx context.Context, request *UpdateConferenceRequest, params UpdateTexmlConferenceParams) (UpdateTexmlConferenceRes, error)
	// UpdateTexmlConferenceParticipant invokes UpdateTexmlConferenceParticipant operation.
	//
	// Updates a conference participant.
	//
	// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
	UpdateTexmlConferenceParticipant(ctx context.Context, request *UpdateConferenceParticipantRequest, params UpdateTexmlConferenceParticipantParams) (UpdateTexmlConferenceParticipantRes, error)
	// UpdateVerifyProfile invokes UpdateVerifyProfile operation.
	//
	// Update Verify profile.
	//
	// PATCH /verify_profiles/{verify_profile_id}
	UpdateVerifyProfile(ctx context.Context, request *UpdateVerifyProfileReq, params UpdateVerifyProfileParams) (UpdateVerifyProfileRes, error)
	// VerifyVerificationCode invokes VerifyVerificationCode operation.
	//
	// Submit verification code.
	//
	// POST /verified_numbers/{phone_number}/actions/verify
	VerifyVerificationCode(ctx context.Context, request *VerifyVerificationCodeReq, params VerifyVerificationCodeParams) (VerifyVerificationCodeRes, error)
	// VerifyVerificationCodeByPhoneNumber invokes VerifyVerificationCodeByPhoneNumber operation.
	//
	// Submit verification code.
	//
	// POST /verifications/by_phone_number/{phone_number}/actions/verify
	VerifyVerificationCodeByPhoneNumber(ctx context.Context, request *VerifyVerificationCodeRequest, params VerifyVerificationCodeByPhoneNumberParams) (VerifyVerificationCodeByPhoneNumberRes, error)
	// ViewRoomRecording invokes ViewRoomRecording operation.
	//
	// View a room recording.
	//
	// GET /room_recordings/{room_recording_id}
	ViewRoomRecording(ctx context.Context, params ViewRoomRecordingParams) (ViewRoomRecordingRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AnswerCall invokes AnswerCall operation.
//
// Answer an incoming call. You must issue this command before executing subsequent commands on an
// incoming call.
// **Expected Webhooks:**
// - `call.answered`
// - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set.
//
// POST /calls/{call_control_id}/actions/answer
func (c *Client) AnswerCall(ctx context.Context, request *AnswerRequest, params AnswerCallParams) (AnswerCallRes, error) {
	res, err := c.sendAnswerCall(ctx, request, params)
	return res, err
}

func (c *Client) sendAnswerCall(ctx context.Context, request *AnswerRequest, params AnswerCallParams) (res AnswerCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/answer"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnswerCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "AnswerCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAnswerCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AssignPhoneNumber invokes AssignPhoneNumber operation.
//
// You should own the phone number being assigned to the channel zone. Remember that you should
// reserve channels in this channel zone, otherwise you won't be able to receive incoming calls.
//
// POST /channel_zones/{channel_zone_id}/channel_zone_phone_numbers
func (c *Client) AssignPhoneNumber(ctx context.Context, request *AssignPhoneNumberReq, params AssignPhoneNumberParams) (AssignPhoneNumberRes, error) {
	res, err := c.sendAssignPhoneNumber(ctx, request, params)
	return res, err
}

func (c *Client) sendAssignPhoneNumber(ctx context.Context, request *AssignPhoneNumberReq, params AssignPhoneNumberParams) (res AssignPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channel_zones/"
	{
		// Encode "channel_zone_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_zone_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChannelZoneID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/channel_zone_phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAssignPhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "AssignPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAssignPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AudioPublicAudioTranscriptionsPost invokes audio_public_audio_transcriptions_post operation.
//
// Transcribe speech to text. This endpoint is consistent with the [OpenAI Transcription
// API](https://platform.openai.com/docs/api-reference/audio/createTranscription) and may be used
// with the OpenAI JS or Python SDK.
//
// POST /ai/audio/transcriptions
func (c *Client) AudioPublicAudioTranscriptionsPost(ctx context.Context, request *AudioTranscriptionRequestMultipart) (AudioPublicAudioTranscriptionsPostRes, error) {
	res, err := c.sendAudioPublicAudioTranscriptionsPost(ctx, request)
	return res, err
}

func (c *Client) sendAudioPublicAudioTranscriptionsPost(ctx context.Context, request *AudioTranscriptionRequestMultipart) (res AudioPublicAudioTranscriptionsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ai/audio/transcriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAudioPublicAudioTranscriptionsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "AudioPublicAudioTranscriptionsPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAudioPublicAudioTranscriptionsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BridgeCall invokes BridgeCall operation.
//
// Bridge two call control calls.
// **Expected Webhooks:**
// - `call.bridged` for Leg A
// - `call.bridged` for Leg B.
//
// POST /calls/{call_control_id}/actions/bridge
func (c *Client) BridgeCall(ctx context.Context, request *BridgeRequest, params BridgeCallParams) (BridgeCallRes, error) {
	res, err := c.sendBridgeCall(ctx, request, params)
	return res, err
}

func (c *Client) sendBridgeCall(ctx context.Context, request *BridgeRequest, params BridgeCallParams) (res BridgeCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/bridge"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBridgeCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "BridgeCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBridgeCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BulkCredentialAction invokes BulkCredentialAction operation.
//
// Perform activate or deactivate action on all credentials filtered by the provided tag. Activate
// action will change the status to active, making it possible to connect calls with the credential.
// Deactivate action will change the status to inactive, making it impossible to connect calls with
// the credential.
//
// POST /actions/{action}/telephony_credentials
func (c *Client) BulkCredentialAction(ctx context.Context, params BulkCredentialActionParams) (BulkCredentialActionRes, error) {
	res, err := c.sendBulkCredentialAction(ctx, params)
	return res, err
}

func (c *Client) sendBulkCredentialAction(ctx context.Context, params BulkCredentialActionParams) (res BulkCredentialActionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/actions/"
	{
		// Encode "action" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "action",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Action)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilterTag))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "BulkCredentialAction", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBulkCredentialActionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateBulkTelephonyCredentials invokes CreateBulkTelephonyCredentials operation.
//
// Creates several credentials in bulk.
//
// POST /actions/bulk/telephony_credentials
func (c *Client) CreateBulkTelephonyCredentials(ctx context.Context, request *BulkCredentialRequest) (CreateBulkTelephonyCredentialsRes, error) {
	res, err := c.sendCreateBulkTelephonyCredentials(ctx, request)
	return res, err
}

func (c *Client) sendCreateBulkTelephonyCredentials(ctx context.Context, request *BulkCredentialRequest) (res CreateBulkTelephonyCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/actions/bulk/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBulkTelephonyCredentialsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateBulkTelephonyCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateBulkTelephonyCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCallControlApplication invokes CreateCallControlApplication operation.
//
// Create a call control application.
//
// POST /call_control_applications
func (c *Client) CreateCallControlApplication(ctx context.Context, request *CreateCallControlApplicationRequest) (CreateCallControlApplicationRes, error) {
	res, err := c.sendCreateCallControlApplication(ctx, request)
	return res, err
}

func (c *Client) sendCreateCallControlApplication(ctx context.Context, request *CreateCallControlApplicationRequest) (res CreateCallControlApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/call_control_applications"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCallControlApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateCallControlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCallControlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCsvDownload invokes CreateCsvDownload operation.
//
// Create a CSV download.
//
// POST /phone_numbers/csv_downloads
func (c *Client) CreateCsvDownload(ctx context.Context) (CreateCsvDownloadRes, error) {
	res, err := c.sendCreateCsvDownload(ctx)
	return res, err
}

func (c *Client) sendCreateCsvDownload(ctx context.Context) (res CreateCsvDownloadRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/csv_downloads"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateCsvDownload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCsvDownloadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCustomStorageCredentials invokes CreateCustomStorageCredentials operation.
//
// Creates a custom storage credentials configuration.
//
// POST /custom_storage_credentials/{connection_id}
func (c *Client) CreateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params CreateCustomStorageCredentialsParams) (CreateCustomStorageCredentialsRes, error) {
	res, err := c.sendCreateCustomStorageCredentials(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params CreateCustomStorageCredentialsParams) (res CreateCustomStorageCredentialsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/custom_storage_credentials/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCustomStorageCredentialsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateCustomStorageCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateCustomStorageCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDefaultGateway invokes CreateDefaultGateway operation.
//
// Create Default Gateway.
//
// POST /networks/{id}/default_gateway
func (c *Client) CreateDefaultGateway(ctx context.Context, request *DefaultGateway, params CreateDefaultGatewayParams) (CreateDefaultGatewayRes, error) {
	res, err := c.sendCreateDefaultGateway(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDefaultGateway(ctx context.Context, request *DefaultGateway, params CreateDefaultGatewayParams) (res CreateDefaultGatewayRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/networks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/default_gateway"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDefaultGatewayRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateDefaultGateway", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDefaultGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDeletePhoneNumbersJob invokes CreateDeletePhoneNumbersJob operation.
//
// Creates a new background job to delete a batch of numbers. At most one thousand numbers can be
// updated per API call.
//
// POST /phone_numbers/jobs/delete_phone_numbers
func (c *Client) CreateDeletePhoneNumbersJob(ctx context.Context, request *PhoneNumbersJobDeletePhoneNumbersRequest) (CreateDeletePhoneNumbersJobRes, error) {
	res, err := c.sendCreateDeletePhoneNumbersJob(ctx, request)
	return res, err
}

func (c *Client) sendCreateDeletePhoneNumbersJob(ctx context.Context, request *PhoneNumbersJobDeletePhoneNumbersRequest) (res CreateDeletePhoneNumbersJobRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/jobs/delete_phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDeletePhoneNumbersJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateDeletePhoneNumbersJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDeletePhoneNumbersJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateFlashcallVerification invokes CreateFlashcallVerification operation.
//
// Trigger Flash call verification.
//
// POST /verifications/flashcall
func (c *Client) CreateFlashcallVerification(ctx context.Context, request *CreateVerificationRequestFlashcall) (CreateFlashcallVerificationRes, error) {
	res, err := c.sendCreateFlashcallVerification(ctx, request)
	return res, err
}

func (c *Client) sendCreateFlashcallVerification(ctx context.Context, request *CreateVerificationRequestFlashcall) (res CreateFlashcallVerificationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verifications/flashcall"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateFlashcallVerificationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateFlashcallVerification", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateFlashcallVerificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateGroupMmsMessage invokes CreateGroupMmsMessage operation.
//
// Send a group MMS message.
//
// POST /messages/group_mms
func (c *Client) CreateGroupMmsMessage(ctx context.Context, request OptCreateGroupMMSMessageRequest) (CreateGroupMmsMessageRes, error) {
	res, err := c.sendCreateGroupMmsMessage(ctx, request)
	return res, err
}

func (c *Client) sendCreateGroupMmsMessage(ctx context.Context, request OptCreateGroupMMSMessageRequest) (res CreateGroupMmsMessageRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messages/group_mms"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateGroupMmsMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateGroupMmsMessage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateGroupMmsMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateLongCodeMessage invokes CreateLongCodeMessage operation.
//
// Send a long code message.
//
// POST /messages/long_code
func (c *Client) CreateLongCodeMessage(ctx context.Context, request OptCreateLongCodeMessageRequest) (CreateLongCodeMessageRes, error) {
	res, err := c.sendCreateLongCodeMessage(ctx, request)
	return res, err
}

func (c *Client) sendCreateLongCodeMessage(ctx context.Context, request OptCreateLongCodeMessageRequest) (res CreateLongCodeMessageRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messages/long_code"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateLongCodeMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateLongCodeMessage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateLongCodeMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateMessagingHostedNumberOrder invokes CreateMessagingHostedNumberOrder operation.
//
// Create a messaging hosted number order.
//
// POST /messaging_hosted_number_orders
func (c *Client) CreateMessagingHostedNumberOrder(ctx context.Context, request OptCreateMessagingHostedNumberOrderRequest) (CreateMessagingHostedNumberOrderRes, error) {
	res, err := c.sendCreateMessagingHostedNumberOrder(ctx, request)
	return res, err
}

func (c *Client) sendCreateMessagingHostedNumberOrder(ctx context.Context, request OptCreateMessagingHostedNumberOrderRequest) (res CreateMessagingHostedNumberOrderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messaging_hosted_number_orders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateMessagingHostedNumberOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateMessagingHostedNumberOrder", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateMessagingHostedNumberOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNetwork invokes CreateNetwork operation.
//
// Create a new Network.
//
// POST /networks
func (c *Client) CreateNetwork(ctx context.Context, request *NetworkCreate) (CreateNetworkRes, error) {
	res, err := c.sendCreateNetwork(ctx, request)
	return res, err
}

func (c *Client) sendCreateNetwork(ctx context.Context, request *NetworkCreate) (res CreateNetworkRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/networks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNetworkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNotificationChannels invokes CreateNotificationChannels operation.
//
// Create a notification channel.
//
// POST /notification_channels
func (c *Client) CreateNotificationChannels(ctx context.Context, request OptNotificationChannel) (CreateNotificationChannelsRes, error) {
	res, err := c.sendCreateNotificationChannels(ctx, request)
	return res, err
}

func (c *Client) sendCreateNotificationChannels(ctx context.Context, request OptNotificationChannel) (res CreateNotificationChannelsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/notification_channels"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNotificationChannelsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateNotificationChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateNotificationChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNumberPoolMessage invokes CreateNumberPoolMessage operation.
//
// Send a message using number pool.
//
// POST /messages/number_pool
func (c *Client) CreateNumberPoolMessage(ctx context.Context, request OptCreateNumberPoolMessageRequest) (CreateNumberPoolMessageRes, error) {
	res, err := c.sendCreateNumberPoolMessage(ctx, request)
	return res, err
}

func (c *Client) sendCreateNumberPoolMessage(ctx context.Context, request OptCreateNumberPoolMessageRequest) (res CreateNumberPoolMessageRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messages/number_pool"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNumberPoolMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateNumberPoolMessage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateNumberPoolMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePhoneNumbersJobUpdateEmergencySettings invokes CreatePhoneNumbersJobUpdateEmergencySettings operation.
//
// Creates a background job to update the emergency settings of a collection of phone numbers. At
// most one thousand numbers can be updated per API call.
//
// POST /phone_numbers/jobs/update_emergency_settings
func (c *Client) CreatePhoneNumbersJobUpdateEmergencySettings(ctx context.Context, request *PhoneNumbersJobUpdateEmergencySettingsRequest) (CreatePhoneNumbersJobUpdateEmergencySettingsRes, error) {
	res, err := c.sendCreatePhoneNumbersJobUpdateEmergencySettings(ctx, request)
	return res, err
}

func (c *Client) sendCreatePhoneNumbersJobUpdateEmergencySettings(ctx context.Context, request *PhoneNumbersJobUpdateEmergencySettingsRequest) (res CreatePhoneNumbersJobUpdateEmergencySettingsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/jobs/update_emergency_settings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePhoneNumbersJobUpdateEmergencySettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreatePhoneNumbersJobUpdateEmergencySettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreatePhoneNumbersJobUpdateEmergencySettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProfile invokes CreateProfile operation.
//
// Creates a Verified Calls Display Profile associated with the given Business Identity.
//
// POST /verified_calls_display_profiles
func (c *Client) CreateProfile(ctx context.Context, request *CreateVerifiedCallsDisplayProfileRequest) (CreateProfileRes, error) {
	res, err := c.sendCreateProfile(ctx, request)
	return res, err
}

func (c *Client) sendCreateProfile(ctx context.Context, request *CreateVerifiedCallsDisplayProfileRequest) (res CreateProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verified_calls_display_profiles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProfileVerificationRequest invokes CreateProfileVerificationRequest operation.
//
// Starts a new Verified Calls Display Profile verification process.
//
// POST /verified_calls_display_profiles/{id}/verification_request
func (c *Client) CreateProfileVerificationRequest(ctx context.Context, params CreateProfileVerificationRequestParams) (CreateProfileVerificationRequestRes, error) {
	res, err := c.sendCreateProfileVerificationRequest(ctx, params)
	return res, err
}

func (c *Client) sendCreateProfileVerificationRequest(ctx context.Context, params CreateProfileVerificationRequestParams) (res CreateProfileVerificationRequestRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/verified_calls_display_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/verification_request"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateProfileVerificationRequest", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateProfileVerificationRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateShortCodeMessage invokes CreateShortCodeMessage operation.
//
// Send a short code message.
//
// POST /messages/short_code
func (c *Client) CreateShortCodeMessage(ctx context.Context, request OptCreateShortCodeMessageRequest) (CreateShortCodeMessageRes, error) {
	res, err := c.sendCreateShortCodeMessage(ctx, request)
	return res, err
}

func (c *Client) sendCreateShortCodeMessage(ctx context.Context, request OptCreateShortCodeMessageRequest) (res CreateShortCodeMessageRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messages/short_code"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateShortCodeMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateShortCodeMessage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateShortCodeMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTelephonyCredential invokes CreateTelephonyCredential operation.
//
// Create a credential.
//
// POST /telephony_credentials
func (c *Client) CreateTelephonyCredential(ctx context.Context, request *TelephonyCredentialCreateRequest) (CreateTelephonyCredentialRes, error) {
	res, err := c.sendCreateTelephonyCredential(ctx, request)
	return res, err
}

func (c *Client) sendCreateTelephonyCredential(ctx context.Context, request *TelephonyCredentialCreateRequest) (res CreateTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTelephonyCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTelephonyCredentialToken invokes CreateTelephonyCredentialToken operation.
//
// Create an Access Token (JWT) for the credential.
//
// POST /telephony_credentials/{id}/token
func (c *Client) CreateTelephonyCredentialToken(ctx context.Context, params CreateTelephonyCredentialTokenParams) (CreateTelephonyCredentialTokenRes, error) {
	res, err := c.sendCreateTelephonyCredentialToken(ctx, params)
	return res, err
}

func (c *Client) sendCreateTelephonyCredentialToken(ctx context.Context, params CreateTelephonyCredentialTokenParams) (res CreateTelephonyCredentialTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateTelephonyCredentialToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTelephonyCredentialTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTexmlApplication invokes CreateTexmlApplication operation.
//
// Creates a TeXML Application.
//
// POST /texml_applications
func (c *Client) CreateTexmlApplication(ctx context.Context, request *CreateTexmlApplicationRequest) (CreateTexmlApplicationRes, error) {
	res, err := c.sendCreateTexmlApplication(ctx, request)
	return res, err
}

func (c *Client) sendCreateTexmlApplication(ctx context.Context, request *CreateTexmlApplicationRequest) (res CreateTexmlApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/texml_applications"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTexmlApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateTexmlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTexmlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTexmlSecret invokes CreateTexmlSecret operation.
//
// Create a TeXML secret which can be later used as a Dynamic Parameter for TeXML when using Mustache
// Templates in your TeXML. In your TeXML you will be able to use your secret name, and this name
// will be replaced by the actual secret value when processing the TeXML on Telnyx side.  The secrets
// are not visible in any logs.
//
// POST /texml/secrets
func (c *Client) CreateTexmlSecret(ctx context.Context, request *CreateTeXMLSecretRequest) (CreateTexmlSecretRes, error) {
	res, err := c.sendCreateTexmlSecret(ctx, request)
	return res, err
}

func (c *Client) sendCreateTexmlSecret(ctx context.Context, request *CreateTeXMLSecretRequest) (res CreateTexmlSecretRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/texml/secrets"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTexmlSecretRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateTexmlSecret", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTexmlSecretResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateUpdatePhoneNumbersJob invokes CreateUpdatePhoneNumbersJob operation.
//
// Creates a new background job to update a batch of numbers. At most one thousand numbers can be
// updated per API call. At least one of the updateable fields must be submitted.
//
// POST /phone_numbers/jobs/update_phone_numbers
func (c *Client) CreateUpdatePhoneNumbersJob(ctx context.Context, request *PhoneNumbersJobUpdatePhoneNumbersRequest) (CreateUpdatePhoneNumbersJobRes, error) {
	res, err := c.sendCreateUpdatePhoneNumbersJob(ctx, request)
	return res, err
}

func (c *Client) sendCreateUpdatePhoneNumbersJob(ctx context.Context, request *PhoneNumbersJobUpdatePhoneNumbersRequest) (res CreateUpdatePhoneNumbersJobRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/jobs/update_phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateUpdatePhoneNumbersJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateUpdatePhoneNumbersJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateUpdatePhoneNumbersJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerificationCall invokes CreateVerificationCall operation.
//
// Trigger Call verification.
//
// POST /verifications/call
func (c *Client) CreateVerificationCall(ctx context.Context, request *CreateVerificationRequestCall) (CreateVerificationCallRes, error) {
	res, err := c.sendCreateVerificationCall(ctx, request)
	return res, err
}

func (c *Client) sendCreateVerificationCall(ctx context.Context, request *CreateVerificationRequestCall) (res CreateVerificationCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verifications/call"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVerificationCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVerificationCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerificationCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerificationSms invokes CreateVerificationSms operation.
//
// Trigger SMS verification.
//
// POST /verifications/sms
func (c *Client) CreateVerificationSms(ctx context.Context, request *CreateVerificationRequestSMS) (CreateVerificationSmsRes, error) {
	res, err := c.sendCreateVerificationSms(ctx, request)
	return res, err
}

func (c *Client) sendCreateVerificationSms(ctx context.Context, request *CreateVerificationRequestSMS) (res CreateVerificationSmsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verifications/sms"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVerificationSmsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVerificationSms", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerificationSmsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerifiedNumber invokes CreateVerifiedNumber operation.
//
// Initiates phone number verification procedure.
//
// POST /verified_numbers
func (c *Client) CreateVerifiedNumber(ctx context.Context, request *CreateVerifiedNumberReq) (CreateVerifiedNumberRes, error) {
	res, err := c.sendCreateVerifiedNumber(ctx, request)
	return res, err
}

func (c *Client) sendCreateVerifiedNumber(ctx context.Context, request *CreateVerifiedNumberReq) (res CreateVerifiedNumberRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verified_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVerifiedNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVerifiedNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerifiedNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerifyProfile invokes CreateVerifyProfile operation.
//
// Creates a new Verify profile to associate verifications with.
//
// POST /verify_profiles
func (c *Client) CreateVerifyProfile(ctx context.Context, request *CreateVerifyProfileReq) (CreateVerifyProfileRes, error) {
	res, err := c.sendCreateVerifyProfile(ctx, request)
	return res, err
}

func (c *Client) sendCreateVerifyProfile(ctx context.Context, request *CreateVerifyProfileReq) (res CreateVerifyProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verify_profiles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVerifyProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVerifyProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerifyProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCallControlApplication invokes DeleteCallControlApplication operation.
//
// Deletes a call control application.
//
// DELETE /call_control_applications/{id}
func (c *Client) DeleteCallControlApplication(ctx context.Context, params DeleteCallControlApplicationParams) (DeleteCallControlApplicationRes, error) {
	res, err := c.sendDeleteCallControlApplication(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCallControlApplication(ctx context.Context, params DeleteCallControlApplicationParams) (res DeleteCallControlApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/call_control_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteCallControlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCallControlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCustomStorageCredentials invokes DeleteCustomStorageCredentials operation.
//
// Deletes a stored custom credentials configuration.
//
// DELETE /custom_storage_credentials/{connection_id}
func (c *Client) DeleteCustomStorageCredentials(ctx context.Context, params DeleteCustomStorageCredentialsParams) (DeleteCustomStorageCredentialsRes, error) {
	res, err := c.sendDeleteCustomStorageCredentials(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCustomStorageCredentials(ctx context.Context, params DeleteCustomStorageCredentialsParams) (res DeleteCustomStorageCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/custom_storage_credentials/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteCustomStorageCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteCustomStorageCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDefaultGateway invokes DeleteDefaultGateway operation.
//
// Delete Default Gateway.
//
// DELETE /networks/{id}/default_gateway
func (c *Client) DeleteDefaultGateway(ctx context.Context, params DeleteDefaultGatewayParams) (DeleteDefaultGatewayRes, error) {
	res, err := c.sendDeleteDefaultGateway(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDefaultGateway(ctx context.Context, params DeleteDefaultGatewayParams) (res DeleteDefaultGatewayRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/networks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/default_gateway"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteDefaultGateway", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDefaultGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteExternalConnectionLogMessage invokes DeleteExternalConnectionLogMessage operation.
//
// Dismiss a log message for an external connection associated with your account.
//
// DELETE /external_connections/log_messages/{id}
func (c *Client) DeleteExternalConnectionLogMessage(ctx context.Context, params DeleteExternalConnectionLogMessageParams) (DeleteExternalConnectionLogMessageRes, error) {
	res, err := c.sendDeleteExternalConnectionLogMessage(ctx, params)
	return res, err
}

func (c *Client) sendDeleteExternalConnectionLogMessage(ctx context.Context, params DeleteExternalConnectionLogMessageParams) (res DeleteExternalConnectionLogMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/external_connections/log_messages/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteExternalConnectionLogMessage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteExternalConnectionLogMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteNetwork invokes DeleteNetwork operation.
//
// Delete a Network.
//
// DELETE /networks/{id}
func (c *Client) DeleteNetwork(ctx context.Context, params DeleteNetworkParams) (DeleteNetworkRes, error) {
	res, err := c.sendDeleteNetwork(ctx, params)
	return res, err
}

func (c *Client) sendDeleteNetwork(ctx context.Context, params DeleteNetworkParams) (res DeleteNetworkRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/networks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteNotificationChannel invokes DeleteNotificationChannel operation.
//
// Delete a notification channel.
//
// DELETE /notification_channels/{id}
func (c *Client) DeleteNotificationChannel(ctx context.Context, params DeleteNotificationChannelParams) (DeleteNotificationChannelRes, error) {
	res, err := c.sendDeleteNotificationChannel(ctx, params)
	return res, err
}

func (c *Client) sendDeleteNotificationChannel(ctx context.Context, params DeleteNotificationChannelParams) (res DeleteNotificationChannelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/notification_channels/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteNotificationChannel", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNotificationChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePhoneNumber invokes DeletePhoneNumber operation.
//
// Delete a phone number.
//
// DELETE /phone_numbers/{id}
func (c *Client) DeletePhoneNumber(ctx context.Context, params DeletePhoneNumberParams) (DeletePhoneNumberRes, error) {
	res, err := c.sendDeletePhoneNumber(ctx, params)
	return res, err
}

func (c *Client) sendDeletePhoneNumber(ctx context.Context, params DeletePhoneNumberParams) (res DeletePhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone_numbers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeletePhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeletePhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProfile invokes DeleteProfile operation.
//
// Delete Verify profile.
//
// DELETE /verify_profiles/{verify_profile_id}
func (c *Client) DeleteProfile(ctx context.Context, params DeleteProfileParams) (DeleteProfileRes, error) {
	res, err := c.sendDeleteProfile(ctx, params)
	return res, err
}

func (c *Client) sendDeleteProfile(ctx context.Context, params DeleteProfileParams) (res DeleteProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verify_profiles/"
	{
		// Encode "verify_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "verify_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VerifyProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRecording invokes DeleteRecording operation.
//
// Permanently deletes a call recording.
//
// DELETE /recordings/{recording_id}
func (c *Client) DeleteRecording(ctx context.Context, params DeleteRecordingParams) (DeleteRecordingRes, error) {
	res, err := c.sendDeleteRecording(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRecording(ctx context.Context, params DeleteRecordingParams) (res DeleteRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/recordings/"
	{
		// Encode "recording_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRecordingTranscription invokes deleteRecordingTranscription operation.
//
// Permanently deletes a recording transcription.
//
// DELETE /recording_transcriptions/{recording_transcription_id}
func (c *Client) DeleteRecordingTranscription(ctx context.Context, params DeleteRecordingTranscriptionParams) (DeleteRecordingTranscriptionRes, error) {
	res, err := c.sendDeleteRecordingTranscription(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRecordingTranscription(ctx context.Context, params DeleteRecordingTranscriptionParams) (res DeleteRecordingTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/recording_transcriptions/"
	{
		// Encode "recording_transcription_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_transcription_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingTranscriptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRecordingTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRecordingTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRecordings invokes DeleteRecordings operation.
//
// Permanently deletes a list of call recordings.
//
// DELETE /recordings/actions/delete
func (c *Client) DeleteRecordings(ctx context.Context, request []string) (DeleteRecordingsRes, error) {
	res, err := c.sendDeleteRecordings(ctx, request)
	return res, err
}

func (c *Client) sendDeleteRecordings(ctx context.Context, request []string) (res DeleteRecordingsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if request == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/recordings/actions/delete"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteRecordingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRoomRecording invokes DeleteRoomRecording operation.
//
// Synchronously delete a Room Recording.
//
// DELETE /room_recordings/{room_recording_id}
func (c *Client) DeleteRoomRecording(ctx context.Context, params DeleteRoomRecordingParams) (DeleteRoomRecordingRes, error) {
	res, err := c.sendDeleteRoomRecording(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRoomRecording(ctx context.Context, params DeleteRoomRecordingParams) (res DeleteRoomRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/room_recordings/"
	{
		// Encode "room_recording_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "room_recording_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RoomRecordingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRoomRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRoomRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRoomRecordings invokes DeleteRoomRecordings operation.
//
// Delete several room recordings in a bulk.
//
// DELETE /room_recordings
func (c *Client) DeleteRoomRecordings(ctx context.Context, params DeleteRoomRecordingsParams) (DeleteRoomRecordingsRes, error) {
	res, err := c.sendDeleteRoomRecordings(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRoomRecordings(ctx context.Context, params DeleteRoomRecordingsParams) (res DeleteRoomRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/room_recordings"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[date_ended_at][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtEq.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_ended_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_ended_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtEq.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[room_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[room_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterRoomID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[participant_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[participant_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterParticipantID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[session_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[session_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterSessionID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[type]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsEq.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsLte.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsGte.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRoomRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRoomRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTeXMLCallRecording invokes DeleteTeXMLCallRecording operation.
//
// Deletes recording resource identified by recording id.
//
// DELETE /texml/Accounts/{account_sid}/Recordings/{recording_sid}.json
func (c *Client) DeleteTeXMLCallRecording(ctx context.Context, params DeleteTeXMLCallRecordingParams) (DeleteTeXMLCallRecordingRes, error) {
	res, err := c.sendDeleteTeXMLCallRecording(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTeXMLCallRecording(ctx context.Context, params DeleteTeXMLCallRecordingParams) (res DeleteTeXMLCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Recordings/"
	{
		// Encode "recording_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTeXMLCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTeXMLCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTeXMLRecordingTranscription invokes DeleteTeXMLRecordingTranscription operation.
//
// Permanently deletes a recording transcription.
//
// DELETE /texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json
func (c *Client) DeleteTeXMLRecordingTranscription(ctx context.Context, params DeleteTeXMLRecordingTranscriptionParams) (DeleteTeXMLRecordingTranscriptionRes, error) {
	res, err := c.sendDeleteTeXMLRecordingTranscription(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTeXMLRecordingTranscription(ctx context.Context, params DeleteTeXMLRecordingTranscriptionParams) (res DeleteTeXMLRecordingTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Transcriptions/"
	{
		// Encode "recording_transcription_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_transcription_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingTranscriptionSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTeXMLRecordingTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTeXMLRecordingTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTelephonyCredential invokes DeleteTelephonyCredential operation.
//
// Delete an existing credential.
//
// DELETE /telephony_credentials/{id}
func (c *Client) DeleteTelephonyCredential(ctx context.Context, params DeleteTelephonyCredentialParams) (DeleteTelephonyCredentialRes, error) {
	res, err := c.sendDeleteTelephonyCredential(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTelephonyCredential(ctx context.Context, params DeleteTelephonyCredentialParams) (res DeleteTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTelephonyCredentials invokes DeleteTelephonyCredentials operation.
//
// Delete several credentials in bulk.
//
// DELETE /actions/bulk/telephony_credentials
func (c *Client) DeleteTelephonyCredentials(ctx context.Context, params DeleteTelephonyCredentialsParams) (DeleteTelephonyCredentialsRes, error) {
	res, err := c.sendDeleteTelephonyCredentials(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTelephonyCredentials(ctx context.Context, params DeleteTelephonyCredentialsParams) (res DeleteTelephonyCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/actions/bulk/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilterTag))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTelephonyCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTelephonyCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTexmlApplication invokes DeleteTexmlApplication operation.
//
// Deletes a TeXML Application.
//
// DELETE /texml_applications/{id}
func (c *Client) DeleteTexmlApplication(ctx context.Context, params DeleteTexmlApplicationParams) (DeleteTexmlApplicationRes, error) {
	res, err := c.sendDeleteTexmlApplication(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTexmlApplication(ctx context.Context, params DeleteTexmlApplicationParams) (res DeleteTexmlApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/texml_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTexmlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTexmlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTexmlConferenceParticipant invokes DeleteTexmlConferenceParticipant operation.
//
// Deletes a conference participant.
//
// DELETE /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
func (c *Client) DeleteTexmlConferenceParticipant(ctx context.Context, params DeleteTexmlConferenceParticipantParams) (DeleteTexmlConferenceParticipantRes, error) {
	res, err := c.sendDeleteTexmlConferenceParticipant(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTexmlConferenceParticipant(ctx context.Context, params DeleteTexmlConferenceParticipantParams) (res DeleteTexmlConferenceParticipantRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteTexmlConferenceParticipant", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTexmlConferenceParticipantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVerifiedCallDisplayProfile invokes DeleteVerifiedCallDisplayProfile operation.
//
// Deletes the Verified Calls Display Profile. This action will fail if any verification requests
// have been made for this Verified Calls Display Profile. Please contact support@telnyx.com in case
// you want to delete a Verified Calls Display Profile in that situation.
//
// DELETE /verified_calls_display_profiles/{id}
func (c *Client) DeleteVerifiedCallDisplayProfile(ctx context.Context, params DeleteVerifiedCallDisplayProfileParams) (DeleteVerifiedCallDisplayProfileRes, error) {
	res, err := c.sendDeleteVerifiedCallDisplayProfile(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVerifiedCallDisplayProfile(ctx context.Context, params DeleteVerifiedCallDisplayProfileParams) (res DeleteVerifiedCallDisplayProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_calls_display_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteVerifiedCallDisplayProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVerifiedCallDisplayProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVerifiedNumber invokes DeleteVerifiedNumber operation.
//
// Delete a verified number.
//
// DELETE /verified_numbers/{phone_number}
func (c *Client) DeleteVerifiedNumber(ctx context.Context, params DeleteVerifiedNumberParams) (DeleteVerifiedNumberRes, error) {
	res, err := c.sendDeleteVerifiedNumber(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVerifiedNumber(ctx context.Context, params DeleteVerifiedNumberParams) (res DeleteVerifiedNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_numbers/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteVerifiedNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVerifiedNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DialCall invokes DialCall operation.
//
// Dial a number or SIP URI from a given connection. A successful response will include a
// `call_leg_id` which can be used to correlate the command with subsequent webhooks.
// **Expected Webhooks:**
// - `call.initiated`
// - `call.answered` or `call.hangup`
// - `call.machine.detection.ended` if `answering_machine_detection` was requested
// - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end
// of machine greeting
// - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
// - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and
// a beep was detected
// - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set.
//
// POST /calls
func (c *Client) DialCall(ctx context.Context, request *CallRequest) (DialCallRes, error) {
	res, err := c.sendDialCall(ctx, request)
	return res, err
}

func (c *Client) sendDialCall(ctx context.Context, request *CallRequest) (res DialCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/calls"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDialCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DialCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDialCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DialTexmlConferenceParticipant invokes DialTexmlConferenceParticipant operation.
//
// Dials a new conference participant.
//
// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants
func (c *Client) DialTexmlConferenceParticipant(ctx context.Context, request *DialConferenceParticipantRequest, params DialTexmlConferenceParticipantParams) (DialTexmlConferenceParticipantRes, error) {
	res, err := c.sendDialTexmlConferenceParticipant(ctx, request, params)
	return res, err
}

func (c *Client) sendDialTexmlConferenceParticipant(ctx context.Context, request *DialConferenceParticipantRequest, params DialTexmlConferenceParticipantParams) (res DialTexmlConferenceParticipantRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDialTexmlConferenceParticipantRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DialTexmlConferenceParticipant", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDialTexmlConferenceParticipantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DisplayProfile invokes DisplayProfile operation.
//
// Display the Verified Calls Display Profile.
//
// GET /verified_calls_display_profiles/{id}
func (c *Client) DisplayProfile(ctx context.Context, params DisplayProfileParams) (DisplayProfileRes, error) {
	res, err := c.sendDisplayProfile(ctx, params)
	return res, err
}

func (c *Client) sendDisplayProfile(ctx context.Context, params DisplayProfileParams) (res DisplayProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_calls_display_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DisplayProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDisplayProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnablePhoneNumberEmergency invokes EnablePhoneNumberEmergency operation.
//
// Enable emergency for a phone number.
//
// POST /phone_numbers/{id}/actions/enable_emergency
func (c *Client) EnablePhoneNumberEmergency(ctx context.Context, request *PhoneNumberEnableEmergencyRequest, params EnablePhoneNumberEmergencyParams) (EnablePhoneNumberEmergencyRes, error) {
	res, err := c.sendEnablePhoneNumberEmergency(ctx, request, params)
	return res, err
}

func (c *Client) sendEnablePhoneNumberEmergency(ctx context.Context, request *PhoneNumberEnableEmergencyRequest, params EnablePhoneNumberEmergencyParams) (res EnablePhoneNumberEmergencyRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone_numbers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enable_emergency"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnablePhoneNumberEmergencyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "EnablePhoneNumberEmergency", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnablePhoneNumberEmergencyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnqueueCall invokes EnqueueCall operation.
//
// Put the call in a queue.
//
// POST /calls/{call_control_id}/actions/enqueue
func (c *Client) EnqueueCall(ctx context.Context, request *EnqueueRequest, params EnqueueCallParams) (EnqueueCallRes, error) {
	res, err := c.sendEnqueueCall(ctx, request, params)
	return res, err
}

func (c *Client) sendEnqueueCall(ctx context.Context, request *EnqueueRequest, params EnqueueCallParams) (res EnqueueCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enqueue"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnqueueCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "EnqueueCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnqueueCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FetchTeXMLCallRecordings invokes FetchTeXMLCallRecordings operation.
//
// Returns recordings for a call identified by call_sid.
//
// GET /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json
func (c *Client) FetchTeXMLCallRecordings(ctx context.Context, params FetchTeXMLCallRecordingsParams) (FetchTeXMLCallRecordingsRes, error) {
	res, err := c.sendFetchTeXMLCallRecordings(ctx, params)
	return res, err
}

func (c *Client) sendFetchTeXMLCallRecordings(ctx context.Context, params FetchTeXMLCallRecordingsParams) (res FetchTeXMLCallRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FetchTeXMLCallRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFetchTeXMLCallRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FetchTeXMLConferenceRecordings invokes FetchTeXMLConferenceRecordings operation.
//
// Returns recordings for a conference identified by conference_sid.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings.json
func (c *Client) FetchTeXMLConferenceRecordings(ctx context.Context, params FetchTeXMLConferenceRecordingsParams) (FetchTeXMLConferenceRecordingsRes, error) {
	res, err := c.sendFetchTeXMLConferenceRecordings(ctx, params)
	return res, err
}

func (c *Client) sendFetchTeXMLConferenceRecordings(ctx context.Context, params FetchTeXMLConferenceRecordingsParams) (res FetchTeXMLConferenceRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FetchTeXMLConferenceRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFetchTeXMLConferenceRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindPortoutComments invokes FindPortoutComments operation.
//
// Returns a list of comments for a portout request.
//
// GET /portouts/{id}/comments
func (c *Client) FindPortoutComments(ctx context.Context, params FindPortoutCommentsParams) (FindPortoutCommentsRes, error) {
	res, err := c.sendFindPortoutComments(ctx, params)
	return res, err
}

func (c *Client) sendFindPortoutComments(ctx context.Context, params FindPortoutCommentsParams) (res FindPortoutCommentsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/portouts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FindPortoutComments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindPortoutCommentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindPortoutRequest invokes FindPortoutRequest operation.
//
// Returns the portout request based on the ID provided.
//
// GET /portouts/{id}
func (c *Client) FindPortoutRequest(ctx context.Context, params FindPortoutRequestParams) (FindPortoutRequestRes, error) {
	res, err := c.sendFindPortoutRequest(ctx, params)
	return res, err
}

func (c *Client) sendFindPortoutRequest(ctx context.Context, params FindPortoutRequestParams) (res FindPortoutRequestRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/portouts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FindPortoutRequest", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindPortoutRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindTelephonyCredentials invokes FindTelephonyCredentials operation.
//
// List all On-demand Credentials.
//
// GET /telephony_credentials
func (c *Client) FindTelephonyCredentials(ctx context.Context, params FindTelephonyCredentialsParams) (FindTelephonyCredentialsRes, error) {
	res, err := c.sendFindTelephonyCredentials(ctx, params)
	return res, err
}

func (c *Client) sendFindTelephonyCredentials(ctx context.Context, params FindTelephonyCredentialsParams) (res FindTelephonyCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTag.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[name]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[resource_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[resource_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterResourceID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[sip_username]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[sip_username]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterSipUsername.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FindTelephonyCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindTelephonyCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindTexmlApplications invokes FindTexmlApplications operation.
//
// Returns a list of your TeXML Applications.
//
// GET /texml_applications
func (c *Client) FindTexmlApplications(ctx context.Context, params FindTexmlApplicationsParams) (FindTexmlApplicationsRes, error) {
	res, err := c.sendFindTexmlApplications(ctx, params)
	return res, err
}

func (c *Client) sendFindTexmlApplications(ctx context.Context, params FindTexmlApplicationsParams) (res FindTexmlApplicationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/texml_applications"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[friendly_name][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[friendly_name][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterFriendlyNameContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[outbound_voice_profile_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[outbound_voice_profile_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterOutboundVoiceProfileID.Get(); ok {
				return e.EncodeValue(conv.StringInt64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "FindTexmlApplications", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFindTexmlApplicationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatherCall invokes GatherCall operation.
//
// Gather DTMF signals to build interactive menus.
// You can pass a list of valid digits. The `Answer` command must be issued before the `gather`
// command.
// **Expected Webhooks:**
// - `call.dtmf.received` (you may receive many of these webhooks)
// - `call.gather.ended`.
//
// POST /calls/{call_control_id}/actions/gather
func (c *Client) GatherCall(ctx context.Context, request *GatherRequest, params GatherCallParams) (GatherCallRes, error) {
	res, err := c.sendGatherCall(ctx, request, params)
	return res, err
}

func (c *Client) sendGatherCall(ctx context.Context, request *GatherRequest, params GatherCallParams) (res GatherCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/gather"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatherCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GatherCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGatherCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatherUsingAudio invokes GatherUsingAudio operation.
//
// Play an audio file on the call until the required DTMF signals are gathered to build interactive
// menus.
// You can pass a list of valid digits along with an 'invalid_audio_url', which will be played back
// at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The
// `Answer command must be issued before the `gather_using_audio` command.
// **Expected Webhooks:**
// - `call.playback.started`
// - `call.playback.ended`
// - `call.dtmf.received` (you may receive many of these webhooks)
// - `call.gather.ended`.
//
// POST /calls/{call_control_id}/actions/gather_using_audio
func (c *Client) GatherUsingAudio(ctx context.Context, request *GatherUsingAudioRequest, params GatherUsingAudioParams) (GatherUsingAudioRes, error) {
	res, err := c.sendGatherUsingAudio(ctx, request, params)
	return res, err
}

func (c *Client) sendGatherUsingAudio(ctx context.Context, request *GatherUsingAudioRequest, params GatherUsingAudioParams) (res GatherUsingAudioRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/gather_using_audio"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatherUsingAudioRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GatherUsingAudio", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGatherUsingAudioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatherUsingSpeak invokes GatherUsingSpeak operation.
//
// Convert text to speech and play it on the call until the required DTMF signals are gathered to
// build interactive menus.
// You can pass a list of valid digits along with an 'invalid_payload', which will be played back at
// the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The
// `Answer` command must be issued before the `gather_using_speak` command.
// **Expected Webhooks:**
// - `call.dtmf.received` (you may receive many of these webhooks)
// - `call.gather.ended`.
//
// POST /calls/{call_control_id}/actions/gather_using_speak
func (c *Client) GatherUsingSpeak(ctx context.Context, request *GatherUsingSpeakRequest, params GatherUsingSpeakParams) (GatherUsingSpeakRes, error) {
	res, err := c.sendGatherUsingSpeak(ctx, request, params)
	return res, err
}

func (c *Client) sendGatherUsingSpeak(ctx context.Context, request *GatherUsingSpeakRequest, params GatherUsingSpeakParams) (res GatherUsingSpeakRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/gather_using_speak"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatherUsingSpeakRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GatherUsingSpeak", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGatherUsingSpeakResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCsvDownload invokes GetCsvDownload operation.
//
// Retrieve a CSV download.
//
// GET /phone_numbers/csv_downloads/{id}
func (c *Client) GetCsvDownload(ctx context.Context, params GetCsvDownloadParams) (GetCsvDownloadRes, error) {
	res, err := c.sendGetCsvDownload(ctx, params)
	return res, err
}

func (c *Client) sendGetCsvDownload(ctx context.Context, params GetCsvDownloadParams) (res GetCsvDownloadRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone_numbers/csv_downloads/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetCsvDownload", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCsvDownloadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCustomStorageCredentials invokes GetCustomStorageCredentials operation.
//
// Returns the information about custom storage credentials.
//
// GET /custom_storage_credentials/{connection_id}
func (c *Client) GetCustomStorageCredentials(ctx context.Context, params GetCustomStorageCredentialsParams) (GetCustomStorageCredentialsRes, error) {
	res, err := c.sendGetCustomStorageCredentials(ctx, params)
	return res, err
}

func (c *Client) sendGetCustomStorageCredentials(ctx context.Context, params GetCustomStorageCredentialsParams) (res GetCustomStorageCredentialsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/custom_storage_credentials/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetCustomStorageCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCustomStorageCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDefaultGateway invokes GetDefaultGateway operation.
//
// Get Default Gateway status.
//
// GET /networks/{id}/default_gateway
func (c *Client) GetDefaultGateway(ctx context.Context, params GetDefaultGatewayParams) (GetDefaultGatewayRes, error) {
	res, err := c.sendGetDefaultGateway(ctx, params)
	return res, err
}

func (c *Client) sendGetDefaultGateway(ctx context.Context, params GetDefaultGatewayParams) (res GetDefaultGatewayRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/networks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/default_gateway"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetDefaultGateway", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDefaultGatewayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExternalConnectionLogMessage invokes GetExternalConnectionLogMessage operation.
//
// Retrieve a log message for an external connection associated with your account.
//
// GET /external_connections/log_messages/{id}
func (c *Client) GetExternalConnectionLogMessage(ctx context.Context, params GetExternalConnectionLogMessageParams) (GetExternalConnectionLogMessageRes, error) {
	res, err := c.sendGetExternalConnectionLogMessage(ctx, params)
	return res, err
}

func (c *Client) sendGetExternalConnectionLogMessage(ctx context.Context, params GetExternalConnectionLogMessageParams) (res GetExternalConnectionLogMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/external_connections/log_messages/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetExternalConnectionLogMessage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetExternalConnectionLogMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExternalConnectionPhoneNumber invokes GetExternalConnectionPhoneNumber operation.
//
// Return the details of a phone number associated with the given external connection.
//
// GET /external_connections/{id}/phone_numbers/{phone_number_id}
func (c *Client) GetExternalConnectionPhoneNumber(ctx context.Context, params GetExternalConnectionPhoneNumberParams) (GetExternalConnectionPhoneNumberRes, error) {
	res, err := c.sendGetExternalConnectionPhoneNumber(ctx, params)
	return res, err
}

func (c *Client) sendGetExternalConnectionPhoneNumber(ctx context.Context, params GetExternalConnectionPhoneNumberParams) (res GetExternalConnectionPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/external_connections/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetExternalConnectionPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetExternalConnectionPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMessage invokes GetMessage operation.
//
// Note: This API endpoint can only retrieve messages that are no older than 10 days since their
// creation. If you require messages older than this, please generate an [MDR report.
// ](https://developers.telnyx.com/docs/api/v1/reports/MDR-Reports).
//
// GET /messages/{id}
func (c *Client) GetMessage(ctx context.Context, params GetMessageParams) (GetMessageRes, error) {
	res, err := c.sendGetMessage(ctx, params)
	return res, err
}

func (c *Client) sendGetMessage(ctx context.Context, params GetMessageParams) (res GetMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/messages/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetMessage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMessagingHostedNumberOrder invokes GetMessagingHostedNumberOrder operation.
//
// Retrieve a messaging hosted number order.
//
// GET /messaging_hosted_number_orders/{id}
func (c *Client) GetMessagingHostedNumberOrder(ctx context.Context, params GetMessagingHostedNumberOrderParams) (GetMessagingHostedNumberOrderRes, error) {
	res, err := c.sendGetMessagingHostedNumberOrder(ctx, params)
	return res, err
}

func (c *Client) sendGetMessagingHostedNumberOrder(ctx context.Context, params GetMessagingHostedNumberOrderParams) (res GetMessagingHostedNumberOrderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/messaging_hosted_number_orders/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetMessagingHostedNumberOrder", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMessagingHostedNumberOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMobileNetworkOperators invokes GetMobileNetworkOperators operation.
//
// Telnyx has a set of GSM mobile operators partners that are available through our mobile network
// roaming. This resource is entirely managed by Telnyx and may change over time. That means that
// this resource won't allow any write operations for it. Still, it's available so it can be used as
// a support resource that can be related to other resources or become a configuration option.
//
// GET /mobile_network_operators
func (c *Client) GetMobileNetworkOperators(ctx context.Context, params GetMobileNetworkOperatorsParams) (GetMobileNetworkOperatorsRes, error) {
	res, err := c.sendGetMobileNetworkOperators(ctx, params)
	return res, err
}

func (c *Client) sendGetMobileNetworkOperators(ctx context.Context, params GetMobileNetworkOperatorsParams) (res GetMobileNetworkOperatorsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/mobile_network_operators"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[name][starts_with]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name][starts_with]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterNameStartsWith.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[name][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterNameContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[name][ends_with]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name][ends_with]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterNameEndsWith.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[country_code]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[country_code]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCountryCode.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[mcc]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[mcc]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterMcc.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[mnc]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[mnc]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterMnc.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[tadig]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tadig]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTadig.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[network_preferences_enabled]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[network_preferences_enabled]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterNetworkPreferencesEnabled.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetMobileNetworkOperators", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMobileNetworkOperatorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNetwork invokes GetNetwork operation.
//
// Retrieve a Network.
//
// GET /networks/{id}
func (c *Client) GetNetwork(ctx context.Context, params GetNetworkParams) (GetNetworkRes, error) {
	res, err := c.sendGetNetwork(ctx, params)
	return res, err
}

func (c *Client) sendGetNetwork(ctx context.Context, params GetNetworkParams) (res GetNetworkRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/networks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNotificationChannel invokes GetNotificationChannel operation.
//
// Get a notification channel.
//
// GET /notification_channels/{id}
func (c *Client) GetNotificationChannel(ctx context.Context, params GetNotificationChannelParams) (GetNotificationChannelRes, error) {
	res, err := c.sendGetNotificationChannel(ctx, params)
	return res, err
}

func (c *Client) sendGetNotificationChannel(ctx context.Context, params GetNotificationChannelParams) (res GetNotificationChannelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/notification_channels/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetNotificationChannel", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNotificationChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNumberOrderPhoneNumber invokes GetNumberOrderPhoneNumber operation.
//
// Get an existing number order phone number.
//
// GET /number_order_phone_numbers/{number_order_phone_number_id}
func (c *Client) GetNumberOrderPhoneNumber(ctx context.Context, params GetNumberOrderPhoneNumberParams) (GetNumberOrderPhoneNumberRes, error) {
	res, err := c.sendGetNumberOrderPhoneNumber(ctx, params)
	return res, err
}

func (c *Client) sendGetNumberOrderPhoneNumber(ctx context.Context, params GetNumberOrderPhoneNumberParams) (res GetNumberOrderPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/number_order_phone_numbers/"
	{
		// Encode "number_order_phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "number_order_phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NumberOrderPhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetNumberOrderPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNumberOrderPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneNumberMessagingSettings invokes GetPhoneNumberMessagingSettings operation.
//
// Retrieve a phone number with messaging settings.
//
// GET /phone_numbers/{id}/messaging
func (c *Client) GetPhoneNumberMessagingSettings(ctx context.Context, params GetPhoneNumberMessagingSettingsParams) (GetPhoneNumberMessagingSettingsRes, error) {
	res, err := c.sendGetPhoneNumberMessagingSettings(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneNumberMessagingSettings(ctx context.Context, params GetPhoneNumberMessagingSettingsParams) (res GetPhoneNumberMessagingSettingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone_numbers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messaging"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPhoneNumberMessagingSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPhoneNumberMessagingSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneNumberVoiceSettings invokes GetPhoneNumberVoiceSettings operation.
//
// Retrieve a phone number with voice settings.
//
// GET /phone_numbers/{id}/voice
func (c *Client) GetPhoneNumberVoiceSettings(ctx context.Context, params GetPhoneNumberVoiceSettingsParams) (GetPhoneNumberVoiceSettingsRes, error) {
	res, err := c.sendGetPhoneNumberVoiceSettings(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneNumberVoiceSettings(ctx context.Context, params GetPhoneNumberVoiceSettingsParams) (res GetPhoneNumberVoiceSettingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone_numbers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/voice"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPhoneNumberVoiceSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPhoneNumberVoiceSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneNumbers invokes GetPhoneNumbers operation.
//
// Retrieve the assigned phone numbers in a channel zone. Phone numbers assigned to a channel zone
// can receive concurrent calls up to the quantity reserved in that channel zone. Additional
// concurrent calls are rejected with a busy signal.
//
// GET /channel_zones/{channel_zone_id}/channel_zone_phone_numbers
func (c *Client) GetPhoneNumbers(ctx context.Context, params GetPhoneNumbersParams) (*GetGcbPhoneNumbersRequestResponse, error) {
	res, err := c.sendGetPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneNumbers(ctx context.Context, params GetPhoneNumbersParams) (res *GetGcbPhoneNumbersRequestResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channel_zones/"
	{
		// Encode "channel_zone_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_zone_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChannelZoneID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/channel_zone_phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPortRequestSupportingDocuments invokes GetPortRequestSupportingDocuments operation.
//
// List every supporting documents for a portout request.
//
// GET /portouts/{id}/supporting_documents
func (c *Client) GetPortRequestSupportingDocuments(ctx context.Context, params GetPortRequestSupportingDocumentsParams) (GetPortRequestSupportingDocumentsRes, error) {
	res, err := c.sendGetPortRequestSupportingDocuments(ctx, params)
	return res, err
}

func (c *Client) sendGetPortRequestSupportingDocuments(ctx context.Context, params GetPortRequestSupportingDocumentsParams) (res GetPortRequestSupportingDocumentsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/portouts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/supporting_documents"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPortRequestSupportingDocuments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPortRequestSupportingDocumentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecording invokes GetRecording operation.
//
// Retrieves the details of an existing call recording.
//
// GET /recordings/{recording_id}
func (c *Client) GetRecording(ctx context.Context, params GetRecordingParams) (GetRecordingRes, error) {
	res, err := c.sendGetRecording(ctx, params)
	return res, err
}

func (c *Client) sendGetRecording(ctx context.Context, params GetRecordingParams) (res GetRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/recordings/"
	{
		// Encode "recording_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecordingTranscription invokes getRecordingTranscription operation.
//
// Retrieves the details of an existing recording transcription.
//
// GET /recording_transcriptions/{recording_transcription_id}
func (c *Client) GetRecordingTranscription(ctx context.Context, params GetRecordingTranscriptionParams) (GetRecordingTranscriptionRes, error) {
	res, err := c.sendGetRecordingTranscription(ctx, params)
	return res, err
}

func (c *Client) sendGetRecordingTranscription(ctx context.Context, params GetRecordingTranscriptionParams) (res GetRecordingTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/recording_transcriptions/"
	{
		// Encode "recording_transcription_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_transcription_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingTranscriptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRecordingTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecordingTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecordingTranscriptions invokes getRecordingTranscriptions operation.
//
// Returns a list of your recording transcriptions.
//
// GET /recording_transcriptions
func (c *Client) GetRecordingTranscriptions(ctx context.Context) (GetRecordingTranscriptionsRes, error) {
	res, err := c.sendGetRecordingTranscriptions(ctx)
	return res, err
}

func (c *Client) sendGetRecordingTranscriptions(ctx context.Context) (res GetRecordingTranscriptionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/recording_transcriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRecordingTranscriptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecordingTranscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecordings invokes GetRecordings operation.
//
// Returns a list of your call recordings.
//
// GET /recordings
func (c *Client) GetRecordings(ctx context.Context, params GetRecordingsParams) (GetRecordingsRes, error) {
	res, err := c.sendGetRecordings(ctx, params)
	return res, err
}

func (c *Client) sendGetRecordings(ctx context.Context, params GetRecordingsParams) (res GetRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/recordings"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[conference_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[conference_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterConferenceID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[created_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[created_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCreatedAtGte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[created_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[created_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCreatedAtLte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[call_leg_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[call_leg_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCallLegID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[call_session_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[call_session_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCallSessionID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[from]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[from]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterFrom.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[to]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[to]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTo.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[connection_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[connection_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterConnectionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeXMLCallRecording invokes GetTeXMLCallRecording operation.
//
// Returns recording resource identified by recording id.
//
// GET /texml/Accounts/{account_sid}/Recordings/{recording_sid}.json
func (c *Client) GetTeXMLCallRecording(ctx context.Context, params GetTeXMLCallRecordingParams) (GetTeXMLCallRecordingRes, error) {
	res, err := c.sendGetTeXMLCallRecording(ctx, params)
	return res, err
}

func (c *Client) sendGetTeXMLCallRecording(ctx context.Context, params GetTeXMLCallRecordingParams) (res GetTeXMLCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Recordings/"
	{
		// Encode "recording_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTeXMLCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeXMLCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeXMLCallRecordings invokes GetTeXMLCallRecordings operation.
//
// Returns multiple recording resources for an account.
//
// GET /texml/Accounts/{account_sid}/Recordings.json
func (c *Client) GetTeXMLCallRecordings(ctx context.Context, params GetTeXMLCallRecordingsParams) (GetTeXMLCallRecordingsRes, error) {
	res, err := c.sendGetTeXMLCallRecordings(ctx, params)
	return res, err
}

func (c *Client) sendGetTeXMLCallRecordings(ctx context.Context, params GetTeXMLCallRecordingsParams) (res GetTeXMLCallRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Recordings.json"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "DateCreated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "DateCreated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateCreated.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTeXMLCallRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeXMLCallRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeXMLRecordingTranscription invokes GetTeXMLRecordingTranscription operation.
//
// Returns the recording transcription resource identified by its ID.
//
// GET /texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json
func (c *Client) GetTeXMLRecordingTranscription(ctx context.Context, params GetTeXMLRecordingTranscriptionParams) (GetTeXMLRecordingTranscriptionRes, error) {
	res, err := c.sendGetTeXMLRecordingTranscription(ctx, params)
	return res, err
}

func (c *Client) sendGetTeXMLRecordingTranscription(ctx context.Context, params GetTeXMLRecordingTranscriptionParams) (res GetTeXMLRecordingTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Transcriptions/"
	{
		// Encode "recording_transcription_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_transcription_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingTranscriptionSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTeXMLRecordingTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeXMLRecordingTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeXMLRecordingTranscriptions invokes GetTeXMLRecordingTranscriptions operation.
//
// Returns multiple recording transcription resources for an account.
//
// GET /texml/Accounts/{account_sid}/Transcriptions.json
func (c *Client) GetTeXMLRecordingTranscriptions(ctx context.Context, params GetTeXMLRecordingTranscriptionsParams) (GetTeXMLRecordingTranscriptionsRes, error) {
	res, err := c.sendGetTeXMLRecordingTranscriptions(ctx, params)
	return res, err
}

func (c *Client) sendGetTeXMLRecordingTranscriptions(ctx context.Context, params GetTeXMLRecordingTranscriptionsParams) (res GetTeXMLRecordingTranscriptionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Transcriptions.json"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "PageToken" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageToken",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTeXMLRecordingTranscriptions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeXMLRecordingTranscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTelephonyCredential invokes GetTelephonyCredential operation.
//
// Get the details of an existing On-demand Credential.
//
// GET /telephony_credentials/{id}
func (c *Client) GetTelephonyCredential(ctx context.Context, params GetTelephonyCredentialParams) (GetTelephonyCredentialRes, error) {
	res, err := c.sendGetTelephonyCredential(ctx, params)
	return res, err
}

func (c *Client) sendGetTelephonyCredential(ctx context.Context, params GetTelephonyCredentialParams) (res GetTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlApplication invokes GetTexmlApplication operation.
//
// Retrieves the details of an existing TeXML Application.
//
// GET /texml_applications/{id}
func (c *Client) GetTexmlApplication(ctx context.Context, params GetTexmlApplicationParams) (GetTexmlApplicationRes, error) {
	res, err := c.sendGetTexmlApplication(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlApplication(ctx context.Context, params GetTexmlApplicationParams) (res GetTexmlApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/texml_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlCall invokes GetTexmlCall operation.
//
// Returns an individual call identified by its CallSid. This endpoint is eventually consistent.
//
// GET /texml/Accounts/{account_sid}/Calls/{call_sid}
func (c *Client) GetTexmlCall(ctx context.Context, params GetTexmlCallParams) (GetTexmlCallRes, error) {
	res, err := c.sendGetTexmlCall(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlCall(ctx context.Context, params GetTexmlCallParams) (res GetTexmlCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlCalls invokes GetTexmlCalls operation.
//
// Returns multiple call resouces for an account. This endpoint is eventually consistent.
//
// GET /texml/Accounts/{account_sid}/Calls
func (c *Client) GetTexmlCalls(ctx context.Context, params GetTexmlCallsParams) (GetTexmlCallsRes, error) {
	res, err := c.sendGetTexmlCalls(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlCalls(ctx context.Context, params GetTexmlCallsParams) (res GetTexmlCallsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageToken" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageToken",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "To" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "To",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "From" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "From",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "StartTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "StartTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "EndTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "EndTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlCalls", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConference invokes GetTexmlConference operation.
//
// Returns a conference resource.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}
func (c *Client) GetTexmlConference(ctx context.Context, params GetTexmlConferenceParams) (GetTexmlConferenceRes, error) {
	res, err := c.sendGetTexmlConference(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConference(ctx context.Context, params GetTexmlConferenceParams) (res GetTexmlConferenceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConference", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferenceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConferenceParticipant invokes GetTexmlConferenceParticipant operation.
//
// Gets conference participant resource.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
func (c *Client) GetTexmlConferenceParticipant(ctx context.Context, params GetTexmlConferenceParticipantParams) (GetTexmlConferenceParticipantRes, error) {
	res, err := c.sendGetTexmlConferenceParticipant(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConferenceParticipant(ctx context.Context, params GetTexmlConferenceParticipantParams) (res GetTexmlConferenceParticipantRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConferenceParticipant", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferenceParticipantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConferenceParticipants invokes GetTexmlConferenceParticipants operation.
//
// Lists conference participants.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants
func (c *Client) GetTexmlConferenceParticipants(ctx context.Context, params GetTexmlConferenceParticipantsParams) (GetTexmlConferenceParticipantsRes, error) {
	res, err := c.sendGetTexmlConferenceParticipants(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConferenceParticipants(ctx context.Context, params GetTexmlConferenceParticipantsParams) (res GetTexmlConferenceParticipantsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConferenceParticipants", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferenceParticipantsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConferenceRecordings invokes GetTexmlConferenceRecordings operation.
//
// Lists conference recordings.
//
// GET /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings
func (c *Client) GetTexmlConferenceRecordings(ctx context.Context, params GetTexmlConferenceRecordingsParams) (GetTexmlConferenceRecordingsRes, error) {
	res, err := c.sendGetTexmlConferenceRecordings(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConferenceRecordings(ctx context.Context, params GetTexmlConferenceRecordingsParams) (res GetTexmlConferenceRecordingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConferenceRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferenceRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTexmlConferences invokes GetTexmlConferences operation.
//
// Lists conference resources.
//
// GET /texml/Accounts/{account_sid}/Conferences
func (c *Client) GetTexmlConferences(ctx context.Context, params GetTexmlConferencesParams) (GetTexmlConferencesRes, error) {
	res, err := c.sendGetTexmlConferences(ctx, params)
	return res, err
}

func (c *Client) sendGetTexmlConferences(ctx context.Context, params GetTexmlConferencesParams) (res GetTexmlConferencesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "Page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "PageToken" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "PageToken",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "FriendlyName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "FriendlyName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FriendlyName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "Status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "Status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "DateCreated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "DateCreated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateCreated.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "DateUpdated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "DateUpdated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateUpdated.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTexmlConferences", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTexmlConferencesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserBalance invokes GetUserBalance operation.
//
// Get user balance details.
//
// GET /balance
func (c *Client) GetUserBalance(ctx context.Context) (GetUserBalanceRes, error) {
	res, err := c.sendGetUserBalance(ctx)
	return res, err
}

func (c *Client) sendGetUserBalance(ctx context.Context) (res GetUserBalanceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/balance"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetUserBalance", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserBalanceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVerifiedNumber invokes GetVerifiedNumber operation.
//
// Retrieve a verified number.
//
// GET /verified_numbers/{phone_number}
func (c *Client) GetVerifiedNumber(ctx context.Context, params GetVerifiedNumberParams) (GetVerifiedNumberRes, error) {
	res, err := c.sendGetVerifiedNumber(ctx, params)
	return res, err
}

func (c *Client) sendGetVerifiedNumber(ctx context.Context, params GetVerifiedNumberParams) (res GetVerifiedNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_numbers/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVerifiedNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVerifiedNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVerifyProfile invokes GetVerifyProfile operation.
//
// Gets a single Verify profile.
//
// GET /verify_profiles/{verify_profile_id}
func (c *Client) GetVerifyProfile(ctx context.Context, params GetVerifyProfileParams) (GetVerifyProfileRes, error) {
	res, err := c.sendGetVerifyProfile(ctx, params)
	return res, err
}

func (c *Client) sendGetVerifyProfile(ctx context.Context, params GetVerifyProfileParams) (res GetVerifyProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verify_profiles/"
	{
		// Encode "verify_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "verify_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VerifyProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVerifyProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVerifyProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookDeliveries invokes GetWebhookDeliveries operation.
//
// Lists webhook_deliveries for the authenticated user.
//
// GET /webhook_deliveries
func (c *Client) GetWebhookDeliveries(ctx context.Context, params GetWebhookDeliveriesParams) (GetWebhookDeliveriesRes, error) {
	res, err := c.sendGetWebhookDeliveries(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhookDeliveries(ctx context.Context, params GetWebhookDeliveriesParams) (res GetWebhookDeliveriesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/webhook_deliveries"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[status][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatusEq.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[event_type]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[event_type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterEventType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[webhook][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[webhook][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterWebhookContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[attempts][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[attempts][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterAttemptsContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[started_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[started_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStartedAtGte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[started_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[started_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStartedAtLte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[finished_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[finished_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterFinishedAtGte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[finished_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[finished_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterFinishedAtLte.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetWebhookDeliveries", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookDeliveriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookDelivery invokes GetWebhookDelivery operation.
//
// Provides webhook_delivery debug data, such as timestamps, delivery status and attempts.
//
// GET /webhook_deliveries/{id}
func (c *Client) GetWebhookDelivery(ctx context.Context, params GetWebhookDeliveryParams) (GetWebhookDeliveryRes, error) {
	res, err := c.sendGetWebhookDelivery(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhookDelivery(ctx context.Context, params GetWebhookDeliveryParams) (res GetWebhookDeliveryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/webhook_deliveries/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetWebhookDelivery", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookDeliveryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HangupCall invokes HangupCall operation.
//
// Hang up the call.
// **Expected Webhooks:**
// - `call.hangup`
// - `call.recording.saved`.
//
// POST /calls/{call_control_id}/actions/hangup
func (c *Client) HangupCall(ctx context.Context, request *HangupRequest, params HangupCallParams) (HangupCallRes, error) {
	res, err := c.sendHangupCall(ctx, request, params)
	return res, err
}

func (c *Client) sendHangupCall(ctx context.Context, request *HangupRequest, params HangupCallParams) (res HangupCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/hangup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHangupCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "HangupCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHangupCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InitiateTexmlCallByAccount invokes InitiateTexmlCallByAccount operation.
//
// Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for
// the connection in the Mission Control Portal.
//
// POST /texml/Accounts/{account_sid}/Calls
func (c *Client) InitiateTexmlCallByAccount(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByAccountParams) (*InitiateCallResponse, error) {
	res, err := c.sendInitiateTexmlCallByAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendInitiateTexmlCallByAccount(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByAccountParams) (res *InitiateCallResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInitiateTexmlCallByAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "InitiateTexmlCallByAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInitiateTexmlCallByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InitiateTexmlCallByApplication invokes InitiateTexmlCallByApplication operation.
//
// Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for
// the connection in the Mission Control Portal.
//
// POST /texml/calls/{application_id}
func (c *Client) InitiateTexmlCallByApplication(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByApplicationParams) (*InitiateCallResponse, error) {
	res, err := c.sendInitiateTexmlCallByApplication(ctx, request, params)
	return res, err
}

func (c *Client) sendInitiateTexmlCallByApplication(ctx context.Context, request *InitiateCallRequest, params InitiateTexmlCallByApplicationParams) (res *InitiateCallResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/texml/calls/"
	{
		// Encode "application_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "application_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApplicationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInitiateTexmlCallByApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "InitiateTexmlCallByApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInitiateTexmlCallByApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeaveQueue invokes LeaveQueue operation.
//
// Removes the call from a queue.
//
// POST /calls/{call_control_id}/actions/leave_queue
func (c *Client) LeaveQueue(ctx context.Context, request *LeaveQueueRequest, params LeaveQueueParams) (LeaveQueueRes, error) {
	res, err := c.sendLeaveQueue(ctx, request, params)
	return res, err
}

func (c *Client) sendLeaveQueue(ctx context.Context, request *LeaveQueueRequest, params LeaveQueueParams) (res LeaveQueueRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/leave_queue"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLeaveQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "LeaveQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeaveQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAvailablePhoneNumbers invokes ListAvailablePhoneNumbers operation.
//
// List available phone numbers.
//
// GET /available_phone_numbers
func (c *Client) ListAvailablePhoneNumbers(ctx context.Context, params ListAvailablePhoneNumbersParams) (ListAvailablePhoneNumbersRes, error) {
	res, err := c.sendListAvailablePhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListAvailablePhoneNumbers(ctx context.Context, params ListAvailablePhoneNumbersParams) (res ListAvailablePhoneNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/available_phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[phone_number][starts_with]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number][starts_with]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumberStartsWith.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number][ends_with]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number][ends_with]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumberEndsWith.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumberContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[locality]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[locality]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterLocality.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[administrative_area]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[administrative_area]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterAdministrativeArea.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[country_code]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[country_code]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCountryCode.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[national_destination_code]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[national_destination_code]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterNationalDestinationCode.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[rate_center]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[rate_center]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterRateCenter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number_type]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number_type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumberType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[features]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[features]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.FilterFeatures != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.FilterFeatures {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[limit]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[limit]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterLimit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[best_effort]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[best_effort]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterBestEffort.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[quickship]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[quickship]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterQuickship.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[reservable]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[reservable]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterReservable.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[exclude_held_numbers]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[exclude_held_numbers]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterExcludeHeldNumbers.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListAvailablePhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListAvailablePhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCallControlApplications invokes ListCallControlApplications operation.
//
// Return a list of call control applications.
//
// GET /call_control_applications
func (c *Client) ListCallControlApplications(ctx context.Context, params ListCallControlApplicationsParams) (ListCallControlApplicationsRes, error) {
	res, err := c.sendListCallControlApplications(ctx, params)
	return res, err
}

func (c *Client) sendListCallControlApplications(ctx context.Context, params ListCallControlApplicationsParams) (res ListCallControlApplicationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/call_control_applications"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[application_name][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[application_name][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterApplicationNameContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[outbound_voice_profile_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[outbound_voice_profile_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterOutboundVoiceProfileID.Get(); ok {
				return e.EncodeValue(conv.StringInt64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListCallControlApplications", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListCallControlApplicationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListConnectionActiveCalls invokes ListConnectionActiveCalls operation.
//
// Lists all active calls for given connection. Acceptable connections are either SIP connections
// with webhook_url or xml_request_url, call control or texml. Returned results are cursor paginated.
//
// GET /connections/{connection_id}/active_calls
func (c *Client) ListConnectionActiveCalls(ctx context.Context, params ListConnectionActiveCallsParams) (ListConnectionActiveCallsRes, error) {
	res, err := c.sendListConnectionActiveCalls(ctx, params)
	return res, err
}

func (c *Client) sendListConnectionActiveCalls(ctx context.Context, params ListConnectionActiveCallsParams) (res ListConnectionActiveCallsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connections/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/active_calls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[limit]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[limit]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageLimit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[after]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[after]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageAfter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[before]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[before]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageBefore.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListConnectionActiveCalls", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListConnectionActiveCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListCsvDownloads invokes ListCsvDownloads operation.
//
// List CSV downloads.
//
// GET /phone_numbers/csv_downloads
func (c *Client) ListCsvDownloads(ctx context.Context, params ListCsvDownloadsParams) (ListCsvDownloadsRes, error) {
	res, err := c.sendListCsvDownloads(ctx, params)
	return res, err
}

func (c *Client) sendListCsvDownloads(ctx context.Context, params ListCsvDownloadsParams) (res ListCsvDownloadsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/csv_downloads"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListCsvDownloads", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListCsvDownloadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListExternalConnectionLogMessages invokes ListExternalConnectionLogMessages operation.
//
// Retrieve a list of log messages for all external connections associated with your account.
//
// GET /external_connections/log_messages
func (c *Client) ListExternalConnectionLogMessages(ctx context.Context, params ListExternalConnectionLogMessagesParams) (ListExternalConnectionLogMessagesRes, error) {
	res, err := c.sendListExternalConnectionLogMessages(ctx, params)
	return res, err
}

func (c *Client) sendListExternalConnectionLogMessages(ctx context.Context, params ListExternalConnectionLogMessagesParams) (res ListExternalConnectionLogMessagesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external_connections/log_messages"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[external_connection_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[external_connection_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterExternalConnectionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[telephone_number][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[telephone_number][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTelephoneNumberContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[telephone_number][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[telephone_number][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTelephoneNumberEq.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListExternalConnectionLogMessages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListExternalConnectionLogMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListExternalConnectionPhoneNumbers invokes ListExternalConnectionPhoneNumbers operation.
//
// Returns a list of all active phone numbers associated with the given external connection.
//
// GET /external_connections/{id}/phone_numbers
func (c *Client) ListExternalConnectionPhoneNumbers(ctx context.Context, params ListExternalConnectionPhoneNumbersParams) (ListExternalConnectionPhoneNumbersRes, error) {
	res, err := c.sendListExternalConnectionPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListExternalConnectionPhoneNumbers(ctx context.Context, params ListExternalConnectionPhoneNumbersParams) (res ListExternalConnectionPhoneNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/external_connections/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumberEq.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumberContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[civic_address_id][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[civic_address_id][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCivicAddressIDEq.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[location_id][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[location_id][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterLocationIDEq.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListExternalConnectionPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListExternalConnectionPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListInboundChannels invokes ListInboundChannels operation.
//
// Returns the inbound channels for your account. Inbound channels allows you to use Channel Billing
// for calls to your Telnyx phone numbers. Please check the Telnyx Support Articles section for full
// information and examples of how to utilize Channel Billing.
//
// GET /phone_numbers/inbound_channels
func (c *Client) ListInboundChannels(ctx context.Context) (ListInboundChannelsRes, error) {
	res, err := c.sendListInboundChannels(ctx)
	return res, err
}

func (c *Client) sendListInboundChannels(ctx context.Context) (res ListInboundChannelsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/inbound_channels"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListInboundChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListInboundChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMessagingHostedNumberOrders invokes ListMessagingHostedNumberOrders operation.
//
// List messaging hosted number orders.
//
// GET /messaging_hosted_number_orders
func (c *Client) ListMessagingHostedNumberOrders(ctx context.Context, params ListMessagingHostedNumberOrdersParams) (ListMessagingHostedNumberOrdersRes, error) {
	res, err := c.sendListMessagingHostedNumberOrders(ctx, params)
	return res, err
}

func (c *Client) sendListMessagingHostedNumberOrders(ctx context.Context, params ListMessagingHostedNumberOrdersParams) (res ListMessagingHostedNumberOrdersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messaging_hosted_number_orders"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListMessagingHostedNumberOrders", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListMessagingHostedNumberOrdersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMessagingUrlDomains invokes ListMessagingUrlDomains operation.
//
// List messaging URL domains.
//
// GET /messaging_url_domains
func (c *Client) ListMessagingUrlDomains(ctx context.Context, params ListMessagingUrlDomainsParams) (ListMessagingUrlDomainsRes, error) {
	res, err := c.sendListMessagingUrlDomains(ctx, params)
	return res, err
}

func (c *Client) sendListMessagingUrlDomains(ctx context.Context, params ListMessagingUrlDomainsParams) (res ListMessagingUrlDomainsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messaging_url_domains"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListMessagingUrlDomains", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListMessagingUrlDomainsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListNetworkInterfaces invokes ListNetworkInterfaces operation.
//
// List all Interfaces for a Network.
//
// GET /networks/{id}/network_interfaces
func (c *Client) ListNetworkInterfaces(ctx context.Context, params ListNetworkInterfacesParams) (ListNetworkInterfacesRes, error) {
	res, err := c.sendListNetworkInterfaces(ctx, params)
	return res, err
}

func (c *Client) sendListNetworkInterfaces(ctx context.Context, params ListNetworkInterfacesParams) (res ListNetworkInterfacesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/networks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/network_interfaces"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[name]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[type]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListNetworkInterfaces", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListNetworkInterfacesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListNetworks invokes ListNetworks operation.
//
// List all Networks.
//
// GET /networks
func (c *Client) ListNetworks(ctx context.Context, params ListNetworksParams) (ListNetworksRes, error) {
	res, err := c.sendListNetworks(ctx, params)
	return res, err
}

func (c *Client) sendListNetworks(ctx context.Context, params ListNetworksParams) (res ListNetworksRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/networks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[name]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListNetworks", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListNetworksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListNotificationChannels invokes ListNotificationChannels operation.
//
// List notification channels.
//
// GET /notification_channels
func (c *Client) ListNotificationChannels(ctx context.Context, params ListNotificationChannelsParams) (ListNotificationChannelsRes, error) {
	res, err := c.sendListNotificationChannels(ctx, params)
	return res, err
}

func (c *Client) sendListNotificationChannels(ctx context.Context, params ListNotificationChannelsParams) (res ListNotificationChannelsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/notification_channels"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[channel_type_id][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[channel_type_id][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterChannelTypeIDEq.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListNotificationChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListNotificationChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneNumbers invokes ListPhoneNumbers operation.
//
// List phone numbers.
//
// GET /phone_numbers
func (c *Client) ListPhoneNumbers(ctx context.Context, params ListPhoneNumbersParams) (ListPhoneNumbersRes, error) {
	res, err := c.sendListPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListPhoneNumbers(ctx context.Context, params ListPhoneNumbersParams) (res ListPhoneNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTag.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[connection_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[connection_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterConnectionID.Get(); ok {
				return e.EncodeValue(conv.StringInt64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.connection_name][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.connection_name][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceConnectionNameContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.connection_name][starts_with]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.connection_name][starts_with]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceConnectionNameStartsWith.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.connection_name][ends_with]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.connection_name][ends_with]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceConnectionNameEndsWith.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.connection_name][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.connection_name][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceConnectionNameEq.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.usage_payment_method]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.usage_payment_method]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceUsagePaymentMethod.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[billing_group_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[billing_group_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterBillingGroupID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[emergency_address_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[emergency_address_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterEmergencyAddressID.Get(); ok {
				return e.EncodeValue(conv.StringInt64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[customer_reference]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[customer_reference]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCustomerReference.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneNumbersJobs invokes ListPhoneNumbersJobs operation.
//
// Lists the phone numbers jobs.
//
// GET /phone_numbers/jobs
func (c *Client) ListPhoneNumbersJobs(ctx context.Context, params ListPhoneNumbersJobsParams) (ListPhoneNumbersJobsRes, error) {
	res, err := c.sendListPhoneNumbersJobs(ctx, params)
	return res, err
}

func (c *Client) sendListPhoneNumbersJobs(ctx context.Context, params ListPhoneNumbersJobsParams) (res ListPhoneNumbersJobsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/jobs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[type]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListPhoneNumbersJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListPhoneNumbersJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneNumbersWithMessagingSettings invokes ListPhoneNumbersWithMessagingSettings operation.
//
// List phone numbers with messaging settings.
//
// GET /phone_numbers/messaging
func (c *Client) ListPhoneNumbersWithMessagingSettings(ctx context.Context, params ListPhoneNumbersWithMessagingSettingsParams) (ListPhoneNumbersWithMessagingSettingsRes, error) {
	res, err := c.sendListPhoneNumbersWithMessagingSettings(ctx, params)
	return res, err
}

func (c *Client) sendListPhoneNumbersWithMessagingSettings(ctx context.Context, params ListPhoneNumbersWithMessagingSettingsParams) (res ListPhoneNumbersWithMessagingSettingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/messaging"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListPhoneNumbersWithMessagingSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListPhoneNumbersWithMessagingSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneNumbersWithVoiceSettings invokes ListPhoneNumbersWithVoiceSettings operation.
//
// List phone numbers with voice settings.
//
// GET /phone_numbers/voice
func (c *Client) ListPhoneNumbersWithVoiceSettings(ctx context.Context, params ListPhoneNumbersWithVoiceSettingsParams) (ListPhoneNumbersWithVoiceSettingsRes, error) {
	res, err := c.sendListPhoneNumbersWithVoiceSettings(ctx, params)
	return res, err
}

func (c *Client) sendListPhoneNumbersWithVoiceSettings(ctx context.Context, params ListPhoneNumbersWithVoiceSettingsParams) (res ListPhoneNumbersWithVoiceSettingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/voice"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[connection_name][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[connection_name][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterConnectionNameContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[customer_reference]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[customer_reference]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCustomerReference.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.usage_payment_method]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.usage_payment_method]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceUsagePaymentMethod.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListPhoneNumbersWithVoiceSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListPhoneNumbersWithVoiceSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPortingPhoneNumbers invokes ListPortingPhoneNumbers operation.
//
// Returns a list of your porting phone numbers.
//
// GET /porting_phone_numbers
func (c *Client) ListPortingPhoneNumbers(ctx context.Context, params ListPortingPhoneNumbersParams) (ListPortingPhoneNumbersRes, error) {
	res, err := c.sendListPortingPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListPortingPhoneNumbers(ctx context.Context, params ListPortingPhoneNumbersParams) (res ListPortingPhoneNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/porting_phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[porting_order_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[porting_order_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPortingOrderID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[porting_order_id][in][]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[porting_order_id][in][]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.FilterPortingOrderIDIn != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.FilterPortingOrderIDIn {
						if err := func() error {
							return e.EncodeValue(conv.UUIDToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[support_key][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[support_key][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterSupportKeyEq.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[support_key][in][]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[support_key][in][]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.FilterSupportKeyIn != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.FilterSupportKeyIn {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number][in][]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number][in][]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.FilterPhoneNumberIn != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.FilterPhoneNumberIn {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[porting_order_status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[porting_order_status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPortingOrderStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[activation_status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[activation_status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterActivationStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[portability_status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[portability_status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPortabilityStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListPortingPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListPortingPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListProfileMessageTemplates invokes ListProfileMessageTemplates operation.
//
// List all Verify profile message templates.
//
// GET /verify_profiles/templates
func (c *Client) ListProfileMessageTemplates(ctx context.Context) (*ListVerifyProfileMessageTemplateResponse, error) {
	res, err := c.sendListProfileMessageTemplates(ctx)
	return res, err
}

func (c *Client) sendListProfileMessageTemplates(ctx context.Context) (res *ListVerifyProfileMessageTemplateResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verify_profiles/templates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListProfileMessageTemplates", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListProfileMessageTemplatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListProfilePhoneNumbers invokes ListProfilePhoneNumbers operation.
//
// List phone numbers associated with a messaging profile.
//
// GET /messaging_profiles/{id}/phone_numbers
func (c *Client) ListProfilePhoneNumbers(ctx context.Context, params ListProfilePhoneNumbersParams) (ListProfilePhoneNumbersRes, error) {
	res, err := c.sendListProfilePhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListProfilePhoneNumbers(ctx context.Context, params ListProfilePhoneNumbersParams) (res ListProfilePhoneNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/messaging_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListProfilePhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListProfilePhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListProfiles invokes ListProfiles operation.
//
// Gets a paginated list of Verify profiles.
//
// GET /verify_profiles
func (c *Client) ListProfiles(ctx context.Context, params ListProfilesParams) (ListProfilesRes, error) {
	res, err := c.sendListProfiles(ctx, params)
	return res, err
}

func (c *Client) sendListProfiles(ctx context.Context, params ListProfilesParams) (res ListProfilesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verify_profiles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[name]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[name]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListProfiles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListProfilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListQueueCalls invokes ListQueueCalls operation.
//
// Retrieve the list of calls in an existing queue.
//
// GET /queues/{queue_name}/calls
func (c *Client) ListQueueCalls(ctx context.Context, params ListQueueCallsParams) (ListQueueCallsRes, error) {
	res, err := c.sendListQueueCalls(ctx, params)
	return res, err
}

func (c *Client) sendListQueueCalls(ctx context.Context, params ListQueueCallsParams) (res ListQueueCallsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/queues/"
	{
		// Encode "queue_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueueName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calls"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListQueueCalls", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListQueueCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRegulatoryRequirements invokes ListRegulatoryRequirements operation.
//
// Retrieve regulartory requirements.
//
// GET /phone_numbers_regulatory_requirements
func (c *Client) ListRegulatoryRequirements(ctx context.Context, params ListRegulatoryRequirementsParams) (ListRegulatoryRequirementsRes, error) {
	res, err := c.sendListRegulatoryRequirements(ctx, params)
	return res, err
}

func (c *Client) sendListRegulatoryRequirements(ctx context.Context, params ListRegulatoryRequirementsParams) (res ListRegulatoryRequirementsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers_regulatory_requirements"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[phone_number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilterPhoneNumber))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListRegulatoryRequirements", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListRegulatoryRequirementsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListRoomRecordings invokes ListRoomRecordings operation.
//
// View a list of room recordings.
//
// GET /room_recordings
func (c *Client) ListRoomRecordings(ctx context.Context, params ListRoomRecordingsParams) (*ListRoomRecordingsResponse, error) {
	res, err := c.sendListRoomRecordings(ctx, params)
	return res, err
}

func (c *Client) sendListRoomRecordings(ctx context.Context, params ListRoomRecordingsParams) (res *ListRoomRecordingsResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/room_recordings"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[date_ended_at][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtEq.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_ended_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_ended_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_ended_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateEndedAtLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtEq.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtGte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[date_started_at][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[date_started_at][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDateStartedAtLte.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[room_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[room_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterRoomID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[participant_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[participant_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterParticipantID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[session_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[session_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterSessionID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[type]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[type]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][eq]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][eq]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsEq.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][lte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][lte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsLte.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[duration_secs][gte]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[duration_secs][gte]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterDurationSecsGte.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListRoomRecordings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListRoomRecordingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListTags invokes ListTags operation.
//
// Returns a list of tags used on Credentials.
//
// GET /telephony_credentials/tags
func (c *Client) ListTags(ctx context.Context, params ListTagsParams) (ListTagsRes, error) {
	res, err := c.sendListTags(ctx, params)
	return res, err
}

func (c *Client) sendListTags(ctx context.Context, params ListTagsParams) (res ListTagsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/telephony_credentials/tags"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListTags", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListVerifications invokes ListVerifications operation.
//
// List verifications by phone number.
//
// GET /verifications/by_phone_number/{phone_number}
func (c *Client) ListVerifications(ctx context.Context, params ListVerificationsParams) (ListVerificationsRes, error) {
	res, err := c.sendListVerifications(ctx, params)
	return res, err
}

func (c *Client) sendListVerifications(ctx context.Context, params ListVerificationsParams) (res ListVerificationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verifications/by_phone_number/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListVerifications", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListVerificationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListVerifiedCallDisplayProfiles invokes ListVerifiedCallDisplayProfiles operation.
//
// Lists the Verified Calls Display Profiles owned by the current user/organization.
//
// GET /verified_calls_display_profiles
func (c *Client) ListVerifiedCallDisplayProfiles(ctx context.Context, params ListVerifiedCallDisplayProfilesParams) (ListVerifiedCallDisplayProfilesRes, error) {
	res, err := c.sendListVerifiedCallDisplayProfiles(ctx, params)
	return res, err
}

func (c *Client) sendListVerifiedCallDisplayProfiles(ctx context.Context, params ListVerifiedCallDisplayProfilesParams) (res ListVerifiedCallDisplayProfilesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verified_calls_display_profiles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListVerifiedCallDisplayProfiles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListVerifiedCallDisplayProfilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListVerifiedNumbers invokes ListVerifiedNumbers operation.
//
// Gets a paginated list of Verified Numbers.
//
// GET /verified_numbers
func (c *Client) ListVerifiedNumbers(ctx context.Context, params ListVerifiedNumbersParams) (ListVerifiedNumbersRes, error) {
	res, err := c.sendListVerifiedNumbers(ctx, params)
	return res, err
}

func (c *Client) sendListVerifiedNumbers(ctx context.Context, params ListVerifiedNumbersParams) (res ListVerifiedNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/verified_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ListVerifiedNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListVerifiedNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LookupNumber invokes LookupNumber operation.
//
// Returns information about the provided phone number.
//
// GET /number_lookup/{phone_number}
func (c *Client) LookupNumber(ctx context.Context, params LookupNumberParams) (LookupNumberRes, error) {
	res, err := c.sendLookupNumber(ctx, params)
	return res, err
}

func (c *Client) sendLookupNumber(ctx context.Context, params LookupNumberParams) (res LookupNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/number_lookup/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "LookupNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLookupNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NoiseSuppressionStart invokes noiseSuppressionStart operation.
//
// Noise Suppression Start (BETA).
//
// POST /calls/{call_control_id}/actions/suppression_start
func (c *Client) NoiseSuppressionStart(ctx context.Context, request *NoiseSuppressionStart, params NoiseSuppressionStartParams) (NoiseSuppressionStartRes, error) {
	res, err := c.sendNoiseSuppressionStart(ctx, request, params)
	return res, err
}

func (c *Client) sendNoiseSuppressionStart(ctx context.Context, request *NoiseSuppressionStart, params NoiseSuppressionStartParams) (res NoiseSuppressionStartRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/suppression_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNoiseSuppressionStartRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "NoiseSuppressionStart", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeNoiseSuppressionStartResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NoiseSuppressionStop invokes noiseSuppressionStop operation.
//
// Noise Suppression Stop (BETA).
//
// POST /calls/{call_control_id}/actions/suppression_stop
func (c *Client) NoiseSuppressionStop(ctx context.Context, request *NoiseSuppressionStop, params NoiseSuppressionStopParams) (NoiseSuppressionStopRes, error) {
	res, err := c.sendNoiseSuppressionStop(ctx, request, params)
	return res, err
}

func (c *Client) sendNoiseSuppressionStop(ctx context.Context, request *NoiseSuppressionStop, params NoiseSuppressionStopParams) (res NoiseSuppressionStopRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/suppression_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNoiseSuppressionStopRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "NoiseSuppressionStop", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeNoiseSuppressionStopResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PauseCallRecording invokes PauseCallRecording operation.
//
// Pause recording the call. Recording can be resumed via Resume recording command.
// **Expected Webhooks:**
// There are no webhooks associated with this command.
//
// POST /calls/{call_control_id}/actions/record_pause
func (c *Client) PauseCallRecording(ctx context.Context, request *PauseRecordingRequest, params PauseCallRecordingParams) (PauseCallRecordingRes, error) {
	res, err := c.sendPauseCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendPauseCallRecording(ctx context.Context, request *PauseRecordingRequest, params PauseCallRecordingParams) (res PauseCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/record_pause"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePauseCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "PauseCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePauseCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PerformCredentialAction invokes PerformCredentialAction operation.
//
// Perform activate or deactivate action on provided Credential. Activate action will change the
// status to active, making it possible to connect calls with the credential. Deactivate action will
// change the status to inactive, making it impossible to connect calls with the credential.
//
// POST /telephony_credentials/{id}/actions/{action}
func (c *Client) PerformCredentialAction(ctx context.Context, params PerformCredentialActionParams) (PerformCredentialActionRes, error) {
	res, err := c.sendPerformCredentialAction(ctx, params)
	return res, err
}

func (c *Client) sendPerformCredentialAction(ctx context.Context, params PerformCredentialActionParams) (res PerformCredentialActionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/"
	{
		// Encode "action" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "action",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Action)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "PerformCredentialAction", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePerformCredentialActionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPortRequestComment invokes PostPortRequestComment operation.
//
// Creates a comment on a portout request.
//
// POST /portouts/{id}/comments
func (c *Client) PostPortRequestComment(ctx context.Context, request *PostPortRequestCommentReq, params PostPortRequestCommentParams) (PostPortRequestCommentRes, error) {
	res, err := c.sendPostPortRequestComment(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPortRequestComment(ctx context.Context, request *PostPortRequestCommentReq, params PostPortRequestCommentParams) (res PostPortRequestCommentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/portouts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPortRequestCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "PostPortRequestComment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostPortRequestCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostPortRequestSupportingDocuments invokes PostPortRequestSupportingDocuments operation.
//
// Creates a list of supporting documents on a portout request.
//
// POST /portouts/{id}/supporting_documents
func (c *Client) PostPortRequestSupportingDocuments(ctx context.Context, request *PostPortRequestSupportingDocumentsReq, params PostPortRequestSupportingDocumentsParams) (PostPortRequestSupportingDocumentsRes, error) {
	res, err := c.sendPostPortRequestSupportingDocuments(ctx, request, params)
	return res, err
}

func (c *Client) sendPostPortRequestSupportingDocuments(ctx context.Context, request *PostPortRequestSupportingDocumentsReq, params PostPortRequestSupportingDocumentsParams) (res PostPortRequestSupportingDocumentsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/portouts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/supporting_documents"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostPortRequestSupportingDocumentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "PostPortRequestSupportingDocuments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostPortRequestSupportingDocumentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReferCall invokes ReferCall operation.
//
// Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any point in the
// duration of a call.
// **Expected Webhooks:**
// - `call.refer.started`
// - `call.refer.completed`
// - `call.refer.failed`.
//
// POST /calls/{call_control_id}/actions/refer
func (c *Client) ReferCall(ctx context.Context, request *ReferRequest, params ReferCallParams) (ReferCallRes, error) {
	res, err := c.sendReferCall(ctx, request, params)
	return res, err
}

func (c *Client) sendReferCall(ctx context.Context, request *ReferRequest, params ReferCallParams) (res ReferCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/refer"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReferCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ReferCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReferCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RegisterCall invokes RegisterCall operation.
//
// Register the call before dialing to show your brand on callee's phone.
//
// POST /calls/register
func (c *Client) RegisterCall(ctx context.Context, request *RegisterCallRequest) (RegisterCallRes, error) {
	res, err := c.sendRegisterCall(ctx, request)
	return res, err
}

func (c *Client) sendRegisterCall(ctx context.Context, request *RegisterCallRequest) (res RegisterCallRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/calls/register"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRegisterCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RegisterCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRegisterCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RejectCall invokes RejectCall operation.
//
// Reject an incoming call.
// **Expected Webhooks:**
// - `call.hangup`.
//
// POST /calls/{call_control_id}/actions/reject
func (c *Client) RejectCall(ctx context.Context, request *RejectRequest, params RejectCallParams) (RejectCallRes, error) {
	res, err := c.sendRejectCall(ctx, request, params)
	return res, err
}

func (c *Client) sendRejectCall(ctx context.Context, request *RejectRequest, params RejectCallParams) (res RejectCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/reject"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRejectCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RejectCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRejectCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ResumeCallRecording invokes ResumeCallRecording operation.
//
// Resume recording the call.
// **Expected Webhooks:**
// There are no webhooks associated with this command.
//
// POST /calls/{call_control_id}/actions/record_resume
func (c *Client) ResumeCallRecording(ctx context.Context, request *ResumeRecordingRequest, params ResumeCallRecordingParams) (ResumeCallRecordingRes, error) {
	res, err := c.sendResumeCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendResumeCallRecording(ctx context.Context, request *ResumeRecordingRequest, params ResumeCallRecordingParams) (res ResumeCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/record_resume"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeResumeCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ResumeCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeResumeCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveCallControlApplication invokes RetrieveCallControlApplication operation.
//
// Retrieves the details of an existing call control application.
//
// GET /call_control_applications/{id}
func (c *Client) RetrieveCallControlApplication(ctx context.Context, params RetrieveCallControlApplicationParams) (RetrieveCallControlApplicationRes, error) {
	res, err := c.sendRetrieveCallControlApplication(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveCallControlApplication(ctx context.Context, params RetrieveCallControlApplicationParams) (res RetrieveCallControlApplicationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/call_control_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveCallControlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveCallControlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveCallFromQueue invokes RetrieveCallFromQueue operation.
//
// Retrieve an existing call from an existing queue.
//
// GET /queues/{queue_name}/calls/{call_control_id}
func (c *Client) RetrieveCallFromQueue(ctx context.Context, params RetrieveCallFromQueueParams) (RetrieveCallFromQueueRes, error) {
	res, err := c.sendRetrieveCallFromQueue(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveCallFromQueue(ctx context.Context, params RetrieveCallFromQueueParams) (res RetrieveCallFromQueueRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/queues/"
	{
		// Encode "queue_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.QueueName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveCallFromQueue", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveCallFromQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveCallStatus invokes RetrieveCallStatus operation.
//
// Returns the status of a call (data is available 10 minutes after call ended).
//
// GET /calls/{call_control_id}
func (c *Client) RetrieveCallStatus(ctx context.Context, params RetrieveCallStatusParams) (RetrieveCallStatusRes, error) {
	res, err := c.sendRetrieveCallStatus(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveCallStatus(ctx context.Context, params RetrieveCallStatusParams) (res RetrieveCallStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveCallStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveCallStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveOrderPhoneNumbers invokes RetrieveOrderPhoneNumbers operation.
//
// Get a list of phone numbers associated to orders.
//
// GET /number_order_phone_numbers
func (c *Client) RetrieveOrderPhoneNumbers(ctx context.Context) (RetrieveOrderPhoneNumbersRes, error) {
	res, err := c.sendRetrieveOrderPhoneNumbers(ctx)
	return res, err
}

func (c *Client) sendRetrieveOrderPhoneNumbers(ctx context.Context) (res RetrieveOrderPhoneNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/number_order_phone_numbers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveOrderPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveOrderPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrievePhoneNumber invokes RetrievePhoneNumber operation.
//
// Retrieve a phone number.
//
// GET /phone_numbers/{id}
func (c *Client) RetrievePhoneNumber(ctx context.Context, params RetrievePhoneNumberParams) (RetrievePhoneNumberRes, error) {
	res, err := c.sendRetrievePhoneNumber(ctx, params)
	return res, err
}

func (c *Client) sendRetrievePhoneNumber(ctx context.Context, params RetrievePhoneNumberParams) (res RetrievePhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone_numbers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrievePhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrievePhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrievePhoneNumbersJob invokes RetrievePhoneNumbersJob operation.
//
// Retrieve a phone numbers job.
//
// GET /phone_numbers/jobs/{id}
func (c *Client) RetrievePhoneNumbersJob(ctx context.Context, params RetrievePhoneNumbersJobParams) (RetrievePhoneNumbersJobRes, error) {
	res, err := c.sendRetrievePhoneNumbersJob(ctx, params)
	return res, err
}

func (c *Client) sendRetrievePhoneNumbersJob(ctx context.Context, params RetrievePhoneNumbersJobParams) (res RetrievePhoneNumbersJobRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone_numbers/jobs/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrievePhoneNumbersJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrievePhoneNumbersJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveVerification invokes RetrieveVerification operation.
//
// Retrieve verification.
//
// GET /verifications/{verification_id}
func (c *Client) RetrieveVerification(ctx context.Context, params RetrieveVerificationParams) (RetrieveVerificationRes, error) {
	res, err := c.sendRetrieveVerification(ctx, params)
	return res, err
}

func (c *Client) sendRetrieveVerification(ctx context.Context, params RetrieveVerificationParams) (res RetrieveVerificationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verifications/"
	{
		// Encode "verification_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "verification_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VerificationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RetrieveVerification", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetrieveVerificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendDTMF invokes SendDTMF operation.
//
// Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.
// **Expected Webhooks:**
// There are no webhooks associated with this command.
//
// POST /calls/{call_control_id}/actions/send_dtmf
func (c *Client) SendDTMF(ctx context.Context, request *SendDTMFRequest, params SendDTMFParams) (SendDTMFRes, error) {
	res, err := c.sendSendDTMF(ctx, request, params)
	return res, err
}

func (c *Client) sendSendDTMF(ctx context.Context, request *SendDTMFRequest, params SendDTMFParams) (res SendDTMFRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/send_dtmf"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendDTMFRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "SendDTMF", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendDTMFResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendMessage invokes SendMessage operation.
//
// Send a message with a Phone Number, Alphanumeric Sender ID, Short Code or Number Pool.
// This endpoint allows you to send a message with any messaging resource.
// Current messaging resources include: long-code, short-code, number-pool, and
// alphanumeric-sender-id.
//
// POST /messages
func (c *Client) SendMessage(ctx context.Context, request OptCreateMessageRequest) (SendMessageRes, error) {
	res, err := c.sendSendMessage(ctx, request)
	return res, err
}

func (c *Client) sendSendMessage(ctx context.Context, request OptCreateMessageRequest) (res SendMessageRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "SendMessage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SlimListPhoneNumbers invokes SlimListPhoneNumbers operation.
//
// List phone numbers, This endpoint is a lighter version of the /phone_numbers endpoint having
// higher performance and rate limit.
//
// GET /phone_numbers/slim
func (c *Client) SlimListPhoneNumbers(ctx context.Context, params SlimListPhoneNumbersParams) (SlimListPhoneNumbersRes, error) {
	res, err := c.sendSlimListPhoneNumbers(ctx, params)
	return res, err
}

func (c *Client) sendSlimListPhoneNumbers(ctx context.Context, params SlimListPhoneNumbersParams) (res SlimListPhoneNumbersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/slim"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page[number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page[size]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page[size]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_connection" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_connection",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeConnection.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeTags.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterTag.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[phone_number]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[phone_number]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterPhoneNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[status]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[status]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[connection_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[connection_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterConnectionID.Get(); ok {
				return e.EncodeValue(conv.StringInt64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.connection_name][contains]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.connection_name][contains]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceConnectionNameContains.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.connection_name][starts_with]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.connection_name][starts_with]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceConnectionNameStartsWith.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.connection_name][ends_with]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.connection_name][ends_with]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceConnectionNameEndsWith.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.connection_name]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.connection_name]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceConnectionName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[voice.usage_payment_method]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[voice.usage_payment_method]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterVoiceUsagePaymentMethod.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[billing_group_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[billing_group_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterBillingGroupID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[emergency_address_id]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[emergency_address_id]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterEmergencyAddressID.Get(); ok {
				return e.EncodeValue(conv.StringInt64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter[customer_reference]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[customer_reference]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterCustomerReference.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "SlimListPhoneNumbers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSlimListPhoneNumbersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpeakCall invokes SpeakCall operation.
//
// Convert text to speech and play it back on the call. If multiple speak text commands are issued
// consecutively, the audio files will be placed in a queue awaiting playback.
// **Expected Webhooks:**
// - `call.speak.started`
// - `call.speak.ended`.
//
// POST /calls/{call_control_id}/actions/speak
func (c *Client) SpeakCall(ctx context.Context, request *SpeakRequest, params SpeakCallParams) (SpeakCallRes, error) {
	res, err := c.sendSpeakCall(ctx, request, params)
	return res, err
}

func (c *Client) sendSpeakCall(ctx context.Context, request *SpeakRequest, params SpeakCallParams) (res SpeakCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/speak"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSpeakCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "SpeakCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSpeakCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallFork invokes StartCallFork operation.
//
// Call forking allows you to stream the media from a call to a specific target in realtime.
// This stream can be used to enable realtime audio analysis to support a
// variety of use cases, including fraud detection, or the creation of AI-generated audio responses.
// Requests must specify either the `target` attribute or the `rx` and `tx` attributes.
// **Expected Webhooks:**
// - `call.fork.started`
// - `call.fork.stopped`
// **Simple Telnyx RTP Encapsulation Protocol (STREP)**
// *Note: This header/encapsulation is not used when the `rx` and `tx`
// parameters have been specified; it only applies when media is forked
// using the `target` attribute.*
// If the destination for forked media is specified using the "target"
// attribute, the RTP will be encapsulated in an extra Telnyx protocol,
// which adds a 24 byte header to the RTP payload in each packet. The STREP
// header includes the Call Control `call_leg_id` for stream
// identification, along with bits that represent the direction (inbound or
// outbound) of the media. This 24-byte header sits between the UDP header
// and the RTP header.
// The STREP header makes it possible to fork RTP for multiple calls (or
// two RTP streams for the same call) to the same IP:port, where the
// streams can be demultiplexed by your application using the information
// in the header. Of course, it's still possible to ignore this header
// completely, for example, if sending forked media for different calls to
// different ports or IP addresses. In this case, simply strip 24 bytes
// (or use the second byte to find the header length) from the received UDP
// payload to get the RTP (RTP header and payload).
// ```
// STREP Specification
// 0                   1                   2                   3
// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |       reserved (4 bytes, for UDP ports or anything else)      |
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |               The call_leg_id                                 |
// |                   from Call Control                           |
// |                       (128 bits / 16 bytes)                   |
// |                           (this is binary data)               |
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 11
// Static bits 11, always set to 11 to easily distinguish forked media
// from RTP (10) and T.38 media (usually 00) and SIP (which begins
// with a capital letter, so begins with bits 01). This is a magic number.
// Version
// Four bits to indicate the version number of the protocol, starting at 0001.
// L
// One bit to represent the leg of the call (A or B).
// 0 represents the A (first) leg of the call.
// 1 represents the B (second) leg of the call.
// D
// One bit to represent the direction of this RTP stream.
// 0 represents media received by Telnyx.
// 1 represents media transmitted by Telnyx.
// HeaderLen (1 byte)
// The length of the header in bytes.
// Note that this value does not include the length of the payload. The total
// size of the RTP can be calculated by subtracting the HeaderLen from the UDP
// length (minus 8 for the UDP header).
// In version 1, this value will always be 24.
// Reserved (6 bytes)
// Reserved for future use and to make sure that the header is a multiple of 32 bits
// Call Leg ID
// A 128-bit identifier for the call leg.
// This is the call_leg_id from Call Control.
// ```.
//
// POST /calls/{call_control_id}/actions/fork_start
func (c *Client) StartCallFork(ctx context.Context, request *StartForkingRequest, params StartCallForkParams) (StartCallForkRes, error) {
	res, err := c.sendStartCallFork(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallFork(ctx context.Context, request *StartForkingRequest, params StartCallForkParams) (res StartCallForkRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/fork_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallForkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallFork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallForkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallPlayback invokes StartCallPlayback operation.
//
// Play an audio file on the call. If multiple play audio commands are issued consecutively,
// the audio files will be placed in a queue awaiting playback.
// *Notes:*
// - When `overlay` is enabled, `target_legs` is limited to `self`.
// - A customer cannot Play Audio with `overlay=true` unless there is a Play Audio with
// `overlay=false` actively playing.
// **Expected Webhooks:**
// - `call.playback.started`
// - `call.playback.ended`.
//
// POST /calls/{call_control_id}/actions/playback_start
func (c *Client) StartCallPlayback(ctx context.Context, request *PlayAudioUrlRequest, params StartCallPlaybackParams) (StartCallPlaybackRes, error) {
	res, err := c.sendStartCallPlayback(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallPlayback(ctx context.Context, request *PlayAudioUrlRequest, params StartCallPlaybackParams) (res StartCallPlaybackRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/playback_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallPlaybackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallPlayback", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallPlaybackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallRecord invokes StartCallRecord operation.
//
// Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop
// Recording command.
// **Expected Webhooks:**
// - `call.recording.saved`.
//
// POST /calls/{call_control_id}/actions/record_start
func (c *Client) StartCallRecord(ctx context.Context, request *StartRecordingRequest, params StartCallRecordParams) (StartCallRecordRes, error) {
	res, err := c.sendStartCallRecord(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallRecord(ctx context.Context, request *StartRecordingRequest, params StartCallRecordParams) (res StartCallRecordRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/record_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallRecordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallRecord", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallStreaming invokes StartCallStreaming operation.
//
// Start streaming the media from a call to a specific WebSocket address or Dialogflow connection in
// near-realtime. Audio will be delivered as base64-encoded RTP payload (raw audio), wrapped in JSON
// payloads.
// **Example: Starting a stream to a Websocket address**
// The `stream_url` param is mandatory.
// ```
// curl -X POST \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Authorization: Bearer YOUR_API_KEY" \
// --data '{
// "stream_url": "wss://www.example.com/websocket",\
// "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d",\
// "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901" \
// }' \
// https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
// ```
// **Example: Starting a stream to a Dialogflow connection**
// Enable the Dialogflow integration by sending `"enable_dialogflow": true` in the request. You need
// to have a Dialogflow connection associated with your Call Control application first, [click here
// for instructions](https://developers.telnyx.com/docs/voice/programmable-voice/dialogflow-es).
// ```
// curl -X POST \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Authorization: Bearer YOUR_API_KEY" \
// --data '{
// "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d", \
// "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901", \
// "enable_dialogflow": true \
// }' \
// https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
// ```
// **Expected Webhooks:**
// - `streaming.started`
// - `streaming.stopped`
// - `streaming.failed`
// **WebSocket events**
// When the WebSocket connection is established, the following event is being sent over it:
// ```
// {
// "event": "connected",
// "version": "1.0.0"
// }
// ```
// And when the call is started, an event which contains information about the encoding and
// `stream_id` that identifies a particular stream:
// ```
// {
// "event": "start",
// "sequence_number": "1",
// "start": {
// "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
// "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
// "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
// "media_format": {
// "encoding": "audio/x-mulaw",
// "sample_rate": 8000,
// "channels": 1
// }
// },
// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
// }
// ```
// The start event is followed by the following media events that contain base64-encoded RTP payload
// (raw audio, no RTP headers) (:
// ```
// {
// "event": "media",
// "sequence_number": "4",
// "media": {
// "track": "inbound/outbound",
// "chunk": "2",
// "timestamp": "5",
// "payload": "no+JhoaJjpzSHxAKBgYJD...IsSbjomGhoqQn1Ic"
// },
// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
// }
// ```
// Please note that the order of events is not guaranteed and the chunk number can be used to reorder
// the events.
// When the call ends, the stop event over WebSockets connection is sent:
// ```
// {
// "event": "stop",
// "sequence_number": "5",
// "stop": {
// "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
// "call_control_id": "v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQ"
// },
// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
// }
// ```
// **Bidirectional Media Streaming**
// Media can be sent back to the call through the websocket as well. This is done in a way very
// similar to the [playback_start](https://developers.telnyx.
// com/docs/api/v2/call-control/Call-Commands#callPlaybackStart)
// command, when using a base64 encoded mp3 file in the payload. Simply send a packet to the
// websocket connection as follows:
// ```
// {
// "event": "media",
// "media": {
// "payload" : <your base64 encoded mp3 file>
// }
// }
// ```
// The payload, which is a base64-encoded mp3 file, will be played on the call.
// Some limitations to be aware of:
// - Media payloads can only be submitted once per second.
// - Media _must_ be base64 encoded mp3
// **Stream Errors**
// Any errors in the media packet, including when a rate limit is reached, will result in an error
// frame being
// sent to your websocket server. The error frame will appear as follows:
// ```
// {
// "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc",
// "event": "error",
// "sequence_number": "6",
// "error": {
// "title": "rate_limit_reached",
// "code": "100005",
// "detail": "Too many requests"
// }
// }
// ```
// Possible errors are as follows:
// - Error 100002: `"unknown_error"`
// - Error 100003: `"malformed_frame"`
// - Error 100004: `"invalid_media"`
// - Error 100005: `"rate_limit_reached"`.
//
// POST /calls/{call_control_id}/actions/streaming_start
func (c *Client) StartCallStreaming(ctx context.Context, request *StartStreamingRequest, params StartCallStreamingParams) (StartCallStreamingRes, error) {
	res, err := c.sendStartCallStreaming(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallStreaming(ctx context.Context, request *StartStreamingRequest, params StartCallStreamingParams) (res StartCallStreamingRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/streaming_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallStreamingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallStreaming", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallStreamingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartCallTranscription invokes StartCallTranscription operation.
//
// Start real-time transcription. Transcription will stop on call hang-up, or can be initiated via
// the Transcription stop command.
// **Expected Webhooks:**
// - `call.transcription`.
//
// POST /calls/{call_control_id}/actions/transcription_start
func (c *Client) StartCallTranscription(ctx context.Context, request *TranscriptionStartRequest, params StartCallTranscriptionParams) (StartCallTranscriptionRes, error) {
	res, err := c.sendStartCallTranscription(ctx, request, params)
	return res, err
}

func (c *Client) sendStartCallTranscription(ctx context.Context, request *TranscriptionStartRequest, params StartCallTranscriptionParams) (res StartCallTranscriptionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/transcription_start"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartCallTranscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartCallTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartCallTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartTeXMLCallRecording invokes StartTeXMLCallRecording operation.
//
// Starts recording with specified parameters for call idientified by call_sid.
//
// POST /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json
func (c *Client) StartTeXMLCallRecording(ctx context.Context, request OptTexmlCreateCallRecordingRequestBody, params StartTeXMLCallRecordingParams) (StartTeXMLCallRecordingRes, error) {
	res, err := c.sendStartTeXMLCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendStartTeXMLCallRecording(ctx context.Context, request OptTexmlCreateCallRecordingRequestBody, params StartTeXMLCallRecordingParams) (res StartTeXMLCallRecordingRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartTeXMLCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StartTeXMLCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStartTeXMLCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallFork invokes StopCallFork operation.
//
// Stop forking a call.
// **Expected Webhooks:**
// - `call.fork.stopped`.
//
// POST /calls/{call_control_id}/actions/fork_stop
func (c *Client) StopCallFork(ctx context.Context, request *StopForkingRequest, params StopCallForkParams) (StopCallForkRes, error) {
	res, err := c.sendStopCallFork(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallFork(ctx context.Context, request *StopForkingRequest, params StopCallForkParams) (res StopCallForkRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/fork_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallForkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallFork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallForkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallGather invokes StopCallGather operation.
//
// Stop current gather.
// **Expected Webhooks:**
// - `call.gather.ended`.
//
// POST /calls/{call_control_id}/actions/gather_stop
func (c *Client) StopCallGather(ctx context.Context, request *StopGatherRequest, params StopCallGatherParams) (StopCallGatherRes, error) {
	res, err := c.sendStopCallGather(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallGather(ctx context.Context, request *StopGatherRequest, params StopCallGatherParams) (res StopCallGatherRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/gather_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallGatherRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallGather", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallGatherResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallPlayback invokes StopCallPlayback operation.
//
// Stop audio being played on the call.
// **Expected Webhooks:**
// - `call.playback.ended` or `call.speak.ended`.
//
// POST /calls/{call_control_id}/actions/playback_stop
func (c *Client) StopCallPlayback(ctx context.Context, request *PlaybackStopRequest, params StopCallPlaybackParams) (StopCallPlaybackRes, error) {
	res, err := c.sendStopCallPlayback(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallPlayback(ctx context.Context, request *PlaybackStopRequest, params StopCallPlaybackParams) (res StopCallPlaybackRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/playback_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallPlaybackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallPlayback", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallPlaybackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallRecording invokes StopCallRecording operation.
//
// Stop recording the call.
// **Expected Webhooks:**
// - `call.recording.saved`.
//
// POST /calls/{call_control_id}/actions/record_stop
func (c *Client) StopCallRecording(ctx context.Context, request *StopRecordingRequest, params StopCallRecordingParams) (StopCallRecordingRes, error) {
	res, err := c.sendStopCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallRecording(ctx context.Context, request *StopRecordingRequest, params StopCallRecordingParams) (res StopCallRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/record_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallStreaming invokes StopCallStreaming operation.
//
// Stop streaming a call to a WebSocket.
// **Expected Webhooks:**
// - `streaming.stopped`.
//
// POST /calls/{call_control_id}/actions/streaming_stop
func (c *Client) StopCallStreaming(ctx context.Context, request *StopStreamingRequest, params StopCallStreamingParams) (StopCallStreamingRes, error) {
	res, err := c.sendStopCallStreaming(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallStreaming(ctx context.Context, request *StopStreamingRequest, params StopCallStreamingParams) (res StopCallStreamingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/streaming_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallStreamingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallStreaming", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallStreamingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopCallTranscription invokes StopCallTranscription operation.
//
// Stop real-time transcription.
//
// POST /calls/{call_control_id}/actions/transcription_stop
func (c *Client) StopCallTranscription(ctx context.Context, request *TranscriptionStopRequest, params StopCallTranscriptionParams) (StopCallTranscriptionRes, error) {
	res, err := c.sendStopCallTranscription(ctx, request, params)
	return res, err
}

func (c *Client) sendStopCallTranscription(ctx context.Context, request *TranscriptionStopRequest, params StopCallTranscriptionParams) (res StopCallTranscriptionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/transcription_stop"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopCallTranscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "StopCallTranscription", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStopCallTranscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TransferCall invokes TransferCall operation.
//
// Transfer a call to a new destination. If the transfer is unsuccessful, a `call.hangup` webhook for
// the other call (Leg B) will be sent indicating that the transfer could not be completed. The
// original call will remain active and may be issued additional commands, potentially transfering
// the call to an alternate destination.
// **Expected Webhooks:**
// - `call.initiated`
// - `call.bridged` to Leg B
// - `call.answered` or `call.hangup`
// - `call.machine.detection.ended` if `answering_machine_detection` was requested
// - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end
// of machine greeting
// - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
// - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and
// a beep was detected.
//
// POST /calls/{call_control_id}/actions/transfer
func (c *Client) TransferCall(ctx context.Context, request *TransferCallRequest, params TransferCallParams) (TransferCallRes, error) {
	res, err := c.sendTransferCall(ctx, request, params)
	return res, err
}

func (c *Client) sendTransferCall(ctx context.Context, request *TransferCallRequest, params TransferCallParams) (res TransferCallRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/transfer"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTransferCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "TransferCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTransferCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnassignPhoneNumber invokes UnassignPhoneNumber operation.
//
// Unassign a phone number from a channel zone.
//
// DELETE /channel_zones/{channel_zone_id}/channel_zone_phone_numbers/{phone_number}
func (c *Client) UnassignPhoneNumber(ctx context.Context, params UnassignPhoneNumberParams) (UnassignPhoneNumberRes, error) {
	res, err := c.sendUnassignPhoneNumber(ctx, params)
	return res, err
}

func (c *Client) sendUnassignPhoneNumber(ctx context.Context, params UnassignPhoneNumberParams) (res UnassignPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/channel_zones/"
	{
		// Encode "channel_zone_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channel_zone_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChannelZoneID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/channel_zone_phone_numbers/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UnassignPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUnassignPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBulkTelephonyCredential invokes UpdateBulkTelephonyCredential operation.
//
// Update several credentials in bulk.
//
// PATCH /actions/bulk/telephony_credentials
func (c *Client) UpdateBulkTelephonyCredential(ctx context.Context, request *BulkCredentialRequest, params UpdateBulkTelephonyCredentialParams) (UpdateBulkTelephonyCredentialRes, error) {
	res, err := c.sendUpdateBulkTelephonyCredential(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateBulkTelephonyCredential(ctx context.Context, request *BulkCredentialRequest, params UpdateBulkTelephonyCredentialParams) (res UpdateBulkTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/actions/bulk/telephony_credentials"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter[tag]" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter[tag]",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilterTag))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBulkTelephonyCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateBulkTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBulkTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCallControlApplication invokes UpdateCallControlApplication operation.
//
// Updates settings of an existing call control application.
//
// PATCH /call_control_applications/{id}
func (c *Client) UpdateCallControlApplication(ctx context.Context, request *UpdateCallControlApplicationRequest, params UpdateCallControlApplicationParams) (UpdateCallControlApplicationRes, error) {
	res, err := c.sendUpdateCallControlApplication(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCallControlApplication(ctx context.Context, request *UpdateCallControlApplicationRequest, params UpdateCallControlApplicationParams) (res UpdateCallControlApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/call_control_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCallControlApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateCallControlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateCallControlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateClientState invokes UpdateClientState operation.
//
// Updates client state.
//
// PUT /calls/{call_control_id}/actions/client_state_update
func (c *Client) UpdateClientState(ctx context.Context, request *ClientStateUpdateRequest, params UpdateClientStateParams) (UpdateClientStateRes, error) {
	res, err := c.sendUpdateClientState(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateClientState(ctx context.Context, request *ClientStateUpdateRequest, params UpdateClientStateParams) (res UpdateClientStateRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/calls/"
	{
		// Encode "call_control_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_control_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallControlID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/client_state_update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateClientStateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateClientState", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateClientStateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCustomStorageCredentials invokes UpdateCustomStorageCredentials operation.
//
// Updates a stored custom credentials configuration.
//
// PUT /custom_storage_credentials/{connection_id}
func (c *Client) UpdateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params UpdateCustomStorageCredentialsParams) (UpdateCustomStorageCredentialsRes, error) {
	res, err := c.sendUpdateCustomStorageCredentials(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCustomStorageCredentials(ctx context.Context, request *CustomStorageConfiguration, params UpdateCustomStorageCredentialsParams) (res UpdateCustomStorageCredentialsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/custom_storage_credentials/"
	{
		// Encode "connection_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connection_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConnectionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateCustomStorageCredentialsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateCustomStorageCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateCustomStorageCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateExternalConnectionPhoneNumber invokes UpdateExternalConnectionPhoneNumber operation.
//
// Asynchronously update settings of the phone number associated with the given external connection.
//
// PATCH /external_connections/{id}/phone_numbers/{phone_number_id}
func (c *Client) UpdateExternalConnectionPhoneNumber(ctx context.Context, request *UpdateExternalConnectionPhoneNumberRequest, params UpdateExternalConnectionPhoneNumberParams) (UpdateExternalConnectionPhoneNumberRes, error) {
	res, err := c.sendUpdateExternalConnectionPhoneNumber(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateExternalConnectionPhoneNumber(ctx context.Context, request *UpdateExternalConnectionPhoneNumberRequest, params UpdateExternalConnectionPhoneNumberParams) (res UpdateExternalConnectionPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/external_connections/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/phone_numbers/"
	{
		// Encode "phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateExternalConnectionPhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateExternalConnectionPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateExternalConnectionPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateNetwork invokes UpdateNetwork operation.
//
// Update a Network.
//
// PATCH /networks/{id}
func (c *Client) UpdateNetwork(ctx context.Context, request *NetworkCreate, params UpdateNetworkParams) (UpdateNetworkRes, error) {
	res, err := c.sendUpdateNetwork(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateNetwork(ctx context.Context, request *NetworkCreate, params UpdateNetworkParams) (res UpdateNetworkRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/networks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateNetworkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateNotificationChannel invokes UpdateNotificationChannel operation.
//
// Update a notification channel.
//
// PATCH /notification_channels/{id}
func (c *Client) UpdateNotificationChannel(ctx context.Context, request *NotificationChannel, params UpdateNotificationChannelParams) (UpdateNotificationChannelRes, error) {
	res, err := c.sendUpdateNotificationChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateNotificationChannel(ctx context.Context, request *NotificationChannel, params UpdateNotificationChannelParams) (res UpdateNotificationChannelRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/notification_channels/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateNotificationChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateNotificationChannel", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateNotificationChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateNumberOrderPhoneNumber invokes UpdateNumberOrderPhoneNumber operation.
//
// Updates a number order phone number.
//
// PATCH /number_order_phone_numbers/{number_order_phone_number_id}
func (c *Client) UpdateNumberOrderPhoneNumber(ctx context.Context, request *UpdateNumberOrderPhoneNumberRequest, params UpdateNumberOrderPhoneNumberParams) (UpdateNumberOrderPhoneNumberRes, error) {
	res, err := c.sendUpdateNumberOrderPhoneNumber(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateNumberOrderPhoneNumber(ctx context.Context, request *UpdateNumberOrderPhoneNumberRequest, params UpdateNumberOrderPhoneNumberParams) (res UpdateNumberOrderPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/number_order_phone_numbers/"
	{
		// Encode "number_order_phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "number_order_phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NumberOrderPhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateNumberOrderPhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateNumberOrderPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateNumberOrderPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOutboundChannels invokes UpdateOutboundChannels operation.
//
// Update the inbound channels for the account.
//
// PATCH /phone_numbers/inbound_channels
func (c *Client) UpdateOutboundChannels(ctx context.Context, request *UpdateOutboundChannelsReq) (UpdateOutboundChannelsRes, error) {
	res, err := c.sendUpdateOutboundChannels(ctx, request)
	return res, err
}

func (c *Client) sendUpdateOutboundChannels(ctx context.Context, request *UpdateOutboundChannelsReq) (res UpdateOutboundChannelsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/phone_numbers/inbound_channels"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOutboundChannelsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateOutboundChannels", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateOutboundChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePhoneNumber invokes UpdatePhoneNumber operation.
//
// Update a phone number.
//
// PATCH /phone_numbers/{id}
func (c *Client) UpdatePhoneNumber(ctx context.Context, request *UpdatePhoneNumberRequest, params UpdatePhoneNumberParams) (UpdatePhoneNumberRes, error) {
	res, err := c.sendUpdatePhoneNumber(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePhoneNumber(ctx context.Context, request *UpdatePhoneNumberRequest, params UpdatePhoneNumberParams) (res UpdatePhoneNumberRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/phone_numbers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdatePhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdatePhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePhoneNumberMessagingSettings invokes UpdatePhoneNumberMessagingSettings operation.
//
// Update a phone number with messaging settings.
//
// PATCH /phone_numbers/{id}/messaging
func (c *Client) UpdatePhoneNumberMessagingSettings(ctx context.Context, request *UpdatePhoneNumberMessagingSettingsRequest, params UpdatePhoneNumberMessagingSettingsParams) (UpdatePhoneNumberMessagingSettingsRes, error) {
	res, err := c.sendUpdatePhoneNumberMessagingSettings(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePhoneNumberMessagingSettings(ctx context.Context, request *UpdatePhoneNumberMessagingSettingsRequest, params UpdatePhoneNumberMessagingSettingsParams) (res UpdatePhoneNumberMessagingSettingsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone_numbers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messaging"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePhoneNumberMessagingSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdatePhoneNumberMessagingSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdatePhoneNumberMessagingSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePhoneNumberVoiceSettings invokes UpdatePhoneNumberVoiceSettings operation.
//
// Update a phone number with voice settings.
//
// PATCH /phone_numbers/{id}/voice
func (c *Client) UpdatePhoneNumberVoiceSettings(ctx context.Context, request *UpdatePhoneNumberVoiceSettingsRequest, params UpdatePhoneNumberVoiceSettingsParams) (UpdatePhoneNumberVoiceSettingsRes, error) {
	res, err := c.sendUpdatePhoneNumberVoiceSettings(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePhoneNumberVoiceSettings(ctx context.Context, request *UpdatePhoneNumberVoiceSettingsRequest, params UpdatePhoneNumberVoiceSettingsParams) (res UpdatePhoneNumberVoiceSettingsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/phone_numbers/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/voice"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePhoneNumberVoiceSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdatePhoneNumberVoiceSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdatePhoneNumberVoiceSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePortoutStatus invokes UpdatePortoutStatus operation.
//
// Authorize or reject portout request.
//
// PATCH /portouts/{id}/{status}
func (c *Client) UpdatePortoutStatus(ctx context.Context, request *UpdatePortoutStatusReq, params UpdatePortoutStatusParams) (UpdatePortoutStatusRes, error) {
	res, err := c.sendUpdatePortoutStatus(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePortoutStatus(ctx context.Context, request *UpdatePortoutStatusReq, params UpdatePortoutStatusParams) (res UpdatePortoutStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/portouts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "status" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "status",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Status)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePortoutStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdatePortoutStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdatePortoutStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateProfile invokes UpdateProfile operation.
//
// Update an existing Verified Calls Display Profile and allows adding/removing nested Call Reasons
// and Phone Numbers. Different attributes can be updated depending on the Verified Calls Display
// Profile's status: For the VERIFICATION_STATE_PENDING status, no fields can be updated. For the
// VERIFICATION_STATE_VERIFIED status, it is allowed only to add/remove Call Reaons and Phone Numbers.
//
//	For the other statuses, all fields can be updated. All existing Call Reasons and Phone Numbers
//
// must be sent during the request, or the update will fail.
//
// PATCH /verified_calls_display_profiles/{id}
func (c *Client) UpdateProfile(ctx context.Context, request *UpdateVerifiedCallsDisplayProfileRequest, params UpdateProfileParams) (UpdateProfileRes, error) {
	res, err := c.sendUpdateProfile(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateProfile(ctx context.Context, request *UpdateVerifiedCallsDisplayProfileRequest, params UpdateProfileParams) (res UpdateProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verified_calls_display_profiles/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTeXMLCallRecording invokes UpdateTeXMLCallRecording operation.
//
// Updates recording resource for particular call.
//
// POST /texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings/{recording_sid}.json
func (c *Client) UpdateTeXMLCallRecording(ctx context.Context, request OptTexmlUpdateCallRecordingRequestBody, params UpdateTeXMLCallRecordingParams) (UpdateTeXMLCallRecordingRes, error) {
	res, err := c.sendUpdateTeXMLCallRecording(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTeXMLCallRecording(ctx context.Context, request OptTexmlUpdateCallRecordingRequestBody, params UpdateTeXMLCallRecordingParams) (res UpdateTeXMLCallRecordingRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Recordings/"
	{
		// Encode "recording_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recording_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RecordingSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = ".json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTeXMLCallRecordingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTeXMLCallRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTeXMLCallRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTelephonyCredential invokes UpdateTelephonyCredential operation.
//
// Update an existing credential.
//
// PATCH /telephony_credentials/{id}
func (c *Client) UpdateTelephonyCredential(ctx context.Context, request *TelephonyCredentialUpdateRequest, params UpdateTelephonyCredentialParams) (UpdateTelephonyCredentialRes, error) {
	res, err := c.sendUpdateTelephonyCredential(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTelephonyCredential(ctx context.Context, request *TelephonyCredentialUpdateRequest, params UpdateTelephonyCredentialParams) (res UpdateTelephonyCredentialRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/telephony_credentials/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTelephonyCredentialRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTelephonyCredential", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTelephonyCredentialResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlApplication invokes UpdateTexmlApplication operation.
//
// Updates settings of an existing TeXML Application.
//
// PATCH /texml_applications/{id}
func (c *Client) UpdateTexmlApplication(ctx context.Context, request *UpdateTexmlApplicationRequest, params UpdateTexmlApplicationParams) (UpdateTexmlApplicationRes, error) {
	res, err := c.sendUpdateTexmlApplication(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlApplication(ctx context.Context, request *UpdateTexmlApplicationRequest, params UpdateTexmlApplicationParams) (res UpdateTexmlApplicationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/texml_applications/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringInt64ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlApplicationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlApplication", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlApplicationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlCall invokes UpdateTexmlCall operation.
//
// Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase
// as specified in the example.
//
// POST /texml/calls/{call_sid}/update
func (c *Client) UpdateTexmlCall(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallParams) (*UpdateTeXMLCallResponse, error) {
	res, err := c.sendUpdateTexmlCall(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlCall(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallParams) (res *UpdateTeXMLCallResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/texml/calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlCall", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlCallByAccount invokes UpdateTexmlCallByAccount operation.
//
// Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase
// as specified in the example.
//
// POST /texml/Accounts/{account_sid}/Calls/{call_sid}
func (c *Client) UpdateTexmlCallByAccount(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallByAccountParams) (*GetCallResponse, error) {
	res, err := c.sendUpdateTexmlCallByAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlCallByAccount(ctx context.Context, request *UpdateCallRequest, params UpdateTexmlCallByAccountParams) (res *GetCallResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Calls/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlCallByAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlCallByAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlCallByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlConference invokes UpdateTexmlConference operation.
//
// Updates a conference resource.
//
// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}
func (c *Client) UpdateTexmlConference(ctx context.Context, request *UpdateConferenceRequest, params UpdateTexmlConferenceParams) (UpdateTexmlConferenceRes, error) {
	res, err := c.sendUpdateTexmlConference(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlConference(ctx context.Context, request *UpdateConferenceRequest, params UpdateTexmlConferenceParams) (res UpdateTexmlConferenceRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlConferenceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlConference", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlConferenceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTexmlConferenceParticipant invokes UpdateTexmlConferenceParticipant operation.
//
// Updates a conference participant.
//
// POST /texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}
func (c *Client) UpdateTexmlConferenceParticipant(ctx context.Context, request *UpdateConferenceParticipantRequest, params UpdateTexmlConferenceParticipantParams) (UpdateTexmlConferenceParticipantRes, error) {
	res, err := c.sendUpdateTexmlConferenceParticipant(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTexmlConferenceParticipant(ctx context.Context, request *UpdateConferenceParticipantRequest, params UpdateTexmlConferenceParticipantParams) (res UpdateTexmlConferenceParticipantRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/texml/Accounts/"
	{
		// Encode "account_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/Conferences/"
	{
		// Encode "conference_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conference_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConferenceSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/Participants/"
	{
		// Encode "call_sid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "call_sid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CallSid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTexmlConferenceParticipantRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateTexmlConferenceParticipant", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateTexmlConferenceParticipantResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVerifyProfile invokes UpdateVerifyProfile operation.
//
// Update Verify profile.
//
// PATCH /verify_profiles/{verify_profile_id}
func (c *Client) UpdateVerifyProfile(ctx context.Context, request *UpdateVerifyProfileReq, params UpdateVerifyProfileParams) (UpdateVerifyProfileRes, error) {
	res, err := c.sendUpdateVerifyProfile(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVerifyProfile(ctx context.Context, request *UpdateVerifyProfileReq, params UpdateVerifyProfileParams) (res UpdateVerifyProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/verify_profiles/"
	{
		// Encode "verify_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "verify_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VerifyProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVerifyProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateVerifyProfile", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVerifyProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VerifyVerificationCode invokes VerifyVerificationCode operation.
//
// Submit verification code.
//
// POST /verified_numbers/{phone_number}/actions/verify
func (c *Client) VerifyVerificationCode(ctx context.Context, request *VerifyVerificationCodeReq, params VerifyVerificationCodeParams) (VerifyVerificationCodeRes, error) {
	res, err := c.sendVerifyVerificationCode(ctx, request, params)
	return res, err
}

func (c *Client) sendVerifyVerificationCode(ctx context.Context, request *VerifyVerificationCodeReq, params VerifyVerificationCodeParams) (res VerifyVerificationCodeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/verified_numbers/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/verify"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeVerifyVerificationCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "VerifyVerificationCode", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVerifyVerificationCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VerifyVerificationCodeByPhoneNumber invokes VerifyVerificationCodeByPhoneNumber operation.
//
// Submit verification code.
//
// POST /verifications/by_phone_number/{phone_number}/actions/verify
func (c *Client) VerifyVerificationCodeByPhoneNumber(ctx context.Context, request *VerifyVerificationCodeRequest, params VerifyVerificationCodeByPhoneNumberParams) (VerifyVerificationCodeByPhoneNumberRes, error) {
	res, err := c.sendVerifyVerificationCodeByPhoneNumber(ctx, request, params)
	return res, err
}

func (c *Client) sendVerifyVerificationCodeByPhoneNumber(ctx context.Context, request *VerifyVerificationCodeRequest, params VerifyVerificationCodeByPhoneNumberParams) (res VerifyVerificationCodeByPhoneNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/verifications/by_phone_number/"
	{
		// Encode "phone_number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/verify"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeVerifyVerificationCodeByPhoneNumberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "VerifyVerificationCodeByPhoneNumber", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVerifyVerificationCodeByPhoneNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ViewRoomRecording invokes ViewRoomRecording operation.
//
// View a room recording.
//
// GET /room_recordings/{room_recording_id}
func (c *Client) ViewRoomRecording(ctx context.Context, params ViewRoomRecordingParams) (ViewRoomRecordingRes, error) {
	res, err := c.sendViewRoomRecording(ctx, params)
	return res, err
}

func (c *Client) sendViewRoomRecording(ctx context.Context, params ViewRoomRecordingParams) (res ViewRoomRecordingRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/room_recordings/"
	{
		// Encode "room_recording_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "room_recording_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RoomRecordingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ViewRoomRecording", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeViewRoomRecordingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
